diff --git a/Carbonite.Gathermate2_Data/Carbonite.Gathermate2_Data-Mists.toc b/Carbonite.Gathermate2_Data/Carbonite.Gathermate2_Data-Mists.toc
index bcda066..8c9d18c 100644
--- a/Carbonite.Gathermate2_Data/Carbonite.Gathermate2_Data-Mists.toc
+++ b/Carbonite.Gathermate2_Data/Carbonite.Gathermate2_Data-Mists.toc
@@ -1,4 +1,4 @@
-## Interface: 50501
+## Interface: 50502
 ## Notes: Wowhead Data dump for GatherMate2
 ## Title: Carbonite GatherMate2Data - Classic @project-version@
 ## Author: kagaro, Xinhuan, Rythal (repackaging for Carb), IrcDirk (new versions for Carb)
diff --git a/Carbonite.Notes/Bindings.xml b/Carbonite.Notes/Bindings.xml
index 3742ef1..9d9d4ae 100644
--- a/Carbonite.Notes/Bindings.xml
+++ b/Carbonite.Notes/Bindings.xml
@@ -1,5 +1,5 @@
-<Bindings>
-	<Binding name="NxTOGGLEFAV" header="CarboniteNotes" category="Carbonite">
-		Nx.NXFavKeyToggleShow();
-	</Binding> 
-</Bindings>
+<Bindings>
+	<Binding name="NxTOGGLEFAV" header="CarboniteNotes" category="Carbonite">
+		Nx.NXFavKeyToggleShow();
+	</Binding> 
+</Bindings>
diff --git a/Carbonite.Notes/Carbonite.Notes.toc b/Carbonite.Notes/Carbonite.Notes.toc
index 9ecfa2e..f5f3eb3 100644
--- a/Carbonite.Notes/Carbonite.Notes.toc
+++ b/Carbonite.Notes/Carbonite.Notes.toc
@@ -1,13 +1,13 @@
-## Interface: 50501, 11508
-## Title: Carbonite Notes @project-version@
-## Version: @project-version@
-## Author: No one
-## Notes: Released Under GPL
-## DefaultState: Enabled
-## LoadOnDemand: 0
-## SavedVariables: NXNotes
-## RequiredDeps: Carbonite
-
-Locales\locales.xml
-NxFav.lua
-
+## Interface: 50502, 11508
+## Title: Carbonite Notes @project-version@
+## Version: @project-version@
+## Author: No one
+## Notes: Released Under GPL
+## DefaultState: Enabled
+## LoadOnDemand: 0
+## SavedVariables: NXNotes
+## RequiredDeps: Carbonite
+
+Locales\locales.xml
+NxFav.lua
+
diff --git a/Carbonite.Quests/Bindings.xml b/Carbonite.Quests/Bindings.xml
index 1697ab7..f184921 100644
--- a/Carbonite.Quests/Bindings.xml
+++ b/Carbonite.Quests/Bindings.xml
@@ -1,8 +1,8 @@
-<Bindings>
-	<Binding name="NxTOGGLEWATCHMINI" header="CarboniteQuests" category="Carbonite">
-		Nx.NXWatchKeyToggleMini();
-	</Binding>
-	<Binding name="NxWATCHUSEITEM" category="Carbonite">
-		Nx.NXWatchKeyUseItem();
-	</Binding>
-</Bindings>
+<Bindings>
+	<Binding name="NxTOGGLEWATCHMINI" header="CarboniteQuests" category="Carbonite">
+		Nx.NXWatchKeyToggleMini();
+	</Binding>
+	<Binding name="NxWATCHUSEITEM" category="Carbonite">
+		Nx.NXWatchKeyUseItem();
+	</Binding>
+</Bindings>
diff --git a/Carbonite.Quests/Carbonite.Quests-Mists.toc b/Carbonite.Quests/Carbonite.Quests-Mists.toc
index 599ef2f..8a63a9d 100644
--- a/Carbonite.Quests/Carbonite.Quests-Mists.toc
+++ b/Carbonite.Quests/Carbonite.Quests-Mists.toc
@@ -1,4 +1,4 @@
-## Interface: 50501
+## Interface: 50502
 ## Title: Carbonite Quest - Classic @project-version@
 ## Version: @project-version@
 ## Author: No One
diff --git a/Carbonite.Social/Carbonite.Social.toc b/Carbonite.Social/Carbonite.Social.toc
index db6107d..3c6f945 100644
--- a/Carbonite.Social/Carbonite.Social.toc
+++ b/Carbonite.Social/Carbonite.Social.toc
@@ -1,13 +1,13 @@
-## Interface: 50501, 11508
-## Title: Carbonite Social & Punks @project-version@
-## Version: @project-version@
-## Author: No One
-## Notes: Released Under GPL
-## DefaultState: Enabled
-## LoadOnDemand: 0
-## SavedVariables: NXSocial
-## RequiredDeps: Carbonite
-
-Locales\locales.xml
-NxSocial.lua
-
+## Interface: 50502, 11508
+## Title: Carbonite Social & Punks @project-version@
+## Version: @project-version@
+## Author: No One
+## Notes: Released Under GPL
+## DefaultState: Enabled
+## LoadOnDemand: 0
+## SavedVariables: NXSocial
+## RequiredDeps: Carbonite
+
+Locales\locales.xml
+NxSocial.lua
+
diff --git a/Carbonite.Social/Locales/locales.xml b/Carbonite.Social/Locales/locales.xml
index 11a90c8..5e22d36 100644
--- a/Carbonite.Social/Locales/locales.xml
+++ b/Carbonite.Social/Locales/locales.xml
@@ -1,14 +1,14 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\..\FrameXML\UI.xsd">
-	<Include file="enUS.lua"/>
-	<Include file="deDE.lua"/>
-	<Include file="esES.lua"/>
-	<Include file="esMX.lua"/>
-	<Include file="frFR.lua"/>
-	<Include file="itIT.lua"/>
-	<Include file="koKR.lua"/>
-	<Include file="ptBR.lua"/>
-	<Include file="ruRU.lua"/>
-	<Include file="zhTW.lua"/>
-	<Include file="zhCN.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\..\FrameXML\UI.xsd">
+	<Include file="enUS.lua"/>
+	<Include file="deDE.lua"/>
+	<Include file="esES.lua"/>
+	<Include file="esMX.lua"/>
+	<Include file="frFR.lua"/>
+	<Include file="itIT.lua"/>
+	<Include file="koKR.lua"/>
+	<Include file="ptBR.lua"/>
+	<Include file="ruRU.lua"/>
+	<Include file="zhTW.lua"/>
+	<Include file="zhCN.lua"/>
+</Ui>
diff --git a/Carbonite.Warehouse/Bindings.xml b/Carbonite.Warehouse/Bindings.xml
index 688c408..a34c258 100644
--- a/Carbonite.Warehouse/Bindings.xml
+++ b/Carbonite.Warehouse/Bindings.xml
@@ -1,5 +1,5 @@
-<Bindings>
-	<Binding name="NxTOGGLEWAREHOUSE" header="CarboniteWarehouse" category="Carbonite" >
-		Nx.NXWarehouseKeyToggleShow();
-	</Binding>
-</Bindings>
+<Bindings>
+	<Binding name="NxTOGGLEWAREHOUSE" header="CarboniteWarehouse" category="Carbonite" >
+		Nx.NXWarehouseKeyToggleShow();
+	</Binding>
+</Bindings>
diff --git a/Carbonite.Warehouse/Carbonite.Warehouse.toc b/Carbonite.Warehouse/Carbonite.Warehouse.toc
index 7ade8b3..db4ea4b 100644
--- a/Carbonite.Warehouse/Carbonite.Warehouse.toc
+++ b/Carbonite.Warehouse/Carbonite.Warehouse.toc
@@ -1,13 +1,13 @@
-## Interface: 50501, 11508
-## Title: Carbonite Warehouse @project-version@
-## Version: @project-version@
-## Author: No One
-## Notes: Released Under GPL
-## DefaultState: Enabled
-## LoadOnDemand: 0
-## SavedVariables: NXWhouse
-## RequiredDeps: Carbonite
-
-Locales\locales.xml
-NxWarehouse.lua
-
+## Interface: 50502, 11508
+## Title: Carbonite Warehouse @project-version@
+## Version: @project-version@
+## Author: No One
+## Notes: Released Under GPL
+## DefaultState: Enabled
+## LoadOnDemand: 0
+## SavedVariables: NXWhouse
+## RequiredDeps: Carbonite
+
+Locales\locales.xml
+NxWarehouse.lua
+
diff --git a/Carbonite.Warehouse/Locales/locales.xml b/Carbonite.Warehouse/Locales/locales.xml
index 11a90c8..5e22d36 100644
--- a/Carbonite.Warehouse/Locales/locales.xml
+++ b/Carbonite.Warehouse/Locales/locales.xml
@@ -1,14 +1,14 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\..\FrameXML\UI.xsd">
-	<Include file="enUS.lua"/>
-	<Include file="deDE.lua"/>
-	<Include file="esES.lua"/>
-	<Include file="esMX.lua"/>
-	<Include file="frFR.lua"/>
-	<Include file="itIT.lua"/>
-	<Include file="koKR.lua"/>
-	<Include file="ptBR.lua"/>
-	<Include file="ruRU.lua"/>
-	<Include file="zhTW.lua"/>
-	<Include file="zhCN.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\..\FrameXML\UI.xsd">
+	<Include file="enUS.lua"/>
+	<Include file="deDE.lua"/>
+	<Include file="esES.lua"/>
+	<Include file="esMX.lua"/>
+	<Include file="frFR.lua"/>
+	<Include file="itIT.lua"/>
+	<Include file="koKR.lua"/>
+	<Include file="ptBR.lua"/>
+	<Include file="ruRU.lua"/>
+	<Include file="zhTW.lua"/>
+	<Include file="zhCN.lua"/>
+</Ui>
diff --git a/Carbonite/Carbonite-Mists.toc b/Carbonite/Carbonite-Mists.toc
index c57e4e7..318a5a1 100644
--- a/Carbonite/Carbonite-Mists.toc
+++ b/Carbonite/Carbonite-Mists.toc
@@ -1,4 +1,4 @@
-## Interface: 50501
+## Interface: 50502
 ## Title: Carbonite Maps - Classic @project-version@
 ## Version: @project-version@
 ## Author: No one
diff --git a/Carbonite/Carbonite.lua b/Carbonite/Carbonite.lua
index a976301..01f0d5a 100644
--- a/Carbonite/Carbonite.lua
+++ b/Carbonite/Carbonite.lua
@@ -730,6 +730,7 @@ function Nx.slashCommand (txt)
     if cmd == "" or cmd == "?" or cmd == "help" then
 
         Nx.prt ("Commands:")
+        Nx.prt (" editmode  (toggle quest objective rectangle editor)")
         Nx.prt (" goto [zone] x y  (set map goto)")
         Nx.prt (" gotoadd [zone] x y  (add map goto)")
         Nx.prt (" menu  (open menu)")
@@ -856,6 +857,9 @@ function Nx.slashCommand (txt)
     elseif cmd == "vehpos" then
         Nx.Map:GetMap (1):VehicleDumpPos()
 
+    elseif cmd == "editmode" then
+        Nx.Map:GetMap(1):ToggleEditMode()
+
     else
         local s = gsub (txt, "note%s*", "")
         Nx:SendCommMessage("carbmodule","CMD|" .. cmd .. "|" .. s,"WHISPER",UnitName("player"))
diff --git a/Carbonite/Data/Shared/NxMapGuide.lua b/Carbonite/Data/Shared/NxMapGuide.lua
index 66f646e..c932fe4 100644
--- a/Carbonite/Data/Shared/NxMapGuide.lua
+++ b/Carbonite/Data/Shared/NxMapGuide.lua
@@ -413,34 +413,6 @@ Nx.GuideInfo = {
             Name = "@E",
             Map = 2
         },
-        {
-            Name = "@O",
-            Map = 3
-        },
-        {
-            Name = "@N",
-            Map = 4
-        },
-        {
-            Name = "@M",
-            Map = 5
-        },
-        {
-            Name = "@P",
-            Map = 6
-        },
-        --[[{
-            Name = "@D",
-            Map = 7
-        },
-        {
-            Name = "@B",
-            Map = 8
-        },
-        {
-            Name = "@A",
-            Map = 9
-        },]]--
     },
     --[[{
         Name = L["Trade Skill"],
@@ -469,6 +441,20 @@ Nx.GuideInfo = {
 
 }
 
+-- Add MoP-specific continents to the Zone folder
+if isMoP then
+    -- Find the Zone folder in GuideInfo and add MoP continents
+    for _, folder in ipairs(Nx.GuideInfo) do
+        if folder.Name == L["Zone"] then
+            tinsert(folder, { Name = "@O", Map = 3 })  -- Outland
+            tinsert(folder, { Name = "@N", Map = 4 })  -- Northrend
+            tinsert(folder, { Name = "@M", Map = 5 })  -- Maelstrom
+            tinsert(folder, { Name = "@P", Map = 6 })  -- Pandaria
+            break
+        end
+    end
+end
+
 Nx.Map.Guide.FindType = nil
 
 function Nx.Map.Guide:Create (map)
@@ -965,21 +951,23 @@ function Nx.Map.Guide:PatchFolder (folder, parent)
             cont2 = Map.ContCnt
         end
         for cont = cont1, cont2 do
-            for _,id in pairs(Nx.Map.MapZones[cont]) do
-                local f = {}
-                local color, infoStr, minLvl = Map:GetMapNameDesc (id)
-                local name = Map:IdToName (id)
-                f.Name = format ("%s%s", color, name)
-                f.Column2 = infoStr
-                if not Map.MapWorldInfo[id] then
-                Nx.prt("err: " .. id)
+            if Nx.Map.MapZones[cont] then
+                for _,id in pairs(Nx.Map.MapZones[cont]) do
+                    local f = {}
+                    local color, infoStr, minLvl = Map:GetMapNameDesc (id)
+                    local name = Map:IdToName (id)
+                    f.Name = format ("%s%s", color, name)
+                    f.Column2 = infoStr
+                    if not Map.MapWorldInfo[id] then
+                    Nx.prt("err: " .. id)
+                    end
+                    f.T = "#Map" .. id
+                    f.Tx = parent.Tx
+                    f.MId = id
+                    f.SrtN = name
+                    f.Srt = minLvl
+                    tinsert (folder, f)
                 end
-                f.T = "#Map" .. id
-                f.Tx = parent.Tx
-                f.MId = id
-                f.SrtN = name
-                f.Srt = minLvl
-                tinsert (folder, f)
             end
         end
         if folder.Map == 0 then
@@ -1850,22 +1838,24 @@ function Nx.Map.Guide:FindClosest (findType)
                     local fid = folder.Id
                     local data = Nx:GetData (longType)
                     for cont = cont1, cont2 do
-                        for _,mapId in pairs(Nx.Map.MapZones[cont]) do
-                            local blizzArea = mapId
-                            local zoneT = data[blizzArea]
-                            if zoneT then
-                                local nodeT = zoneT[fid]
-                                if nodeT then
-                                    for k, node in ipairs (nodeT) do
-                                        local x, y, level = Nx:GatherUnpack (node)
-                                        local wx, wy = Map:GetWorldPos (mapId, x, y)
-                                        if level == Nx.Map.DungeonLevel then
-                                            local dist = (wx - px) ^ 2 + (wy - py) ^ 2
-                                            if dist < closeDist then
-                                                closeDist = dist
-                                                close = 0
-                                                closeMapId = mapId
-                                                closeX, closeY = wx, wy
+                        if Nx.Map.MapZones[cont] then
+                            for _,mapId in pairs(Nx.Map.MapZones[cont]) do
+                                local blizzArea = mapId
+                                local zoneT = data[blizzArea]
+                                if zoneT then
+                                    local nodeT = zoneT[fid]
+                                    if nodeT then
+                                        for k, node in ipairs (nodeT) do
+                                            local x, y, level = Nx:GatherUnpack (node)
+                                            local wx, wy = Map:GetWorldPos (mapId, x, y)
+                                            if level == Nx.Map.DungeonLevel then
+                                                local dist = (wx - px) ^ 2 + (wy - py) ^ 2
+                                                if dist < closeDist then
+                                                    closeDist = dist
+                                                    close = 0
+                                                    closeMapId = mapId
+                                                    closeX, closeY = wx, wy
+                                                end
                                             end
                                         end
                                     end
diff --git a/Carbonite/Data/mop/MapWorldHotspots.lua b/Carbonite/Data/mop/MapWorldHotspots.lua
index 929dd10..8c1abc7 100644
--- a/Carbonite/Data/mop/MapWorldHotspots.lua
+++ b/Carbonite/Data/mop/MapWorldHotspots.lua
@@ -109,7 +109,7 @@ Nx.MapWorldHotspots2 = {
         [390] = "17842ab2623fc9a3502f69586ac6575f465428f1f5a1023f20966d4ad836",
         [418] = "0a36f4d5c95e53941e5921119472c518615813851bcc51e5abd0ca341452",
         [422] = "5ee13353013db1609b0c95b626f2597aed8ca17271084a8ba9526c0ad8e6",
-        [433] = "6fd1333b32266fac053d335f6fc3583338b8a2b9802972af",
+        [433] = "7299211af1247683741c55ad77ea4515b2487b5c8d12429a81616525420f8d992113524e8d9b6f1de2548d9dc428b13792d8d508c04c92d785072150a0d9870a91e9ab7a380ed38bba3b1009d267",--"6fd1333b32266fac053d335f6fc3583338b8a2b9802972af",
         [469] = "51e28f266bff78423d051c517d61eb07ac518511701709c19c11701c24f59c17d62e123d",
 }
 
diff --git a/Carbonite/Docs/CarboniteLicenseAgreement.txt b/Carbonite/Docs/CarboniteLicenseAgreement.txt
index a352299..fc5d9b7 100644
--- a/Carbonite/Docs/CarboniteLicenseAgreement.txt
+++ b/Carbonite/Docs/CarboniteLicenseAgreement.txt
@@ -1,41 +1,41 @@
-
- CARBONITE
- Copyright 2007-2012 Carbon Based Creations, LLC
- CARBONITE(tm) is a registered trademark of Carbon Based Creations, LLC.
-
-----------------------------------------------------------
- Enable word wrap to more easily view this file.
-----------------------------------------------------------
-
-LICENSE AGREEMENT
-
-PLEASE READ THIS END USER LICENSE AGREEMENT ("AGREEMENT") CAREFULLY AND MAKE SURE YOU UNDERSTAND IT.
-The accompanying executable code version of CARBONITE and related documentation ("Software") is made available under the terms and conditions of this Agreement. IF YOU INSTALL OR USE THE PRODUCT, YOU CONSENT TO BE BOUND BY THIS AGREEMENT. IF YOU DO NOT AGREE TO THE TERMS HEREIN, DO NOT INSTALL OR USE THIS PRODUCT.
-
-LICENSE.  The Software is protected by copyright laws, trade secret, and international copyright treaties, and is being licensed to You according to the terms of this Agreement.  Carbon Based Creations, LLC ("Company") grants to You a non-exclusive and non-transferable right to install and use a copy of the Software for Your personal, non-commercial home entertainment use on one personal computer.  The Software made available under this Agreement is licensed, not sold, to You by Company.  Company reserves all rights not expressly granted under this Agreement.
-
-Except to the extent that Company otherwise authorizes You in writing, the following restrictions shall apply:
-
-(1) You may not use the Software for any commercial purposes, including resale, rental, lease, display, or offering on a pay-per-play or other for-charge basis.  You may not sub-license the rights provided to You.
-
-(2) The Software (in both object and source code forms) constitutes valuable trade secret information of Company, and You may not reverse-engineer, decompile or disassemble the Software or otherwise attempt to gain access to the source code for the Software.
-
-(3) You may make a single archival copy of the Software to the extent permitted by law.  You may not otherwise reproduce the Software, or modify or distribute all or any portion of the Software. You shall not provide copies of the Software to any other party.  You may not create derivative works from the Software.
-
-(4) No right, title or interest in or to any trademark, service mark, logo or trade name of Company or of any third parties is granted under this Agreement.  You may not remove or alter any trademark, logo, copyright, or other proprietary notice(s) on the Software.
-
-TERMINATION:  This Agreement is effective until terminated. If You breach this Agreement, the license and Your right to use the Software will terminate immediately and without notice, but all other terms of this Agreement will survive termination and continue in effect.  Upon termination, You will immediately cease using the Software and You must destroy all copies of the Software in Your possession or control.
-
-EXPORT.  You agree that You will not export the Software or any part thereof, except in accordance with all applicable U.S. export restrictions.
-
-U.S. GOVERNMENT RESTRICTED RIGHTS.  The Software is commercial computer software and documentation developed by Company and belonging solely to Company.  If the Software is acquired by or on behalf of the U.S. Government or by a U.S. government prime contractor or a subcontractor, then the Government's rights in the Software will be only as set forth in this Agreement; this is in accordance with 48 C.F.R. 227.7202-4 or successor regulation (for Department of Defense (DOD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 or successor regulation (for non-DOD acquisitions).
-
-GOVERNING LAW AND VENUE.  This Agreement is governed by the laws of the State of Illinois, excluding its choice of law rules.  The United Nations Convention on Contracts for the International Sale of Goods shall not apply.  In any action or suit to enforce any right or remedy under this Agreement or to interpret any of its provisions, the state or federal courts located in the State of Illinois shall have exclusive jurisdiction over any such suit or action, and You hereby agree to submit to the jurisdiction of such courts.
-
-NO WARRANTY.  YOU ACKNOWLEDGE AND AGREE THAT THE SOFTWARE IS PROVIDED "AS IS", "AT YOUR OWN RISK", AND WITHOUT WARRANTY OF ANY KIND.   TO THE FULLEST EXTENT PERMITTED BY LAW, COMPANY HEREBY DISCLAIMS ALL EXPRESS AND IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT OF ANY THIRD PARTY RIGHTS WITH RESPECT TO THE SOFTWARE.  COMPANY DOES NOT WARRANT THAT THE SOFTWARE IS ERROR-FREE OR THAT ACCESS TO THE SOFTWARE WILL BE UNINTERRUPTED AND WITHOUT COMPROMISE TO SECURITY SYSTEMS.
-
-LIMITATION OF LIABILITY.  YOU ACKNOWLEDGE AND AGREE THAT TO THE FULLEST EXTENT PERMITTED BY LAW, COMPANY WILL NOT BE LIABLE FOR ANY LOST REVENUE, LOST PROFIT, BUSINESS INTERRUPTION, LOSS OF BUSINESS OR CONFIDENTIAL INFORMATION OR LOSS OF DATA, COMPUTER MALFUNCTION, OR FOR ANY DIRECT, SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED TO THE USE OF OR INABILITY TO USE OR IN CONNECTION WITH THE SOFTWARE, EVEN IF COMPANY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES AND WHETHER OR NOT SUCH DAMAGES ARE FORESEEABLE.  IN NO EVENT WILL COMPANY'S LIABILITY TO YOU, WHETHER IN CONTRACT, TORT (INCLUDING NEGLIGENCE), OR OTHERWISE, EXCEED THE AMOUNT, IF ANY, PAID BY YOU FOR THE SOFTWARE UNDER THIS AGREEMENT.  THE FOREGOING LIMITATIONS WILL APPLY EVEN IF THE ABOVE STATED WARRANTY FAILS OF ITS ESSENTIAL PURPOSE.  BECAUSE SOME STATES AND/OR JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, THE ABOVE LIMITATION MAY NOT APPLY TO YOU, AND YOU MAY ALSO HAVE OTHER LEGAL RIGHTS THAT VARY FROM STATE TO STATE.
-
-SEVERABILITY/NO WAIVER.  If any provision of this Agreement is held to be unenforceable, this Agreement will remain in effect with the provision omitted, unless omission would frustrate the intent of the parties, in which case this Agreement will immediately terminate.  Failure to enforce any provision of this Agreement is not a waiver of future enforcement of that or any other provision.
-
-----------------------------------------------------------
+
+ CARBONITE
+ Copyright 2007-2012 Carbon Based Creations, LLC
+ CARBONITE(tm) is a registered trademark of Carbon Based Creations, LLC.
+
+----------------------------------------------------------
+ Enable word wrap to more easily view this file.
+----------------------------------------------------------
+
+LICENSE AGREEMENT
+
+PLEASE READ THIS END USER LICENSE AGREEMENT ("AGREEMENT") CAREFULLY AND MAKE SURE YOU UNDERSTAND IT.
+The accompanying executable code version of CARBONITE and related documentation ("Software") is made available under the terms and conditions of this Agreement. IF YOU INSTALL OR USE THE PRODUCT, YOU CONSENT TO BE BOUND BY THIS AGREEMENT. IF YOU DO NOT AGREE TO THE TERMS HEREIN, DO NOT INSTALL OR USE THIS PRODUCT.
+
+LICENSE.  The Software is protected by copyright laws, trade secret, and international copyright treaties, and is being licensed to You according to the terms of this Agreement.  Carbon Based Creations, LLC ("Company") grants to You a non-exclusive and non-transferable right to install and use a copy of the Software for Your personal, non-commercial home entertainment use on one personal computer.  The Software made available under this Agreement is licensed, not sold, to You by Company.  Company reserves all rights not expressly granted under this Agreement.
+
+Except to the extent that Company otherwise authorizes You in writing, the following restrictions shall apply:
+
+(1) You may not use the Software for any commercial purposes, including resale, rental, lease, display, or offering on a pay-per-play or other for-charge basis.  You may not sub-license the rights provided to You.
+
+(2) The Software (in both object and source code forms) constitutes valuable trade secret information of Company, and You may not reverse-engineer, decompile or disassemble the Software or otherwise attempt to gain access to the source code for the Software.
+
+(3) You may make a single archival copy of the Software to the extent permitted by law.  You may not otherwise reproduce the Software, or modify or distribute all or any portion of the Software. You shall not provide copies of the Software to any other party.  You may not create derivative works from the Software.
+
+(4) No right, title or interest in or to any trademark, service mark, logo or trade name of Company or of any third parties is granted under this Agreement.  You may not remove or alter any trademark, logo, copyright, or other proprietary notice(s) on the Software.
+
+TERMINATION:  This Agreement is effective until terminated. If You breach this Agreement, the license and Your right to use the Software will terminate immediately and without notice, but all other terms of this Agreement will survive termination and continue in effect.  Upon termination, You will immediately cease using the Software and You must destroy all copies of the Software in Your possession or control.
+
+EXPORT.  You agree that You will not export the Software or any part thereof, except in accordance with all applicable U.S. export restrictions.
+
+U.S. GOVERNMENT RESTRICTED RIGHTS.  The Software is commercial computer software and documentation developed by Company and belonging solely to Company.  If the Software is acquired by or on behalf of the U.S. Government or by a U.S. government prime contractor or a subcontractor, then the Government's rights in the Software will be only as set forth in this Agreement; this is in accordance with 48 C.F.R. 227.7202-4 or successor regulation (for Department of Defense (DOD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 or successor regulation (for non-DOD acquisitions).
+
+GOVERNING LAW AND VENUE.  This Agreement is governed by the laws of the State of Illinois, excluding its choice of law rules.  The United Nations Convention on Contracts for the International Sale of Goods shall not apply.  In any action or suit to enforce any right or remedy under this Agreement or to interpret any of its provisions, the state or federal courts located in the State of Illinois shall have exclusive jurisdiction over any such suit or action, and You hereby agree to submit to the jurisdiction of such courts.
+
+NO WARRANTY.  YOU ACKNOWLEDGE AND AGREE THAT THE SOFTWARE IS PROVIDED "AS IS", "AT YOUR OWN RISK", AND WITHOUT WARRANTY OF ANY KIND.   TO THE FULLEST EXTENT PERMITTED BY LAW, COMPANY HEREBY DISCLAIMS ALL EXPRESS AND IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT OF ANY THIRD PARTY RIGHTS WITH RESPECT TO THE SOFTWARE.  COMPANY DOES NOT WARRANT THAT THE SOFTWARE IS ERROR-FREE OR THAT ACCESS TO THE SOFTWARE WILL BE UNINTERRUPTED AND WITHOUT COMPROMISE TO SECURITY SYSTEMS.
+
+LIMITATION OF LIABILITY.  YOU ACKNOWLEDGE AND AGREE THAT TO THE FULLEST EXTENT PERMITTED BY LAW, COMPANY WILL NOT BE LIABLE FOR ANY LOST REVENUE, LOST PROFIT, BUSINESS INTERRUPTION, LOSS OF BUSINESS OR CONFIDENTIAL INFORMATION OR LOSS OF DATA, COMPUTER MALFUNCTION, OR FOR ANY DIRECT, SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED TO THE USE OF OR INABILITY TO USE OR IN CONNECTION WITH THE SOFTWARE, EVEN IF COMPANY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES AND WHETHER OR NOT SUCH DAMAGES ARE FORESEEABLE.  IN NO EVENT WILL COMPANY'S LIABILITY TO YOU, WHETHER IN CONTRACT, TORT (INCLUDING NEGLIGENCE), OR OTHERWISE, EXCEED THE AMOUNT, IF ANY, PAID BY YOU FOR THE SOFTWARE UNDER THIS AGREEMENT.  THE FOREGOING LIMITATIONS WILL APPLY EVEN IF THE ABOVE STATED WARRANTY FAILS OF ITS ESSENTIAL PURPOSE.  BECAUSE SOME STATES AND/OR JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, THE ABOVE LIMITATION MAY NOT APPLY TO YOU, AND YOU MAY ALSO HAVE OTHER LEGAL RIGHTS THAT VARY FROM STATE TO STATE.
+
+SEVERABILITY/NO WAIVER.  If any provision of this Agreement is held to be unenforceable, this Agreement will remain in effect with the provision omitted, unless omission would frustrate the intent of the parties, in which case this Agreement will immediately terminate.  Failure to enforce any provision of this Agreement is not a waiver of future enforcement of that or any other provision.
+
+----------------------------------------------------------
diff --git a/Carbonite/Docs/CarboniteReadMe.txt b/Carbonite/Docs/CarboniteReadMe.txt
index fa1b216..30ea0c7 100644
--- a/Carbonite/Docs/CarboniteReadMe.txt
+++ b/Carbonite/Docs/CarboniteReadMe.txt
@@ -1,567 +1,567 @@
-#CARBONITE
-
- **CARBONITE** - *Addon for World of Warcraft(tm)*
-
-##Common Installation Instructions
-
-This zip file contains:
-
-   * \Carbonite\ (a folder)
-   * \CarboniteNodes\ (a folder)
-   * CarboniteTransfer (a folder)
-   * CarboniteLicenseAgreement.txt
-   * CarboniteReadMe.txt
-
-
-The Carbonite folder needs to be dragged from the zip file or the zip file extracted to the Warcraft AddOns folder. Any existing Carbonite folders in the addons folder should be deleted first. This should be done while the game is not running.
-
-You can look at the shortcut (right click and select properties) you use to launch Warcraft to get the path to where it is installed.
-
-So if the shortcut says ```"C:\Program Files\World of Warcraft\Launcher.exe"```, then your addon path is ```"C:\Program Files\World of Warcraft\Interface\AddOns"```.
-
-Default paths:
-
- * Windows XP: ```"C:\Program Files\World of Warcraft\Interface\AddOns"```
- * Vista: ```"C:\Users\Public\Games\World of Warcraft\Interface\AddOns"```
- * Macintosh: ```"Macintosh HD/Applications/World of Warcraft/Interface/AddOns"```
-
-Delete any existing Carbonite folders in the AddOns folder before you unzip a new version.
-
-If you have Warcraft installed at ```"C:\Program Files"```, then you would put the Carbonite folder in:
-
-   ```"C:\Program Files\World of Warcraft\Interface\AddOns"```
-
-Now you would have:
-
-   ```"C:\Program Files\World of Warcraft\Interface\AddOns\Carbonite"```
-
-Which contains:
-
-  * Bindings.xml
-  * Carbonite.lua
-  * Carbonite.toc
-  * Carbonite.xml
-  * CarboniteLicenseAgreement.txt
-  * CarboniteReadMe.txt
-  * Localizations.lua
-  * \Gfx\ (a folder)
-  * \Snd\ (a folder)
-
-A common error is to create a Carbonite folder in AddOns and unzip to the folder.
-This would leave you with
-
-   ```"C:\Program Files\World of Warcraft\Interface\AddOns\Carbonite\Carbonite"``` (WRONG)
-
-This will not work!
-
-Some users have found two AddOns directories on their computers. This may be caused by having installed both a downloaded and CD version of Warcraft or if Vista's Virtual Store is enabled.
-
-When properly installed, the Carbonite logo will appear on login. If the Carbonite logo does not appear, then the AddOns folder you are using is the wrong one. You would then use your computer's "file search" to find the actual folder.
-
-
-###Vista specific installation instructions:
-
-When you download an addon it will be in a zip file.
-
-When you click the "Download" button a dialog box should ask to "Open" or "Save". If you click "Open", then it will download thefile and then show the contents. Near the top of the window thatshows the file contents is a "Extract all files" button. Left click that and then click "Browse..." in the new window that opens.
-
-If you don't know the addon folder location, then look at the shortcut(right click and select properties) you use to launch Warcraft to get the path to where it is installed.
-
-Use the "Select a destination" window that opened to left click on "Computer" then (C:) or whatever drive it is installed on. Continue to click until you are at the game's "Interface\AddOns" folder.
-
- ```"C:\Program Files\World of Warcraft\Interface\AddOns"``` or ```"C:\Users\Public\Games\World of Warcraft\Interface\AddOns"``` are common locations for the game using Vista.
-
-Now left click "OK" at the bottom of the window and you should see ```"(the game path)\Interface\AddOns"``` in the *"Files will be extracted to this folder:"* line. Now click the *"Extract"* button at the bottom of the window. If it asks to overwrite files, which it will the next time you install another version of Carbonite and you did not delete the existing Carbonite folders first, then click *"Yes"*.
-
- You would now have a ```"(the game path)\Interface\AddOns\Carbonite"``` folder.
-
- Installation is now complete and you can run World of Warcraft*(tm)*.
-
-###Macintosh installation:
-
-1 Sign in to the Carbonite website using the email address and password you entered when signing up.
-2 Click on "Downloads" in the website navigation bar.
-3 Click on the newest file in the download list to get a web page for that file, then click the Download button.
-4 When the download is finished you would "open" the downloaded file by right clicking the name and selecting "Open".
-5 Select "Edit" from the Finder menu bar and then "Select All".
-6 Select "Edit" from the Finder menu bar and then "Copy 5 Items".
-7 On the left side of the Finder. Left click "Applications".
-8 On the right side of the Finder. Double left click "World of Warcraft", then "Interface" and "Addons".
-9 Select "Edit" from the Finder menu bar and then "Paste Items".
-
-###Carbonite Start Up
-
-When you enter the game world with a character, you will see a Carbonite Logo appear.
-
-If the Carbonite Logo does not appear, then you have installed it incorrectly or it is disabled. Check if the addon is enabled by using the AddOns button on the character selection screen. If it does not appear in the list of addons, then repeat the installation instructions, since 99% of the time it was unzipped
- to the wrong location.
-
-##Carbonite User Guide
-
-###Some things to do when first using Carbonite
-
-There are dozens of settings you can configure and lots of ways to use Carbonite, but you really can ignore most of that stuff initially.
-
-I would:
-
-1. Read the help window that opens when you first sign in. Right click the Carbonite minimap button and select "Help" to see it again.
-2. Drag the Carbonite map window (using the title bar) to the top right of the screen leaving a little room on the right edge.
-3. Size the map window by dragging the edges.
-4. Drag the Quest Watch List (title bar) to a nice spot under the map.
-5. Drag the little window under (around) the Carbonite minimap button icon, so the icons start at the very top right of the screen.
-6. Right click the Carbonite minimap button and select "Show Info 1 2" to get the HUD for you and your target. Select again if you don't like it to hide them.
-
-When you start questing, you would click the purple *"Auto Track"* button at the top of the Quest Watch List or click a grey button on a specific quest objective to get the HUD arrow to start tracking it. Follow the arrow.
-
-###General User Interface
-
-Most windows can be moved, sized, scaled & locked.
-
- * To move a window:	Left Click the title bar and drag.
- * To resize a window:	Left Click and drag any window edge.
- * To scale a window:	Right Click the title bar or close button and adjust the Scale slider.
- * To close a window:	Left Click the close button.
- * To lock a window:	Right Click the title bar or close button and check lock.
- * To unlock a window:	Right Click the close button which appears as a lock icon when locked.
-
-####Transparency
-
-Each window has two transparency settings. Fade in and fade out.  Each setting controls the transparency level for the window borders & background.
-
-- The fade in setting is used when the window has mouse focus.
-- The fade out setting is use when the mouse leaves the window.
-
-You can change these settings by Right Clicking the window title bar.
-
-When using a slider control if you hold down shift all units are snapped to 0.1.  Pressing ALT while on a slider will set its value to 1.0
-
-
-###Minimap Carbonite Icon
-
-This icon is found at the top left of the minimap or at the top of the minimap docking window.
-
-Left Clicking will show or hide the map.
-Right Clicking will open the main Carbonite menu. The menu can be used to open the help or options windows.
-
-
-###Map
-
-Left Click and drag to move the map around inside the window
-Roll your mouse wheel to zoom in/out at the current mouse position on the map.
-Pressing M will toggle the map between normal mode and full-screen mode.
-
-The size, position and settings for the map are saved.  These settings are also saved independently for each battleground.
-
-The *"Follow You"* option is on by default for the normal map.  As you move about, the map will adjust to keep you in the center of the screen.  Various battleground maps have this setting off by default as you will typically want to view the entire map and not have it scrolling as you move.
-
-The map has two additional fade settings.  These control the transparency level of the map itself and can be adjusted by Right Clicking in the map window title.
-
-The map title shows the zone you are currently in, your map coordinates and your movement speed as a percentage of normal walk speed.
-
-The map tooltip will show you the level range of the map and is color coded based on faction (Yellow = contested, Green = friendly, Red = enemy)
-
-Party/Raid members will show up as blue dots on your map.  Friends and guild mates running Carbonite will show up on your map as yellow and green dots respectively.  Other Carbonite users in your zone will show up as gray dots on the map.
-
-The tooltip of any Carbonite user on the map will show you their coordinates, health, target name and target health.  Right Clicking their icon will allow you to whisper, retrieve quests and GOTO them.
-
-For users wishing to see your original map, it is accessible by pressing ALT+M.
-
-
-####Map Menu
-
-Right Clicking a non icon area of the map will show the main map menu.
-
-*"Goto"* - Sets a point on the map, which the map and HUD will track. Map moves and scales to keep both you and the goto visible.
-"Clear Goto" - Clears all gotos from the map.
-
-*"Add Note"* - Sets a note for the click location in a folder with that zone name in the Favorites window. It will be shown on the map when that zone is selected.
-
-*"Save Map Scale"* - Saves (remembers) the current map scale (zoom level). A keybinding can be set to do this.
-*"Restore Map Scale"* - Sets the current map scale to the value that was previouly saved. A keybinding can be set to do this.
-
-*"Follow You"* - If on, when you move or turn, the map will scroll to keep you in the center.
-
-*"Select Cities First"* - Changes how cities are selected when you mouse over the map. It will select the zone, like Terokkar, first instead of the city Shattrath. Mostly useless. Someone was having a problem with tring to select a zone and it was added.
-
-*"Monitor Zone"* - Makes you join that zone channel even if you are not in the zone, so you can see players and get punk info from the zone. Useful if you think a punk moved to another zone or to expand your punk detection.
-
-
-
-###Quests
-
-The quest log replaces the original quest log.  Like most windows it is fully sizeable.
-You can Click the button or Shift Click any quest title in the quest log to add it to the watch list.  When you pick up a new quest it will be automatically added to the watch list.  Any quest can be watched including quests with no objectives.  You can add as many quests to the watch list as you like. If you Shift Click a quest category header it will add/remove all quests under that category.
-
-Right Clicking a quest in the quest log will bring up a menu with additional options.
-
-Menu:
-
-* Watch All Quests will mark all quests as being watched, so they show in the Watch List.
-* Share will try to share the quest with your party.
-* Abandon will ask you if you want to abandon the quest.
-
-
-The quest log has 3 additional tabs:
-
-- History: a history of completed quests
-- Database: a searchable list of quests in the database (shows current map zone by default)
-- Player: You can Right Click another Carbonite user's map icon to retrieve their quests.  Their quests will show up in this tab.
-
-
-####Quest Watch List
-
-The watch window is draggable but not sizeable.  It grows and shrinks as needed based on the quests you are currently watching. The Watch window can be made into a sizeable scrolling list if "Use fixed size list" is checked in the Quest Watch page of the Options window.
-
-The green button toggles if all watched quests will be shown on the map and is on by default.
-
-The purple *"Auto Track"* button will target the highest priority quest objective and updates dynamically as you move. Priority is based on distance, quest level and if the quest is complete.
-
-The yellow/blue *"Quest Givers"* button shows Quest Giver icons on the map. Normal ones are shown as parchment icons. Daily quest givers as blue ! icons.
-
-Button colors:
-
-* Dark yellow: No givers
-* Yellow: Quest givers and daily givers
-* Blue: Daily givers
-
-The white *"Show Party Quests"* button determines if quests from other party members with Carbonite will also be shown in the Watch List.
-
-
-####Quest Watch List Objective Buttons
-
-The round buttons to the left of the quests/objectives have several functions.
-
-Left Click will activate *"GOTO"* mode.  This display the location and direction of the objective on the world map.  The map will scale so that you and your target are always visible.
-
-Shift Left Click will toggle the display of quest objectives on/off, but not track it.
-
-Alt Left Click will send a status message about the quest to party chat.
-
-Right Click will bring up a menu with additional options.
-
-Alt Right Click will open the Quest Log with that quest selected.
-
-The black squares will show a tooltip with quest information if you put the mouse cursor over them.
-
-
-###HUD
-
-The HUD arrow turns on whenever you are using the GOTO feature.  The arrow will point to the target and show you the name, distance and estimated arrival time.  The HUD arrow can be moved by dragging the title bar.
-
-Left Clicking the arrow will target a player if it is pointing at a player.
-Right Clicking the arrow will target the target of a player if it is pointing at a player.
-
-
-###Guide
-
-The guide is your in-game GPS with the location of various points of interest.  You can bring up the Guide by Clicking the Guide button on the map window (Question Icon).  By default the map will show you common POIs such as mailbox, bank, flight path, etc. when the map is zoomed in to a certain level.
-
-You can Right Click any POI icon to GOTO it or paste the name & coordinates into a chat message.
-
-Clicking any guide button will display the POI on the map and activate the GOTO mode where appropriate.
-
-Some guide categories have subcategories ( >>> after the text).  If you Click the text it will open up the subcategory.  Pressing the back button will move back up one level.
-
-We plan to add new categories based on user feedback, such as browsing honor/arena rewards.
-
-
-###Warehouse
-
-The Warehouse enables you to browse the equipment and information of every one of your characters at one time.  You can bring up the Warehouse by clicking the Warehouse button in the map window (Chest Icon at bottom of map).
-
-The Warehouse window has a list of your characters on the left side and items on the right side. You can select your characters in the left panel while the right panel displays their inventory, bank or profession items. Clicking a name in the left shows the items. Clicking a profession shows what can be make or done using the profession. You have to open each profession window for the data to get recorded in the Warehouse. This also records a profession link, if it has a link. You can the left click the chain icon to paste the link into an open chat edit box.
-
-You can link items from the warehouse by clicking the item icon.
-
-There is a search field at the top right of the window.  You can type any text into this field and it will display matching items below.
-
-You can click on *"All Characters"* and it will display all the items of all your characters at once. This is a useful feature when you are trying to track down specific items.
-
-Equipped items are listed first; other items follow grouped by category. The number in front of an item name shows the total number that the current character or all characters have. It will be blank if the count is one. The numbers after the name are the amounts in inventory and bank.
-
-Right click the list for a popup menu that allows you to turn off the category headers.
-If you left click on an item it will display the names and total count of any characters with the item. Click the names to hide them.
-
-After installing Carbonite for the first time, it is a good idea to open up the bank with each of your characters to populate the warehouse data.
-
-The sync command in the Warehouse menu imports characters from other accounts in the transfer file that match the current server and exports all current server character data as recorded in the Warehouse. Every character stat that the Warehouse tracks is transfered. You would then copy the CarboniteTransfer.lua file from the SavedVariables folder of the current account to the other account's SavedVariables folder.
-
-The only requirement is that the *"Remember Account Name"* setting at the account login screen be checked when you login, so Carbonite can know which account you are on when you sync. That is stored in the CVars if it is checked.
-
-
-###Transfering settings to other characters
-
-You can move the window layouts and other settings from a character to all your other characters. You would login with the character that is setup the way you like. Open the Warehouse. Right click the list on the right half of the window. Select *"Export current settings to all characters"* and click *"Export"* on the message box.
-
-You can also do it the opposite way using *"Import settings"* from the same menu, but you would have to do that on each character.
-
-
-###Social window
-
-The Social window is opened by pressing the O key and contains the normal friends window tabs and the Carbonite *"Pals"* and *"Punks"* tabs.
-
-####Pals
-
-The *"Pals"* tab keeps track of your friends across all your characters and lets you add them as friends on any character you log in with. It also lets you assign a character to a person, so you can group characters according to the player that owns them. Right click the list for a menu of commands.
-
-The Pals List automatically adds the names of any friends the currently logged in character has. The game keeps a list of friends separately for each character. The Friends List can have a maximum of 50 characters. Pals info is stored by Carbonite for the realm, so you can see all Pals on all characters you have on a realm.
-
-A Pal character name will show in red if they are not on the Friends List of the character that is currently logged in. Right click the name and select "Make Pal Into Friend" to add that Pal to the current character's Friends List.
-
-If you want to remove a Pal, you have to remove them from the Friends List on each character. An addon cannot remove friends from a character that is not currently logged in. Log in to each of your characters, right click the Pal name and select "Remove Pal And Friend". Once they are removed from each character, they will stop showing up as a Pal.
-
-####Punks
-
-The "Punks" tab is for finding enemy players and keeping notes on them. The list has a top and bottom section divided by a blue "-- Active --" line of text. The top lists the names of enemies you have manually added to the list and when detected you will get a message and the area of the map they were seen at will have a large green glowing circle around it and a red icon near the middle of the area. The bottom of the list shows recent punk detections. Those punk areas will show a red glow on the map. Right click the list for the popup menu. When you use "Add Character" from the menu it will add an enemy player to the top section of the list. If an enemy player is targeted it will use that name, otherwise an edit box will open and be filled with the name of the most recent punk personally detected near you. A chat message will show if a new punk is detected near you.
-
-Punks list options are in the "Social & Punks" page in the Options window.
-
-The Social window can be disabled, right click the Carbonite minimap icon and select "Options". Click "Social & Punks" in the left side list, uncheck the box on the right side and reload UI when asked.
-
-
-####Favorites window
-
-The Favorites window has a left and right side.
-
-The left side shows a tree of folders and favorites. You can put folders inside of folders. This works like a computer file system. You select a favorite for viewing or editing by left clicking it.
-
-The right side shows the list of items that belong to the currently selected favorite.
-
-There are 4 item types you can put in a favorite.
-
-1. Comment. Just a line of text that shows in the favorite item list. Create by right clicking the item list and selecting *"Add Comment"*.
-
-2. Note. An item that has an icon, text and map location. Create by right clicking the map and selecting *"Add Note"*. The note will be created in a favorite with the name of the zone. The favorite will be in the *"Notes"* folder. The note will set to the map location where you right clicked and will be set to the Star icon. Notes can be put inside of favorites that are not in the notes folder, but they will not automatically show on the map when the zone is selected. The point of that is so you can make a favorite with you own set of steps (dailies, quest guide) and have notes mixed with targets. When the "Record" button is on the note will go into the selected favorite instead of the favorite in the notes folder.
-
-3. Target 1st. This is the first part of a path or a single destination. Has a name and a map location. These are created when the "Record" button is on and you ctrl click the map or right click the map and select *"Goto"*.
-
-4. Target. This is the next part of a path. Has a name and a map location. These are created when the *"Record"* button is on and you ctrl shift click the map.
-
-###Record Mode
-
-This is on when the Record button is pressed. The button will glow red. Any map targets created (goto, guide or quest selection) will be added to the currently selected favorite below the selected item. Record mode is canceled when a different favorite is selected.
-
-####Viewing
-
-Note items inside of favorites in the *"Notes"* folder will be automatically drawn on the map if the the selected zone name matches the favorite name. Notes in favorites in any other folder will only be drawn when selected in the item list. The Notes folder is meant to mimic how notes are managed in other addons. Generally you should not put items other than notes inside the favorites in the notes folder.
-
-Targets are drawn on the map when selected in the item list. Each target after the selected one will also be drawn until a *"Target 1st"* or a non target is reached. This lets you see a whole path or part of a path.
-
-
-###Info Windows
-
-Info windows show various bits of information in a small movable list.
-Info #1 to #6 come with various default text in them.
-Right click the Carbonite minimap button and select "Show Info 1 2" to make #1 and #2 visible. These are setup for the health and mana of you and your target.
-
-To move or edit them, you need to unlock them on the Info Windows page of the Carb Options window.
-
-* Left click and drag the window title bar to move them around.
-* Right click a line in an unlocked info window and select *"New"* to show Info #3. Again will show #4 and so on.
-* Right click a line in an unlocked info window and select *"Edit Item"* to change the text for that line.
-
-####Info text
-
-* ```<xxx>``` runs a command.
-* ```<c>``` is the color from the last command.
-* ```<t>``` is the text from the last command.
-* ```xxx``` is raw text.
-
-#####Example
-
-```<THealth><c>HP <t>``` This runs the target health command, sets the color, shows the text *"HP "* and shows the text from the command.
-
-You cannot currently add new lines to an Info Window, but Info #3, 5 and 6 have an extra blank line in them, which can be edited.
-
-Info Window defaults:
-
-1. Your health, mana, DK runes, rogue combo points, global cooldown bar, casting bar.
-2. Target health, mana, casting bar.
-3. Durability, time to level.
-4. Battleground queues, start, duration, honor, stats.
-5. Time, FPS.
-6. Rest percentage
-
-
-###Battlegrounds
-
-Carbonite adds clickable objective icons right onto your Battleground map. Timer bars are displayed under each objective and you can mouse over to see the exact times. Right Click on any objective to issue orders such as attack, defend, incoming, and to report time status. Shift Click an objective to send an incoming message.  Each Click adds one to the count.  E.g. Shift Click 3 times on the Lumber Mill icon and you will say *Incoming Lumber Mill: 3*
-
-Hold down ALT to display player names (works anywhere, not just battlegrounds).
-Hold down Shift to draw objectives on top of the player icons.
-
-When a player is in combat his icon has an X in the middle.
-The icon for each player has a health bar along the top and his target's health bar is displayed down the left side.
-
-The HUD arrow will display the closest teammate that is in combat.  It will also point out friends/guildmates in the same battleground. When left clicked it will target that player and right click will target the target of that player.
-
-
-###Keyboard modifiers
-
-####Map
-
- * Shift down - Makes player arrow small. Draws BG objectives on top
- * Shift click - Pings minimap if click is near the player arrow on the map
- * Ctrl left click - Sets goto
- * Alt down - Shows player icon names and makes icons draw on top
-
-####Minimap (in Carbonite map)
-
- * Shift click - Pings
- * Ctrl down - Makes integrated minimap draw on top or bottom if already on top
- * Alt down - Makes docked minimap transparency 50%
-
-####List
-
- * Shift down - Makes mouse wheel scroll 5 times faster
- * Shift + ctrl down - Makes mouse wheel scroll 100 times faster
-
-####Quest Watch
-
- * Alt left click button - Send quest status to party
- * Alt right click button - Open quest window with quest selected
-
-####Settable Keybindings
-
- * Toggle Original Map
- * Toggle Normal or Max Map
- * Toggle None or Max Map
- * Toggle None or Normal Map
- * Restore Saved Map Scale
- * Toggle Full Size Minimap
- * Toggle Favorites
- * Toggle Guide
- * Toggle Warehouse
- * Toggle Watch List Minimize
-
-####Map Icons
-
-Round solid icons are players:
-
-  * Yellow: friend
-  * Green: guild
-  * Blue: party
-  * Grey: non of the above
-
-  * Top Horizontal Bar: player health
-  * Mid Horizontal Bar: friendly target health
-  * Left Vertical Bar: enemy health (red glow if a player)
-  * Map icon with x in center: in combat
-  * Map icon with a red center: health low
-  * Map icon with a black center: dead
-
-Round icons with black centers are for quests. A white icon is a quest ender if quest is simply to get to the end location.
-
-By default there are 12 quest colors. Each quest starting at the top of the quest log has a different color. Once the 12 colors are used it repeats.
-
-  * Red - first quest in quest log
-  * Green - second quest in quest log
-  * Blue - third quest in quest log
-  * Yellow - forth quest and so on
-
-If "Use one color per quest" is off then:
-
-  * Red - objective #1 or #4
-  * Green - objective #2 or #5
-  * Blue - objective #3 or #6
-
-Other Quest Icons:
-
-* Yellow ! - quest starter when you add a goto quest giver
-* Yellow ? - quest ender
-
-Square icons with 4 black arrows are the closest point to reach a quest area:
-
-* White color - is being tracked
-* Non white colors match the same quest colors as described above.
-
-
-####Gathering
-
-Carbonite tracks mining, herb, gas and everfost shard locations when you gather them.
-
-To show them on the map for the selected zone:
-
-* Herbs - Right click a non icon area of map, select Show and check "Show Herb Locations".
-* Mining - Right click a non icon area of map, select Show and check "Show Mining Locations".
-* Gas - Click the Guide ? icon on map, left click "Gather >>>" and left click the Gas icon.
-* Everfrost chip - Click the Guide ? icon on map, left click "Gather >>>" and left click the Everfrost chip icon.
-
-#####Routing
-
-Once any nodes are being shown on the map, you can right click a non icon area of map, select "Route..." and select "Current Gather Locations" to make a route on the map.
-
-
-###Carbonite Items
-
-CarboniteItems is a data addon that contains information on over 25000 game items. It is a load on demand addon, which means it is not actually loaded until you use the "Items >>" section of the Guide. Left click the "Items >>" text to view the CarboniteItems data.
-
-Mouse over the item icons to see a Carbonite generated tooltip of information on the item. The tooltip is similar to the normal game tooltip, but there are some minor differences. If the item icon is not shown as a ?, then the item is in the game's cache file, which means you can hold down the alt key and then mouse over the icons to see the game's tooltip for the item.
-
-The "Search [click]" edit box filters the items shown in the list on the right side by searching the Carbonite tooltips of the items currently show. Some examples:
-
- spell pow    (items with spell power)
- hit rat      (items with hit rating)
- mana per     (items with mana regeneration)
- quest:       (items from a quest)
- minor        (only minor glyphs)
-
-The first tooltip line that matches the filter will be shown in the Info3 column.
-
-Left click a column header to sort by that column.
-Shift left click a column header to decrease the column width.
-Shift right click a column header to increase the column width.
-
-
-###Carbonite Nodes
-
-CarboniteNodes is a simple data addon that contains predefined locations for Herbalism and Mining. It is a load on demand addon, which means it is not actually loaded until you import data from it into Carbonite.
-
-To import the data into Carbonite's gather data, you right click the Carbonite minimap button, select "Options" and select the Guide page of Options window. You would then left click the text that says "Import Carbonite Nodes Herbalism locations" to get the herbs and "Import Carbonite Nodes Mining locations" to get the mining data.
-
-
-###Carbonite Transfer (OLD)
-
-CarboniteTransfer is a simple addon that is used to move Warehouse data between accounts. It will also be used to send and receive favorites in the future. You can delete it or disable it, although it takes almost no memory since it is empty until used.
-
-In the Warehouse you right click the character list and select "Sync account transfer file" and any characters from your other synced accounts are imported from the CarboniteTransfer.lua file and characters in the current account are exported to the CarboniteTransfer.lua file. The file is then copied to the Savedvariables folder of another account, so you can sync the Warehouse data when you login with that account.
-
-Transfering is a manual process, because addons cannot directly access files and can't see addon data from other accounts. You have to copy the CarboniteTransfer.lua file from one SavedVariables folder to another.
-
-Example:
-
-1. Login to any character using AccountA.
-
-2. Select "Sync account transfer file" from the Warehouse menu.
-
-3. Logout. Go back to Account Screen, which saves the CarboniteTransfer.lua file.
-
-4. Copy ```WTF\Account\<AccountA>\SavedVariables\CarboniteTransfer.lua```  to  ```WTF\Account\<AccountB>\SavedVariables\CarboniteTransfer.lua```
-
-5. Login to any character using AccountB.
-
-6. Select "Sync account transfer file" from the Warehouse menu. AccountB will now have Warehouse data from AccountA.
-
-----------------------------------------------------------
-
-#Appendix
-
-Copyright 2007-2012 Carbon Based Creations, LLC
-CARBONITE(tm) is a registered trademark of Carbon Based Creations, LLC.
-
-World of Warcraft(tm) and "WOW" are trademarks owned by Blizzard Entertainment, Inc.
-The CARBONITE addon is not endorsed by or affiliated with Blizzard Entertainment, Inc.
-
-Website: carboniteaddon.com
-
-This program is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
+#CARBONITE
+
+ **CARBONITE** - *Addon for World of Warcraft(tm)*
+
+##Common Installation Instructions
+
+This zip file contains:
+
+   * \Carbonite\ (a folder)
+   * \CarboniteNodes\ (a folder)
+   * CarboniteTransfer (a folder)
+   * CarboniteLicenseAgreement.txt
+   * CarboniteReadMe.txt
+
+
+The Carbonite folder needs to be dragged from the zip file or the zip file extracted to the Warcraft AddOns folder. Any existing Carbonite folders in the addons folder should be deleted first. This should be done while the game is not running.
+
+You can look at the shortcut (right click and select properties) you use to launch Warcraft to get the path to where it is installed.
+
+So if the shortcut says ```"C:\Program Files\World of Warcraft\Launcher.exe"```, then your addon path is ```"C:\Program Files\World of Warcraft\Interface\AddOns"```.
+
+Default paths:
+
+ * Windows XP: ```"C:\Program Files\World of Warcraft\Interface\AddOns"```
+ * Vista: ```"C:\Users\Public\Games\World of Warcraft\Interface\AddOns"```
+ * Macintosh: ```"Macintosh HD/Applications/World of Warcraft/Interface/AddOns"```
+
+Delete any existing Carbonite folders in the AddOns folder before you unzip a new version.
+
+If you have Warcraft installed at ```"C:\Program Files"```, then you would put the Carbonite folder in:
+
+   ```"C:\Program Files\World of Warcraft\Interface\AddOns"```
+
+Now you would have:
+
+   ```"C:\Program Files\World of Warcraft\Interface\AddOns\Carbonite"```
+
+Which contains:
+
+  * Bindings.xml
+  * Carbonite.lua
+  * Carbonite.toc
+  * Carbonite.xml
+  * CarboniteLicenseAgreement.txt
+  * CarboniteReadMe.txt
+  * Localizations.lua
+  * \Gfx\ (a folder)
+  * \Snd\ (a folder)
+
+A common error is to create a Carbonite folder in AddOns and unzip to the folder.
+This would leave you with
+
+   ```"C:\Program Files\World of Warcraft\Interface\AddOns\Carbonite\Carbonite"``` (WRONG)
+
+This will not work!
+
+Some users have found two AddOns directories on their computers. This may be caused by having installed both a downloaded and CD version of Warcraft or if Vista's Virtual Store is enabled.
+
+When properly installed, the Carbonite logo will appear on login. If the Carbonite logo does not appear, then the AddOns folder you are using is the wrong one. You would then use your computer's "file search" to find the actual folder.
+
+
+###Vista specific installation instructions:
+
+When you download an addon it will be in a zip file.
+
+When you click the "Download" button a dialog box should ask to "Open" or "Save". If you click "Open", then it will download thefile and then show the contents. Near the top of the window thatshows the file contents is a "Extract all files" button. Left click that and then click "Browse..." in the new window that opens.
+
+If you don't know the addon folder location, then look at the shortcut(right click and select properties) you use to launch Warcraft to get the path to where it is installed.
+
+Use the "Select a destination" window that opened to left click on "Computer" then (C:) or whatever drive it is installed on. Continue to click until you are at the game's "Interface\AddOns" folder.
+
+ ```"C:\Program Files\World of Warcraft\Interface\AddOns"``` or ```"C:\Users\Public\Games\World of Warcraft\Interface\AddOns"``` are common locations for the game using Vista.
+
+Now left click "OK" at the bottom of the window and you should see ```"(the game path)\Interface\AddOns"``` in the *"Files will be extracted to this folder:"* line. Now click the *"Extract"* button at the bottom of the window. If it asks to overwrite files, which it will the next time you install another version of Carbonite and you did not delete the existing Carbonite folders first, then click *"Yes"*.
+
+ You would now have a ```"(the game path)\Interface\AddOns\Carbonite"``` folder.
+
+ Installation is now complete and you can run World of Warcraft*(tm)*.
+
+###Macintosh installation:
+
+1 Sign in to the Carbonite website using the email address and password you entered when signing up.
+2 Click on "Downloads" in the website navigation bar.
+3 Click on the newest file in the download list to get a web page for that file, then click the Download button.
+4 When the download is finished you would "open" the downloaded file by right clicking the name and selecting "Open".
+5 Select "Edit" from the Finder menu bar and then "Select All".
+6 Select "Edit" from the Finder menu bar and then "Copy 5 Items".
+7 On the left side of the Finder. Left click "Applications".
+8 On the right side of the Finder. Double left click "World of Warcraft", then "Interface" and "Addons".
+9 Select "Edit" from the Finder menu bar and then "Paste Items".
+
+###Carbonite Start Up
+
+When you enter the game world with a character, you will see a Carbonite Logo appear.
+
+If the Carbonite Logo does not appear, then you have installed it incorrectly or it is disabled. Check if the addon is enabled by using the AddOns button on the character selection screen. If it does not appear in the list of addons, then repeat the installation instructions, since 99% of the time it was unzipped
+ to the wrong location.
+
+##Carbonite User Guide
+
+###Some things to do when first using Carbonite
+
+There are dozens of settings you can configure and lots of ways to use Carbonite, but you really can ignore most of that stuff initially.
+
+I would:
+
+1. Read the help window that opens when you first sign in. Right click the Carbonite minimap button and select "Help" to see it again.
+2. Drag the Carbonite map window (using the title bar) to the top right of the screen leaving a little room on the right edge.
+3. Size the map window by dragging the edges.
+4. Drag the Quest Watch List (title bar) to a nice spot under the map.
+5. Drag the little window under (around) the Carbonite minimap button icon, so the icons start at the very top right of the screen.
+6. Right click the Carbonite minimap button and select "Show Info 1 2" to get the HUD for you and your target. Select again if you don't like it to hide them.
+
+When you start questing, you would click the purple *"Auto Track"* button at the top of the Quest Watch List or click a grey button on a specific quest objective to get the HUD arrow to start tracking it. Follow the arrow.
+
+###General User Interface
+
+Most windows can be moved, sized, scaled & locked.
+
+ * To move a window:	Left Click the title bar and drag.
+ * To resize a window:	Left Click and drag any window edge.
+ * To scale a window:	Right Click the title bar or close button and adjust the Scale slider.
+ * To close a window:	Left Click the close button.
+ * To lock a window:	Right Click the title bar or close button and check lock.
+ * To unlock a window:	Right Click the close button which appears as a lock icon when locked.
+
+####Transparency
+
+Each window has two transparency settings. Fade in and fade out.  Each setting controls the transparency level for the window borders & background.
+
+- The fade in setting is used when the window has mouse focus.
+- The fade out setting is use when the mouse leaves the window.
+
+You can change these settings by Right Clicking the window title bar.
+
+When using a slider control if you hold down shift all units are snapped to 0.1.  Pressing ALT while on a slider will set its value to 1.0
+
+
+###Minimap Carbonite Icon
+
+This icon is found at the top left of the minimap or at the top of the minimap docking window.
+
+Left Clicking will show or hide the map.
+Right Clicking will open the main Carbonite menu. The menu can be used to open the help or options windows.
+
+
+###Map
+
+Left Click and drag to move the map around inside the window
+Roll your mouse wheel to zoom in/out at the current mouse position on the map.
+Pressing M will toggle the map between normal mode and full-screen mode.
+
+The size, position and settings for the map are saved.  These settings are also saved independently for each battleground.
+
+The *"Follow You"* option is on by default for the normal map.  As you move about, the map will adjust to keep you in the center of the screen.  Various battleground maps have this setting off by default as you will typically want to view the entire map and not have it scrolling as you move.
+
+The map has two additional fade settings.  These control the transparency level of the map itself and can be adjusted by Right Clicking in the map window title.
+
+The map title shows the zone you are currently in, your map coordinates and your movement speed as a percentage of normal walk speed.
+
+The map tooltip will show you the level range of the map and is color coded based on faction (Yellow = contested, Green = friendly, Red = enemy)
+
+Party/Raid members will show up as blue dots on your map.  Friends and guild mates running Carbonite will show up on your map as yellow and green dots respectively.  Other Carbonite users in your zone will show up as gray dots on the map.
+
+The tooltip of any Carbonite user on the map will show you their coordinates, health, target name and target health.  Right Clicking their icon will allow you to whisper, retrieve quests and GOTO them.
+
+For users wishing to see your original map, it is accessible by pressing ALT+M.
+
+
+####Map Menu
+
+Right Clicking a non icon area of the map will show the main map menu.
+
+*"Goto"* - Sets a point on the map, which the map and HUD will track. Map moves and scales to keep both you and the goto visible.
+"Clear Goto" - Clears all gotos from the map.
+
+*"Add Note"* - Sets a note for the click location in a folder with that zone name in the Favorites window. It will be shown on the map when that zone is selected.
+
+*"Save Map Scale"* - Saves (remembers) the current map scale (zoom level). A keybinding can be set to do this.
+*"Restore Map Scale"* - Sets the current map scale to the value that was previouly saved. A keybinding can be set to do this.
+
+*"Follow You"* - If on, when you move or turn, the map will scroll to keep you in the center.
+
+*"Select Cities First"* - Changes how cities are selected when you mouse over the map. It will select the zone, like Terokkar, first instead of the city Shattrath. Mostly useless. Someone was having a problem with tring to select a zone and it was added.
+
+*"Monitor Zone"* - Makes you join that zone channel even if you are not in the zone, so you can see players and get punk info from the zone. Useful if you think a punk moved to another zone or to expand your punk detection.
+
+
+
+###Quests
+
+The quest log replaces the original quest log.  Like most windows it is fully sizeable.
+You can Click the button or Shift Click any quest title in the quest log to add it to the watch list.  When you pick up a new quest it will be automatically added to the watch list.  Any quest can be watched including quests with no objectives.  You can add as many quests to the watch list as you like. If you Shift Click a quest category header it will add/remove all quests under that category.
+
+Right Clicking a quest in the quest log will bring up a menu with additional options.
+
+Menu:
+
+* Watch All Quests will mark all quests as being watched, so they show in the Watch List.
+* Share will try to share the quest with your party.
+* Abandon will ask you if you want to abandon the quest.
+
+
+The quest log has 3 additional tabs:
+
+- History: a history of completed quests
+- Database: a searchable list of quests in the database (shows current map zone by default)
+- Player: You can Right Click another Carbonite user's map icon to retrieve their quests.  Their quests will show up in this tab.
+
+
+####Quest Watch List
+
+The watch window is draggable but not sizeable.  It grows and shrinks as needed based on the quests you are currently watching. The Watch window can be made into a sizeable scrolling list if "Use fixed size list" is checked in the Quest Watch page of the Options window.
+
+The green button toggles if all watched quests will be shown on the map and is on by default.
+
+The purple *"Auto Track"* button will target the highest priority quest objective and updates dynamically as you move. Priority is based on distance, quest level and if the quest is complete.
+
+The yellow/blue *"Quest Givers"* button shows Quest Giver icons on the map. Normal ones are shown as parchment icons. Daily quest givers as blue ! icons.
+
+Button colors:
+
+* Dark yellow: No givers
+* Yellow: Quest givers and daily givers
+* Blue: Daily givers
+
+The white *"Show Party Quests"* button determines if quests from other party members with Carbonite will also be shown in the Watch List.
+
+
+####Quest Watch List Objective Buttons
+
+The round buttons to the left of the quests/objectives have several functions.
+
+Left Click will activate *"GOTO"* mode.  This display the location and direction of the objective on the world map.  The map will scale so that you and your target are always visible.
+
+Shift Left Click will toggle the display of quest objectives on/off, but not track it.
+
+Alt Left Click will send a status message about the quest to party chat.
+
+Right Click will bring up a menu with additional options.
+
+Alt Right Click will open the Quest Log with that quest selected.
+
+The black squares will show a tooltip with quest information if you put the mouse cursor over them.
+
+
+###HUD
+
+The HUD arrow turns on whenever you are using the GOTO feature.  The arrow will point to the target and show you the name, distance and estimated arrival time.  The HUD arrow can be moved by dragging the title bar.
+
+Left Clicking the arrow will target a player if it is pointing at a player.
+Right Clicking the arrow will target the target of a player if it is pointing at a player.
+
+
+###Guide
+
+The guide is your in-game GPS with the location of various points of interest.  You can bring up the Guide by Clicking the Guide button on the map window (Question Icon).  By default the map will show you common POIs such as mailbox, bank, flight path, etc. when the map is zoomed in to a certain level.
+
+You can Right Click any POI icon to GOTO it or paste the name & coordinates into a chat message.
+
+Clicking any guide button will display the POI on the map and activate the GOTO mode where appropriate.
+
+Some guide categories have subcategories ( >>> after the text).  If you Click the text it will open up the subcategory.  Pressing the back button will move back up one level.
+
+We plan to add new categories based on user feedback, such as browsing honor/arena rewards.
+
+
+###Warehouse
+
+The Warehouse enables you to browse the equipment and information of every one of your characters at one time.  You can bring up the Warehouse by clicking the Warehouse button in the map window (Chest Icon at bottom of map).
+
+The Warehouse window has a list of your characters on the left side and items on the right side. You can select your characters in the left panel while the right panel displays their inventory, bank or profession items. Clicking a name in the left shows the items. Clicking a profession shows what can be make or done using the profession. You have to open each profession window for the data to get recorded in the Warehouse. This also records a profession link, if it has a link. You can the left click the chain icon to paste the link into an open chat edit box.
+
+You can link items from the warehouse by clicking the item icon.
+
+There is a search field at the top right of the window.  You can type any text into this field and it will display matching items below.
+
+You can click on *"All Characters"* and it will display all the items of all your characters at once. This is a useful feature when you are trying to track down specific items.
+
+Equipped items are listed first; other items follow grouped by category. The number in front of an item name shows the total number that the current character or all characters have. It will be blank if the count is one. The numbers after the name are the amounts in inventory and bank.
+
+Right click the list for a popup menu that allows you to turn off the category headers.
+If you left click on an item it will display the names and total count of any characters with the item. Click the names to hide them.
+
+After installing Carbonite for the first time, it is a good idea to open up the bank with each of your characters to populate the warehouse data.
+
+The sync command in the Warehouse menu imports characters from other accounts in the transfer file that match the current server and exports all current server character data as recorded in the Warehouse. Every character stat that the Warehouse tracks is transfered. You would then copy the CarboniteTransfer.lua file from the SavedVariables folder of the current account to the other account's SavedVariables folder.
+
+The only requirement is that the *"Remember Account Name"* setting at the account login screen be checked when you login, so Carbonite can know which account you are on when you sync. That is stored in the CVars if it is checked.
+
+
+###Transfering settings to other characters
+
+You can move the window layouts and other settings from a character to all your other characters. You would login with the character that is setup the way you like. Open the Warehouse. Right click the list on the right half of the window. Select *"Export current settings to all characters"* and click *"Export"* on the message box.
+
+You can also do it the opposite way using *"Import settings"* from the same menu, but you would have to do that on each character.
+
+
+###Social window
+
+The Social window is opened by pressing the O key and contains the normal friends window tabs and the Carbonite *"Pals"* and *"Punks"* tabs.
+
+####Pals
+
+The *"Pals"* tab keeps track of your friends across all your characters and lets you add them as friends on any character you log in with. It also lets you assign a character to a person, so you can group characters according to the player that owns them. Right click the list for a menu of commands.
+
+The Pals List automatically adds the names of any friends the currently logged in character has. The game keeps a list of friends separately for each character. The Friends List can have a maximum of 50 characters. Pals info is stored by Carbonite for the realm, so you can see all Pals on all characters you have on a realm.
+
+A Pal character name will show in red if they are not on the Friends List of the character that is currently logged in. Right click the name and select "Make Pal Into Friend" to add that Pal to the current character's Friends List.
+
+If you want to remove a Pal, you have to remove them from the Friends List on each character. An addon cannot remove friends from a character that is not currently logged in. Log in to each of your characters, right click the Pal name and select "Remove Pal And Friend". Once they are removed from each character, they will stop showing up as a Pal.
+
+####Punks
+
+The "Punks" tab is for finding enemy players and keeping notes on them. The list has a top and bottom section divided by a blue "-- Active --" line of text. The top lists the names of enemies you have manually added to the list and when detected you will get a message and the area of the map they were seen at will have a large green glowing circle around it and a red icon near the middle of the area. The bottom of the list shows recent punk detections. Those punk areas will show a red glow on the map. Right click the list for the popup menu. When you use "Add Character" from the menu it will add an enemy player to the top section of the list. If an enemy player is targeted it will use that name, otherwise an edit box will open and be filled with the name of the most recent punk personally detected near you. A chat message will show if a new punk is detected near you.
+
+Punks list options are in the "Social & Punks" page in the Options window.
+
+The Social window can be disabled, right click the Carbonite minimap icon and select "Options". Click "Social & Punks" in the left side list, uncheck the box on the right side and reload UI when asked.
+
+
+####Favorites window
+
+The Favorites window has a left and right side.
+
+The left side shows a tree of folders and favorites. You can put folders inside of folders. This works like a computer file system. You select a favorite for viewing or editing by left clicking it.
+
+The right side shows the list of items that belong to the currently selected favorite.
+
+There are 4 item types you can put in a favorite.
+
+1. Comment. Just a line of text that shows in the favorite item list. Create by right clicking the item list and selecting *"Add Comment"*.
+
+2. Note. An item that has an icon, text and map location. Create by right clicking the map and selecting *"Add Note"*. The note will be created in a favorite with the name of the zone. The favorite will be in the *"Notes"* folder. The note will set to the map location where you right clicked and will be set to the Star icon. Notes can be put inside of favorites that are not in the notes folder, but they will not automatically show on the map when the zone is selected. The point of that is so you can make a favorite with you own set of steps (dailies, quest guide) and have notes mixed with targets. When the "Record" button is on the note will go into the selected favorite instead of the favorite in the notes folder.
+
+3. Target 1st. This is the first part of a path or a single destination. Has a name and a map location. These are created when the "Record" button is on and you ctrl click the map or right click the map and select *"Goto"*.
+
+4. Target. This is the next part of a path. Has a name and a map location. These are created when the *"Record"* button is on and you ctrl shift click the map.
+
+###Record Mode
+
+This is on when the Record button is pressed. The button will glow red. Any map targets created (goto, guide or quest selection) will be added to the currently selected favorite below the selected item. Record mode is canceled when a different favorite is selected.
+
+####Viewing
+
+Note items inside of favorites in the *"Notes"* folder will be automatically drawn on the map if the the selected zone name matches the favorite name. Notes in favorites in any other folder will only be drawn when selected in the item list. The Notes folder is meant to mimic how notes are managed in other addons. Generally you should not put items other than notes inside the favorites in the notes folder.
+
+Targets are drawn on the map when selected in the item list. Each target after the selected one will also be drawn until a *"Target 1st"* or a non target is reached. This lets you see a whole path or part of a path.
+
+
+###Info Windows
+
+Info windows show various bits of information in a small movable list.
+Info #1 to #6 come with various default text in them.
+Right click the Carbonite minimap button and select "Show Info 1 2" to make #1 and #2 visible. These are setup for the health and mana of you and your target.
+
+To move or edit them, you need to unlock them on the Info Windows page of the Carb Options window.
+
+* Left click and drag the window title bar to move them around.
+* Right click a line in an unlocked info window and select *"New"* to show Info #3. Again will show #4 and so on.
+* Right click a line in an unlocked info window and select *"Edit Item"* to change the text for that line.
+
+####Info text
+
+* ```<xxx>``` runs a command.
+* ```<c>``` is the color from the last command.
+* ```<t>``` is the text from the last command.
+* ```xxx``` is raw text.
+
+#####Example
+
+```<THealth><c>HP <t>``` This runs the target health command, sets the color, shows the text *"HP "* and shows the text from the command.
+
+You cannot currently add new lines to an Info Window, but Info #3, 5 and 6 have an extra blank line in them, which can be edited.
+
+Info Window defaults:
+
+1. Your health, mana, DK runes, rogue combo points, global cooldown bar, casting bar.
+2. Target health, mana, casting bar.
+3. Durability, time to level.
+4. Battleground queues, start, duration, honor, stats.
+5. Time, FPS.
+6. Rest percentage
+
+
+###Battlegrounds
+
+Carbonite adds clickable objective icons right onto your Battleground map. Timer bars are displayed under each objective and you can mouse over to see the exact times. Right Click on any objective to issue orders such as attack, defend, incoming, and to report time status. Shift Click an objective to send an incoming message.  Each Click adds one to the count.  E.g. Shift Click 3 times on the Lumber Mill icon and you will say *Incoming Lumber Mill: 3*
+
+Hold down ALT to display player names (works anywhere, not just battlegrounds).
+Hold down Shift to draw objectives on top of the player icons.
+
+When a player is in combat his icon has an X in the middle.
+The icon for each player has a health bar along the top and his target's health bar is displayed down the left side.
+
+The HUD arrow will display the closest teammate that is in combat.  It will also point out friends/guildmates in the same battleground. When left clicked it will target that player and right click will target the target of that player.
+
+
+###Keyboard modifiers
+
+####Map
+
+ * Shift down - Makes player arrow small. Draws BG objectives on top
+ * Shift click - Pings minimap if click is near the player arrow on the map
+ * Ctrl left click - Sets goto
+ * Alt down - Shows player icon names and makes icons draw on top
+
+####Minimap (in Carbonite map)
+
+ * Shift click - Pings
+ * Ctrl down - Makes integrated minimap draw on top or bottom if already on top
+ * Alt down - Makes docked minimap transparency 50%
+
+####List
+
+ * Shift down - Makes mouse wheel scroll 5 times faster
+ * Shift + ctrl down - Makes mouse wheel scroll 100 times faster
+
+####Quest Watch
+
+ * Alt left click button - Send quest status to party
+ * Alt right click button - Open quest window with quest selected
+
+####Settable Keybindings
+
+ * Toggle Original Map
+ * Toggle Normal or Max Map
+ * Toggle None or Max Map
+ * Toggle None or Normal Map
+ * Restore Saved Map Scale
+ * Toggle Full Size Minimap
+ * Toggle Favorites
+ * Toggle Guide
+ * Toggle Warehouse
+ * Toggle Watch List Minimize
+
+####Map Icons
+
+Round solid icons are players:
+
+  * Yellow: friend
+  * Green: guild
+  * Blue: party
+  * Grey: non of the above
+
+  * Top Horizontal Bar: player health
+  * Mid Horizontal Bar: friendly target health
+  * Left Vertical Bar: enemy health (red glow if a player)
+  * Map icon with x in center: in combat
+  * Map icon with a red center: health low
+  * Map icon with a black center: dead
+
+Round icons with black centers are for quests. A white icon is a quest ender if quest is simply to get to the end location.
+
+By default there are 12 quest colors. Each quest starting at the top of the quest log has a different color. Once the 12 colors are used it repeats.
+
+  * Red - first quest in quest log
+  * Green - second quest in quest log
+  * Blue - third quest in quest log
+  * Yellow - forth quest and so on
+
+If "Use one color per quest" is off then:
+
+  * Red - objective #1 or #4
+  * Green - objective #2 or #5
+  * Blue - objective #3 or #6
+
+Other Quest Icons:
+
+* Yellow ! - quest starter when you add a goto quest giver
+* Yellow ? - quest ender
+
+Square icons with 4 black arrows are the closest point to reach a quest area:
+
+* White color - is being tracked
+* Non white colors match the same quest colors as described above.
+
+
+####Gathering
+
+Carbonite tracks mining, herb, gas and everfost shard locations when you gather them.
+
+To show them on the map for the selected zone:
+
+* Herbs - Right click a non icon area of map, select Show and check "Show Herb Locations".
+* Mining - Right click a non icon area of map, select Show and check "Show Mining Locations".
+* Gas - Click the Guide ? icon on map, left click "Gather >>>" and left click the Gas icon.
+* Everfrost chip - Click the Guide ? icon on map, left click "Gather >>>" and left click the Everfrost chip icon.
+
+#####Routing
+
+Once any nodes are being shown on the map, you can right click a non icon area of map, select "Route..." and select "Current Gather Locations" to make a route on the map.
+
+
+###Carbonite Items
+
+CarboniteItems is a data addon that contains information on over 25000 game items. It is a load on demand addon, which means it is not actually loaded until you use the "Items >>" section of the Guide. Left click the "Items >>" text to view the CarboniteItems data.
+
+Mouse over the item icons to see a Carbonite generated tooltip of information on the item. The tooltip is similar to the normal game tooltip, but there are some minor differences. If the item icon is not shown as a ?, then the item is in the game's cache file, which means you can hold down the alt key and then mouse over the icons to see the game's tooltip for the item.
+
+The "Search [click]" edit box filters the items shown in the list on the right side by searching the Carbonite tooltips of the items currently show. Some examples:
+
+ spell pow    (items with spell power)
+ hit rat      (items with hit rating)
+ mana per     (items with mana regeneration)
+ quest:       (items from a quest)
+ minor        (only minor glyphs)
+
+The first tooltip line that matches the filter will be shown in the Info3 column.
+
+Left click a column header to sort by that column.
+Shift left click a column header to decrease the column width.
+Shift right click a column header to increase the column width.
+
+
+###Carbonite Nodes
+
+CarboniteNodes is a simple data addon that contains predefined locations for Herbalism and Mining. It is a load on demand addon, which means it is not actually loaded until you import data from it into Carbonite.
+
+To import the data into Carbonite's gather data, you right click the Carbonite minimap button, select "Options" and select the Guide page of Options window. You would then left click the text that says "Import Carbonite Nodes Herbalism locations" to get the herbs and "Import Carbonite Nodes Mining locations" to get the mining data.
+
+
+###Carbonite Transfer (OLD)
+
+CarboniteTransfer is a simple addon that is used to move Warehouse data between accounts. It will also be used to send and receive favorites in the future. You can delete it or disable it, although it takes almost no memory since it is empty until used.
+
+In the Warehouse you right click the character list and select "Sync account transfer file" and any characters from your other synced accounts are imported from the CarboniteTransfer.lua file and characters in the current account are exported to the CarboniteTransfer.lua file. The file is then copied to the Savedvariables folder of another account, so you can sync the Warehouse data when you login with that account.
+
+Transfering is a manual process, because addons cannot directly access files and can't see addon data from other accounts. You have to copy the CarboniteTransfer.lua file from one SavedVariables folder to another.
+
+Example:
+
+1. Login to any character using AccountA.
+
+2. Select "Sync account transfer file" from the Warehouse menu.
+
+3. Logout. Go back to Account Screen, which saves the CarboniteTransfer.lua file.
+
+4. Copy ```WTF\Account\<AccountA>\SavedVariables\CarboniteTransfer.lua```  to  ```WTF\Account\<AccountB>\SavedVariables\CarboniteTransfer.lua```
+
+5. Login to any character using AccountB.
+
+6. Select "Sync account transfer file" from the Warehouse menu. AccountB will now have Warehouse data from AccountA.
+
+----------------------------------------------------------
+
+#Appendix
+
+Copyright 2007-2012 Carbon Based Creations, LLC
+CARBONITE(tm) is a registered trademark of Carbon Based Creations, LLC.
+
+World of Warcraft(tm) and "WOW" are trademarks owned by Blizzard Entertainment, Inc.
+The CARBONITE addon is not endorsed by or affiliated with Blizzard Entertainment, Inc.
+
+Website: carboniteaddon.com
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
\ No newline at end of file
diff --git a/Carbonite/Docs/gpl.txt b/Carbonite/Docs/gpl.txt
index 94a9ed0..818433e 100644
--- a/Carbonite/Docs/gpl.txt
+++ b/Carbonite/Docs/gpl.txt
@@ -1,674 +1,674 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/Carbonite/Libs/AceAddon-3.0/AceAddon-3.0.lua b/Carbonite/Libs/AceAddon-3.0/AceAddon-3.0.lua
index 0ea93d1..f392a21 100644
--- a/Carbonite/Libs/AceAddon-3.0/AceAddon-3.0.lua
+++ b/Carbonite/Libs/AceAddon-3.0/AceAddon-3.0.lua
@@ -1,649 +1,649 @@
---- **AceAddon-3.0** provides a template for creating addon objects.
--- It'll provide you with a set of callback functions that allow you to simplify the loading
--- process of your addon.\\
--- Callbacks provided are:\\
--- * **OnInitialize**, which is called directly after the addon is fully loaded.
--- * **OnEnable** which gets called during the PLAYER_LOGIN event, when most of the data provided by the game is already present.
--- * **OnDisable**, which is only called when your addon is manually being disabled.
--- @usage
--- -- A small (but complete) addon, that doesn't do anything,
--- -- but shows usage of the callbacks.
--- local MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon")
---
--- function MyAddon:OnInitialize()
---   -- do init tasks here, like loading the Saved Variables,
---   -- or setting up slash commands.
--- end
---
--- function MyAddon:OnEnable()
---   -- Do more initialization here, that really enables the use of your addon.
---   -- Register Events, Hook functions, Create Frames, Get information from
---   -- the game that wasn't available in OnInitialize
--- end
---
--- function MyAddon:OnDisable()
---   -- Unhook, Unregister Events, Hide frames that you created.
---   -- You would probably only use an OnDisable if you want to
---   -- build a "standby" mode, or be able to toggle modules on/off.
--- end
--- @class file
--- @name AceAddon-3.0.lua
--- @release $Id: AceAddon-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
-
-local MAJOR, MINOR = "AceAddon-3.0", 13
-local AceAddon, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceAddon then return end -- No Upgrade needed.
-
-AceAddon.frame = AceAddon.frame or CreateFrame("Frame", "AceAddon30Frame") -- Our very own frame
-AceAddon.addons = AceAddon.addons or {} -- addons in general
-AceAddon.statuses = AceAddon.statuses or {} -- statuses of addon.
-AceAddon.initializequeue = AceAddon.initializequeue or {} -- addons that are new and not initialized
-AceAddon.enablequeue = AceAddon.enablequeue or {} -- addons that are initialized and waiting to be enabled
-AceAddon.embeds = AceAddon.embeds or setmetatable({}, {__index = function(tbl, key) tbl[key] = {} return tbl[key] end }) -- contains a list of libraries embedded in an addon
-
--- Lua APIs
-local tinsert, tconcat, tremove = table.insert, table.concat, table.remove
-local fmt, tostring = string.format, tostring
-local select, pairs, next, type, unpack = select, pairs, next, type, unpack
-local loadstring, assert, error = loadstring, assert, error
-local setmetatable, getmetatable, rawset, rawget = setmetatable, getmetatable, rawset, rawget
-
---[[
-	 xpcall safecall implementation
-]]
-local xpcall = xpcall
-
-local function errorhandler(err)
-	return geterrorhandler()(err)
-end
-
-local function safecall(func, ...)
-	-- we check to see if the func is passed is actually a function here and don't error when it isn't
-	-- this safecall is used for optional functions like OnInitialize OnEnable etc. When they are not
-	-- present execution should continue without hinderance
-	if type(func) == "function" then
-		return xpcall(func, errorhandler, ...)
-	end
-end
-
--- local functions that will be implemented further down
-local Enable, Disable, EnableModule, DisableModule, Embed, NewModule, GetModule, GetName, SetDefaultModuleState, SetDefaultModuleLibraries, SetEnabledState, SetDefaultModulePrototype
-
--- used in the addon metatable
-local function addontostring( self ) return self.name end
-
--- Check if the addon is queued for initialization
-local function queuedForInitialization(addon)
-	for i = 1, #AceAddon.initializequeue do
-		if AceAddon.initializequeue[i] == addon then
-			return true
-		end
-	end
-	return false
-end
-
---- Create a new AceAddon-3.0 addon.
--- Any libraries you specified will be embeded, and the addon will be scheduled for
--- its OnInitialize and OnEnable callbacks.
--- The final addon object, with all libraries embeded, will be returned.
--- @paramsig [object ,]name[, lib, ...]
--- @param object Table to use as a base for the addon (optional)
--- @param name Name of the addon object to create
--- @param lib List of libraries to embed into the addon
--- @usage
--- -- Create a simple addon object
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceEvent-3.0")
---
--- -- Create a Addon object based on the table of a frame
--- local MyFrame = CreateFrame("Frame")
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon(MyFrame, "MyAddon", "AceEvent-3.0")
-function AceAddon:NewAddon(objectorname, ...)
-	local object,name
-	local i=1
-	if type(objectorname)=="table" then
-		object=objectorname
-		name=...
-		i=2
-	else
-		name=objectorname
-	end
-	if type(name)~="string" then
-		error(("Usage: NewAddon([object,] name, [lib, lib, lib, ...]): 'name' - string expected got '%s'."):format(type(name)), 2)
-	end
-	if self.addons[name] then
-		error(("Usage: NewAddon([object,] name, [lib, lib, lib, ...]): 'name' - Addon '%s' already exists."):format(name), 2)
-	end
-
-	object = object or {}
-	object.name = name
-
-	local addonmeta = {}
-	local oldmeta = getmetatable(object)
-	if oldmeta then
-		for k, v in pairs(oldmeta) do addonmeta[k] = v end
-	end
-	addonmeta.__tostring = addontostring
-
-	setmetatable( object, addonmeta )
-	self.addons[name] = object
-	object.modules = {}
-	object.orderedModules = {}
-	object.defaultModuleLibraries = {}
-	Embed( object ) -- embed NewModule, GetModule methods
-	self:EmbedLibraries(object, select(i,...))
-
-	-- add to queue of addons to be initialized upon ADDON_LOADED
-	tinsert(self.initializequeue, object)
-	return object
-end
-
-
---- Get the addon object by its name from the internal AceAddon registry.
--- Throws an error if the addon object cannot be found (except if silent is set).
--- @param name unique name of the addon object
--- @param silent if true, the addon is optional, silently return nil if its not found
--- @usage
--- -- Get the Addon
--- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
-function AceAddon:GetAddon(name, silent)
-	if not silent and not self.addons[name] then
-		error(("Usage: GetAddon(name): 'name' - Cannot find an AceAddon '%s'."):format(tostring(name)), 2)
-	end
-	return self.addons[name]
-end
-
--- - Embed a list of libraries into the specified addon.
--- This function will try to embed all of the listed libraries into the addon
--- and error if a single one fails.
---
--- **Note:** This function is for internal use by :NewAddon/:NewModule
--- @paramsig addon, [lib, ...]
--- @param addon addon object to embed the libs in
--- @param lib List of libraries to embed into the addon
-function AceAddon:EmbedLibraries(addon, ...)
-	for i=1,select("#", ... ) do
-		local libname = select(i, ...)
-		self:EmbedLibrary(addon, libname, false, 4)
-	end
-end
-
--- - Embed a library into the addon object.
--- This function will check if the specified library is registered with LibStub
--- and if it has a :Embed function to call. It'll error if any of those conditions
--- fails.
---
--- **Note:** This function is for internal use by :EmbedLibraries
--- @paramsig addon, libname[, silent[, offset]]
--- @param addon addon object to embed the library in
--- @param libname name of the library to embed
--- @param silent marks an embed to fail silently if the library doesn't exist (optional)
--- @param offset will push the error messages back to said offset, defaults to 2 (optional)
-function AceAddon:EmbedLibrary(addon, libname, silent, offset)
-	local lib = LibStub:GetLibrary(libname, true)
-	if not lib and not silent then
-		error(("Usage: EmbedLibrary(addon, libname, silent, offset): 'libname' - Cannot find a library instance of %q."):format(tostring(libname)), offset or 2)
-	elseif lib and type(lib.Embed) == "function" then
-		lib:Embed(addon)
-		tinsert(self.embeds[addon], libname)
-		return true
-	elseif lib then
-		error(("Usage: EmbedLibrary(addon, libname, silent, offset): 'libname' - Library '%s' is not Embed capable"):format(libname), offset or 2)
-	end
-end
-
---- Return the specified module from an addon object.
--- Throws an error if the addon object cannot be found (except if silent is set)
--- @name //addon//:GetModule
--- @paramsig name[, silent]
--- @param name unique name of the module
--- @param silent if true, the module is optional, silently return nil if its not found (optional)
--- @usage
--- -- Get the Addon
--- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
--- -- Get the Module
--- MyModule = MyAddon:GetModule("MyModule")
-function GetModule(self, name, silent)
-	if not self.modules[name] and not silent then
-		error(("Usage: GetModule(name, silent): 'name' - Cannot find module '%s'."):format(tostring(name)), 2)
-	end
-	return self.modules[name]
-end
-
-local function IsModuleTrue(self) return true end
-
---- Create a new module for the addon.
--- The new module can have its own embeded libraries and/or use a module prototype to be mixed into the module.\\
--- A module has the same functionality as a real addon, it can have modules of its own, and has the same API as
--- an addon object.
--- @name //addon//:NewModule
--- @paramsig name[, prototype|lib[, lib, ...]]
--- @param name unique name of the module
--- @param prototype object to derive this module from, methods and values from this table will be mixed into the module (optional)
--- @param lib List of libraries to embed into the addon
--- @usage
--- -- Create a module with some embeded libraries
--- MyModule = MyAddon:NewModule("MyModule", "AceEvent-3.0", "AceHook-3.0")
---
--- -- Create a module with a prototype
--- local prototype = { OnEnable = function(self) print("OnEnable called!") end }
--- MyModule = MyAddon:NewModule("MyModule", prototype, "AceEvent-3.0", "AceHook-3.0")
-function NewModule(self, name, prototype, ...)
-	if type(name) ~= "string" then error(("Usage: NewModule(name, [prototype, [lib, lib, lib, ...]): 'name' - string expected got '%s'."):format(type(name)), 2) end
-	if type(prototype) ~= "string" and type(prototype) ~= "table" and type(prototype) ~= "nil" then error(("Usage: NewModule(name, [prototype, [lib, lib, lib, ...]): 'prototype' - table (prototype), string (lib) or nil expected got '%s'."):format(type(prototype)), 2) end
-
-	if self.modules[name] then error(("Usage: NewModule(name, [prototype, [lib, lib, lib, ...]): 'name' - Module '%s' already exists."):format(name), 2) end
-
-	-- modules are basically addons. We treat them as such. They will be added to the initializequeue properly as well.
-	-- NewModule can only be called after the parent addon is present thus the modules will be initialized after their parent is.
-	local module = AceAddon:NewAddon(fmt("%s_%s", self.name or tostring(self), name))
-
-	module.IsModule = IsModuleTrue
-	module:SetEnabledState(self.defaultModuleState)
-	module.moduleName = name
-
-	if type(prototype) == "string" then
-		AceAddon:EmbedLibraries(module, prototype, ...)
-	else
-		AceAddon:EmbedLibraries(module, ...)
-	end
-	AceAddon:EmbedLibraries(module, unpack(self.defaultModuleLibraries))
-
-	if not prototype or type(prototype) == "string" then
-		prototype = self.defaultModulePrototype or nil
-	end
-
-	if type(prototype) == "table" then
-		local mt = getmetatable(module)
-		mt.__index = prototype
-		setmetatable(module, mt)  -- More of a Base class type feel.
-	end
-
-	safecall(self.OnModuleCreated, self, module) -- Was in Ace2 and I think it could be a cool thing to have handy.
-	self.modules[name] = module
-	tinsert(self.orderedModules, module)
-
-	return module
-end
-
---- Returns the real name of the addon or module, without any prefix.
--- @name //addon//:GetName
--- @paramsig
--- @usage
--- print(MyAddon:GetName())
--- -- prints "MyAddon"
-function GetName(self)
-	return self.moduleName or self.name
-end
-
---- Enables the Addon, if possible, return true or false depending on success.
--- This internally calls AceAddon:EnableAddon(), thus dispatching a OnEnable callback
--- and enabling all modules of the addon (unless explicitly disabled).\\
--- :Enable() also sets the internal `enableState` variable to true
--- @name //addon//:Enable
--- @paramsig
--- @usage
--- -- Enable MyModule
--- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
--- MyModule = MyAddon:GetModule("MyModule")
--- MyModule:Enable()
-function Enable(self)
-	self:SetEnabledState(true)
-
-	-- nevcairiel 2013-04-27: don't enable an addon/module if its queued for init still
-	-- it'll be enabled after the init process
-	if not queuedForInitialization(self) then
-		return AceAddon:EnableAddon(self)
-	end
-end
-
---- Disables the Addon, if possible, return true or false depending on success.
--- This internally calls AceAddon:DisableAddon(), thus dispatching a OnDisable callback
--- and disabling all modules of the addon.\\
--- :Disable() also sets the internal `enableState` variable to false
--- @name //addon//:Disable
--- @paramsig
--- @usage
--- -- Disable MyAddon
--- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
--- MyAddon:Disable()
-function Disable(self)
-	self:SetEnabledState(false)
-	return AceAddon:DisableAddon(self)
-end
-
---- Enables the Module, if possible, return true or false depending on success.
--- Short-hand function that retrieves the module via `:GetModule` and calls `:Enable` on the module object.
--- @name //addon//:EnableModule
--- @paramsig name
--- @usage
--- -- Enable MyModule using :GetModule
--- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
--- MyModule = MyAddon:GetModule("MyModule")
--- MyModule:Enable()
---
--- -- Enable MyModule using the short-hand
--- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
--- MyAddon:EnableModule("MyModule")
-function EnableModule(self, name)
-	local module = self:GetModule( name )
-	return module:Enable()
-end
-
---- Disables the Module, if possible, return true or false depending on success.
--- Short-hand function that retrieves the module via `:GetModule` and calls `:Disable` on the module object.
--- @name //addon//:DisableModule
--- @paramsig name
--- @usage
--- -- Disable MyModule using :GetModule
--- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
--- MyModule = MyAddon:GetModule("MyModule")
--- MyModule:Disable()
---
--- -- Disable MyModule using the short-hand
--- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
--- MyAddon:DisableModule("MyModule")
-function DisableModule(self, name)
-	local module = self:GetModule( name )
-	return module:Disable()
-end
-
---- Set the default libraries to be mixed into all modules created by this object.
--- Note that you can only change the default module libraries before any module is created.
--- @name //addon//:SetDefaultModuleLibraries
--- @paramsig lib[, lib, ...]
--- @param lib List of libraries to embed into the addon
--- @usage
--- -- Create the addon object
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon")
--- -- Configure default libraries for modules (all modules need AceEvent-3.0)
--- MyAddon:SetDefaultModuleLibraries("AceEvent-3.0")
--- -- Create a module
--- MyModule = MyAddon:NewModule("MyModule")
-function SetDefaultModuleLibraries(self, ...)
-	if next(self.modules) then
-		error("Usage: SetDefaultModuleLibraries(...): cannot change the module defaults after a module has been registered.", 2)
-	end
-	self.defaultModuleLibraries = {...}
-end
-
---- Set the default state in which new modules are being created.
--- Note that you can only change the default state before any module is created.
--- @name //addon//:SetDefaultModuleState
--- @paramsig state
--- @param state Default state for new modules, true for enabled, false for disabled
--- @usage
--- -- Create the addon object
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon")
--- -- Set the default state to "disabled"
--- MyAddon:SetDefaultModuleState(false)
--- -- Create a module and explicilty enable it
--- MyModule = MyAddon:NewModule("MyModule")
--- MyModule:Enable()
-function SetDefaultModuleState(self, state)
-	if next(self.modules) then
-		error("Usage: SetDefaultModuleState(state): cannot change the module defaults after a module has been registered.", 2)
-	end
-	self.defaultModuleState = state
-end
-
---- Set the default prototype to use for new modules on creation.
--- Note that you can only change the default prototype before any module is created.
--- @name //addon//:SetDefaultModulePrototype
--- @paramsig prototype
--- @param prototype Default prototype for the new modules (table)
--- @usage
--- -- Define a prototype
--- local prototype = { OnEnable = function(self) print("OnEnable called!") end }
--- -- Set the default prototype
--- MyAddon:SetDefaultModulePrototype(prototype)
--- -- Create a module and explicitly Enable it
--- MyModule = MyAddon:NewModule("MyModule")
--- MyModule:Enable()
--- -- should print "OnEnable called!" now
--- @see NewModule
-function SetDefaultModulePrototype(self, prototype)
-	if next(self.modules) then
-		error("Usage: SetDefaultModulePrototype(prototype): cannot change the module defaults after a module has been registered.", 2)
-	end
-	if type(prototype) ~= "table" then
-		error(("Usage: SetDefaultModulePrototype(prototype): 'prototype' - table expected got '%s'."):format(type(prototype)), 2)
-	end
-	self.defaultModulePrototype = prototype
-end
-
---- Set the state of an addon or module
--- This should only be called before any enabling actually happend, e.g. in/before OnInitialize.
--- @name //addon//:SetEnabledState
--- @paramsig state
--- @param state the state of an addon or module  (enabled=true, disabled=false)
-function SetEnabledState(self, state)
-	self.enabledState = state
-end
-
-
---- Return an iterator of all modules associated to the addon.
--- @name //addon//:IterateModules
--- @paramsig
--- @usage
--- -- Enable all modules
--- for name, module in MyAddon:IterateModules() do
---    module:Enable()
--- end
-local function IterateModules(self) return pairs(self.modules) end
-
--- Returns an iterator of all embeds in the addon
--- @name //addon//:IterateEmbeds
--- @paramsig
-local function IterateEmbeds(self) return pairs(AceAddon.embeds[self]) end
-
---- Query the enabledState of an addon.
--- @name //addon//:IsEnabled
--- @paramsig
--- @usage
--- if MyAddon:IsEnabled() then
---     MyAddon:Disable()
--- end
-local function IsEnabled(self) return self.enabledState end
-local mixins = {
-	NewModule = NewModule,
-	GetModule = GetModule,
-	Enable = Enable,
-	Disable = Disable,
-	EnableModule = EnableModule,
-	DisableModule = DisableModule,
-	IsEnabled = IsEnabled,
-	SetDefaultModuleLibraries = SetDefaultModuleLibraries,
-	SetDefaultModuleState = SetDefaultModuleState,
-	SetDefaultModulePrototype = SetDefaultModulePrototype,
-	SetEnabledState = SetEnabledState,
-	IterateModules = IterateModules,
-	IterateEmbeds = IterateEmbeds,
-	GetName = GetName,
-}
-local function IsModule(self) return false end
-local pmixins = {
-	defaultModuleState = true,
-	enabledState = true,
-	IsModule = IsModule,
-}
--- Embed( target )
--- target (object) - target object to embed aceaddon in
---
--- this is a local function specifically since it's meant to be only called internally
-function Embed(target, skipPMixins)
-	for k, v in pairs(mixins) do
-		target[k] = v
-	end
-	if not skipPMixins then
-		for k, v in pairs(pmixins) do
-			target[k] = target[k] or v
-		end
-	end
-end
-
-
--- - Initialize the addon after creation.
--- This function is only used internally during the ADDON_LOADED event
--- It will call the **OnInitialize** function on the addon object (if present),
--- and the **OnEmbedInitialize** function on all embeded libraries.
---
--- **Note:** Do not call this function manually, unless you're absolutely sure that you know what you are doing.
--- @param addon addon object to intialize
-function AceAddon:InitializeAddon(addon)
-	safecall(addon.OnInitialize, addon)
-
-	local embeds = self.embeds[addon]
-	for i = 1, #embeds do
-		local lib = LibStub:GetLibrary(embeds[i], true)
-		if lib then safecall(lib.OnEmbedInitialize, lib, addon) end
-	end
-
-	-- we don't call InitializeAddon on modules specifically, this is handled
-	-- from the event handler and only done _once_
-end
-
--- - Enable the addon after creation.
--- Note: This function is only used internally during the PLAYER_LOGIN event, or during ADDON_LOADED,
--- if IsLoggedIn() already returns true at that point, e.g. for LoD Addons.
--- It will call the **OnEnable** function on the addon object (if present),
--- and the **OnEmbedEnable** function on all embeded libraries.\\
--- This function does not toggle the enable state of the addon itself, and will return early if the addon is disabled.
---
--- **Note:** Do not call this function manually, unless you're absolutely sure that you know what you are doing.
--- Use :Enable on the addon itself instead.
--- @param addon addon object to enable
-function AceAddon:EnableAddon(addon)
-	if type(addon) == "string" then addon = AceAddon:GetAddon(addon) end
-	if self.statuses[addon.name] or not addon.enabledState then return false end
-
-	-- set the statuses first, before calling the OnEnable. this allows for Disabling of the addon in OnEnable.
-	self.statuses[addon.name] = true
-
-	safecall(addon.OnEnable, addon)
-
-	-- make sure we're still enabled before continueing
-	if self.statuses[addon.name] then
-		local embeds = self.embeds[addon]
-		for i = 1, #embeds do
-			local lib = LibStub:GetLibrary(embeds[i], true)
-			if lib then safecall(lib.OnEmbedEnable, lib, addon) end
-		end
-
-		-- enable possible modules.
-		local modules = addon.orderedModules
-		for i = 1, #modules do
-			self:EnableAddon(modules[i])
-		end
-	end
-	return self.statuses[addon.name] -- return true if we're disabled
-end
-
--- - Disable the addon
--- Note: This function is only used internally.
--- It will call the **OnDisable** function on the addon object (if present),
--- and the **OnEmbedDisable** function on all embeded libraries.\\
--- This function does not toggle the enable state of the addon itself, and will return early if the addon is still enabled.
---
--- **Note:** Do not call this function manually, unless you're absolutely sure that you know what you are doing.
--- Use :Disable on the addon itself instead.
--- @param addon addon object to enable
-function AceAddon:DisableAddon(addon)
-	if type(addon) == "string" then addon = AceAddon:GetAddon(addon) end
-	if not self.statuses[addon.name] then return false end
-
-	-- set statuses first before calling OnDisable, this allows for aborting the disable in OnDisable.
-	self.statuses[addon.name] = false
-
-	safecall( addon.OnDisable, addon )
-
-	-- make sure we're still disabling...
-	if not self.statuses[addon.name] then
-		local embeds = self.embeds[addon]
-		for i = 1, #embeds do
-			local lib = LibStub:GetLibrary(embeds[i], true)
-			if lib then safecall(lib.OnEmbedDisable, lib, addon) end
-		end
-		-- disable possible modules.
-		local modules = addon.orderedModules
-		for i = 1, #modules do
-			self:DisableAddon(modules[i])
-		end
-	end
-
-	return not self.statuses[addon.name] -- return true if we're disabled
-end
-
---- Get an iterator over all registered addons.
--- @usage
--- -- Print a list of all installed AceAddon's
--- for name, addon in AceAddon:IterateAddons() do
---   print("Addon: " .. name)
--- end
-function AceAddon:IterateAddons() return pairs(self.addons) end
-
---- Get an iterator over the internal status registry.
--- @usage
--- -- Print a list of all enabled addons
--- for name, status in AceAddon:IterateAddonStatus() do
---   if status then
---     print("EnabledAddon: " .. name)
---   end
--- end
-function AceAddon:IterateAddonStatus() return pairs(self.statuses) end
-
--- Following Iterators are deprecated, and their addon specific versions should be used
--- e.g. addon:IterateEmbeds() instead of :IterateEmbedsOnAddon(addon)
-function AceAddon:IterateEmbedsOnAddon(addon) return pairs(self.embeds[addon]) end
-function AceAddon:IterateModulesOfAddon(addon) return pairs(addon.modules) end
-
--- Blizzard AddOns which can load very early in the loading process and mess with Ace3 addon loading
-local BlizzardEarlyLoadAddons = {
-	Blizzard_DebugTools = true,
-	Blizzard_TimeManager = true,
-	Blizzard_BattlefieldMap = true,
-	Blizzard_MapCanvas = true,
-	Blizzard_SharedMapDataProviders = true,
-	Blizzard_CombatLog = true,
-}
-
--- Event Handling
-local function onEvent(this, event, arg1)
-	-- 2020-08-28 nevcairiel - ignore the load event of Blizzard addons which occur early in the loading process
-	if (event == "ADDON_LOADED"  and (arg1 == nil or not BlizzardEarlyLoadAddons[arg1])) or event == "PLAYER_LOGIN" then
-		-- if a addon loads another addon, recursion could happen here, so we need to validate the table on every iteration
-		while(#AceAddon.initializequeue > 0) do
-			local addon = tremove(AceAddon.initializequeue, 1)
-			-- this might be an issue with recursion - TODO: validate
-			if event == "ADDON_LOADED" then addon.baseName = arg1 end
-			AceAddon:InitializeAddon(addon)
-			tinsert(AceAddon.enablequeue, addon)
-		end
-
-		if IsLoggedIn() then
-			while(#AceAddon.enablequeue > 0) do
-				local addon = tremove(AceAddon.enablequeue, 1)
-				AceAddon:EnableAddon(addon)
-			end
-		end
-	end
-end
-
-AceAddon.frame:RegisterEvent("ADDON_LOADED")
-AceAddon.frame:RegisterEvent("PLAYER_LOGIN")
-AceAddon.frame:SetScript("OnEvent", onEvent)
-
--- upgrade embeded
-for name, addon in pairs(AceAddon.addons) do
-	Embed(addon, true)
-end
-
--- 2010-10-27 nevcairiel - add new "orderedModules" table
-if oldminor and oldminor < 10 then
-	for name, addon in pairs(AceAddon.addons) do
-		addon.orderedModules = {}
-		for module_name, module in pairs(addon.modules) do
-			tinsert(addon.orderedModules, module)
-		end
-	end
-end
+--- **AceAddon-3.0** provides a template for creating addon objects.
+-- It'll provide you with a set of callback functions that allow you to simplify the loading
+-- process of your addon.\\
+-- Callbacks provided are:\\
+-- * **OnInitialize**, which is called directly after the addon is fully loaded.
+-- * **OnEnable** which gets called during the PLAYER_LOGIN event, when most of the data provided by the game is already present.
+-- * **OnDisable**, which is only called when your addon is manually being disabled.
+-- @usage
+-- -- A small (but complete) addon, that doesn't do anything,
+-- -- but shows usage of the callbacks.
+-- local MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon")
+--
+-- function MyAddon:OnInitialize()
+--   -- do init tasks here, like loading the Saved Variables,
+--   -- or setting up slash commands.
+-- end
+--
+-- function MyAddon:OnEnable()
+--   -- Do more initialization here, that really enables the use of your addon.
+--   -- Register Events, Hook functions, Create Frames, Get information from
+--   -- the game that wasn't available in OnInitialize
+-- end
+--
+-- function MyAddon:OnDisable()
+--   -- Unhook, Unregister Events, Hide frames that you created.
+--   -- You would probably only use an OnDisable if you want to
+--   -- build a "standby" mode, or be able to toggle modules on/off.
+-- end
+-- @class file
+-- @name AceAddon-3.0.lua
+-- @release $Id: AceAddon-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
+
+local MAJOR, MINOR = "AceAddon-3.0", 13
+local AceAddon, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceAddon then return end -- No Upgrade needed.
+
+AceAddon.frame = AceAddon.frame or CreateFrame("Frame", "AceAddon30Frame") -- Our very own frame
+AceAddon.addons = AceAddon.addons or {} -- addons in general
+AceAddon.statuses = AceAddon.statuses or {} -- statuses of addon.
+AceAddon.initializequeue = AceAddon.initializequeue or {} -- addons that are new and not initialized
+AceAddon.enablequeue = AceAddon.enablequeue or {} -- addons that are initialized and waiting to be enabled
+AceAddon.embeds = AceAddon.embeds or setmetatable({}, {__index = function(tbl, key) tbl[key] = {} return tbl[key] end }) -- contains a list of libraries embedded in an addon
+
+-- Lua APIs
+local tinsert, tconcat, tremove = table.insert, table.concat, table.remove
+local fmt, tostring = string.format, tostring
+local select, pairs, next, type, unpack = select, pairs, next, type, unpack
+local loadstring, assert, error = loadstring, assert, error
+local setmetatable, getmetatable, rawset, rawget = setmetatable, getmetatable, rawset, rawget
+
+--[[
+	 xpcall safecall implementation
+]]
+local xpcall = xpcall
+
+local function errorhandler(err)
+	return geterrorhandler()(err)
+end
+
+local function safecall(func, ...)
+	-- we check to see if the func is passed is actually a function here and don't error when it isn't
+	-- this safecall is used for optional functions like OnInitialize OnEnable etc. When they are not
+	-- present execution should continue without hinderance
+	if type(func) == "function" then
+		return xpcall(func, errorhandler, ...)
+	end
+end
+
+-- local functions that will be implemented further down
+local Enable, Disable, EnableModule, DisableModule, Embed, NewModule, GetModule, GetName, SetDefaultModuleState, SetDefaultModuleLibraries, SetEnabledState, SetDefaultModulePrototype
+
+-- used in the addon metatable
+local function addontostring( self ) return self.name end
+
+-- Check if the addon is queued for initialization
+local function queuedForInitialization(addon)
+	for i = 1, #AceAddon.initializequeue do
+		if AceAddon.initializequeue[i] == addon then
+			return true
+		end
+	end
+	return false
+end
+
+--- Create a new AceAddon-3.0 addon.
+-- Any libraries you specified will be embeded, and the addon will be scheduled for
+-- its OnInitialize and OnEnable callbacks.
+-- The final addon object, with all libraries embeded, will be returned.
+-- @paramsig [object ,]name[, lib, ...]
+-- @param object Table to use as a base for the addon (optional)
+-- @param name Name of the addon object to create
+-- @param lib List of libraries to embed into the addon
+-- @usage
+-- -- Create a simple addon object
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceEvent-3.0")
+--
+-- -- Create a Addon object based on the table of a frame
+-- local MyFrame = CreateFrame("Frame")
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon(MyFrame, "MyAddon", "AceEvent-3.0")
+function AceAddon:NewAddon(objectorname, ...)
+	local object,name
+	local i=1
+	if type(objectorname)=="table" then
+		object=objectorname
+		name=...
+		i=2
+	else
+		name=objectorname
+	end
+	if type(name)~="string" then
+		error(("Usage: NewAddon([object,] name, [lib, lib, lib, ...]): 'name' - string expected got '%s'."):format(type(name)), 2)
+	end
+	if self.addons[name] then
+		error(("Usage: NewAddon([object,] name, [lib, lib, lib, ...]): 'name' - Addon '%s' already exists."):format(name), 2)
+	end
+
+	object = object or {}
+	object.name = name
+
+	local addonmeta = {}
+	local oldmeta = getmetatable(object)
+	if oldmeta then
+		for k, v in pairs(oldmeta) do addonmeta[k] = v end
+	end
+	addonmeta.__tostring = addontostring
+
+	setmetatable( object, addonmeta )
+	self.addons[name] = object
+	object.modules = {}
+	object.orderedModules = {}
+	object.defaultModuleLibraries = {}
+	Embed( object ) -- embed NewModule, GetModule methods
+	self:EmbedLibraries(object, select(i,...))
+
+	-- add to queue of addons to be initialized upon ADDON_LOADED
+	tinsert(self.initializequeue, object)
+	return object
+end
+
+
+--- Get the addon object by its name from the internal AceAddon registry.
+-- Throws an error if the addon object cannot be found (except if silent is set).
+-- @param name unique name of the addon object
+-- @param silent if true, the addon is optional, silently return nil if its not found
+-- @usage
+-- -- Get the Addon
+-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
+function AceAddon:GetAddon(name, silent)
+	if not silent and not self.addons[name] then
+		error(("Usage: GetAddon(name): 'name' - Cannot find an AceAddon '%s'."):format(tostring(name)), 2)
+	end
+	return self.addons[name]
+end
+
+-- - Embed a list of libraries into the specified addon.
+-- This function will try to embed all of the listed libraries into the addon
+-- and error if a single one fails.
+--
+-- **Note:** This function is for internal use by :NewAddon/:NewModule
+-- @paramsig addon, [lib, ...]
+-- @param addon addon object to embed the libs in
+-- @param lib List of libraries to embed into the addon
+function AceAddon:EmbedLibraries(addon, ...)
+	for i=1,select("#", ... ) do
+		local libname = select(i, ...)
+		self:EmbedLibrary(addon, libname, false, 4)
+	end
+end
+
+-- - Embed a library into the addon object.
+-- This function will check if the specified library is registered with LibStub
+-- and if it has a :Embed function to call. It'll error if any of those conditions
+-- fails.
+--
+-- **Note:** This function is for internal use by :EmbedLibraries
+-- @paramsig addon, libname[, silent[, offset]]
+-- @param addon addon object to embed the library in
+-- @param libname name of the library to embed
+-- @param silent marks an embed to fail silently if the library doesn't exist (optional)
+-- @param offset will push the error messages back to said offset, defaults to 2 (optional)
+function AceAddon:EmbedLibrary(addon, libname, silent, offset)
+	local lib = LibStub:GetLibrary(libname, true)
+	if not lib and not silent then
+		error(("Usage: EmbedLibrary(addon, libname, silent, offset): 'libname' - Cannot find a library instance of %q."):format(tostring(libname)), offset or 2)
+	elseif lib and type(lib.Embed) == "function" then
+		lib:Embed(addon)
+		tinsert(self.embeds[addon], libname)
+		return true
+	elseif lib then
+		error(("Usage: EmbedLibrary(addon, libname, silent, offset): 'libname' - Library '%s' is not Embed capable"):format(libname), offset or 2)
+	end
+end
+
+--- Return the specified module from an addon object.
+-- Throws an error if the addon object cannot be found (except if silent is set)
+-- @name //addon//:GetModule
+-- @paramsig name[, silent]
+-- @param name unique name of the module
+-- @param silent if true, the module is optional, silently return nil if its not found (optional)
+-- @usage
+-- -- Get the Addon
+-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
+-- -- Get the Module
+-- MyModule = MyAddon:GetModule("MyModule")
+function GetModule(self, name, silent)
+	if not self.modules[name] and not silent then
+		error(("Usage: GetModule(name, silent): 'name' - Cannot find module '%s'."):format(tostring(name)), 2)
+	end
+	return self.modules[name]
+end
+
+local function IsModuleTrue(self) return true end
+
+--- Create a new module for the addon.
+-- The new module can have its own embeded libraries and/or use a module prototype to be mixed into the module.\\
+-- A module has the same functionality as a real addon, it can have modules of its own, and has the same API as
+-- an addon object.
+-- @name //addon//:NewModule
+-- @paramsig name[, prototype|lib[, lib, ...]]
+-- @param name unique name of the module
+-- @param prototype object to derive this module from, methods and values from this table will be mixed into the module (optional)
+-- @param lib List of libraries to embed into the addon
+-- @usage
+-- -- Create a module with some embeded libraries
+-- MyModule = MyAddon:NewModule("MyModule", "AceEvent-3.0", "AceHook-3.0")
+--
+-- -- Create a module with a prototype
+-- local prototype = { OnEnable = function(self) print("OnEnable called!") end }
+-- MyModule = MyAddon:NewModule("MyModule", prototype, "AceEvent-3.0", "AceHook-3.0")
+function NewModule(self, name, prototype, ...)
+	if type(name) ~= "string" then error(("Usage: NewModule(name, [prototype, [lib, lib, lib, ...]): 'name' - string expected got '%s'."):format(type(name)), 2) end
+	if type(prototype) ~= "string" and type(prototype) ~= "table" and type(prototype) ~= "nil" then error(("Usage: NewModule(name, [prototype, [lib, lib, lib, ...]): 'prototype' - table (prototype), string (lib) or nil expected got '%s'."):format(type(prototype)), 2) end
+
+	if self.modules[name] then error(("Usage: NewModule(name, [prototype, [lib, lib, lib, ...]): 'name' - Module '%s' already exists."):format(name), 2) end
+
+	-- modules are basically addons. We treat them as such. They will be added to the initializequeue properly as well.
+	-- NewModule can only be called after the parent addon is present thus the modules will be initialized after their parent is.
+	local module = AceAddon:NewAddon(fmt("%s_%s", self.name or tostring(self), name))
+
+	module.IsModule = IsModuleTrue
+	module:SetEnabledState(self.defaultModuleState)
+	module.moduleName = name
+
+	if type(prototype) == "string" then
+		AceAddon:EmbedLibraries(module, prototype, ...)
+	else
+		AceAddon:EmbedLibraries(module, ...)
+	end
+	AceAddon:EmbedLibraries(module, unpack(self.defaultModuleLibraries))
+
+	if not prototype or type(prototype) == "string" then
+		prototype = self.defaultModulePrototype or nil
+	end
+
+	if type(prototype) == "table" then
+		local mt = getmetatable(module)
+		mt.__index = prototype
+		setmetatable(module, mt)  -- More of a Base class type feel.
+	end
+
+	safecall(self.OnModuleCreated, self, module) -- Was in Ace2 and I think it could be a cool thing to have handy.
+	self.modules[name] = module
+	tinsert(self.orderedModules, module)
+
+	return module
+end
+
+--- Returns the real name of the addon or module, without any prefix.
+-- @name //addon//:GetName
+-- @paramsig
+-- @usage
+-- print(MyAddon:GetName())
+-- -- prints "MyAddon"
+function GetName(self)
+	return self.moduleName or self.name
+end
+
+--- Enables the Addon, if possible, return true or false depending on success.
+-- This internally calls AceAddon:EnableAddon(), thus dispatching a OnEnable callback
+-- and enabling all modules of the addon (unless explicitly disabled).\\
+-- :Enable() also sets the internal `enableState` variable to true
+-- @name //addon//:Enable
+-- @paramsig
+-- @usage
+-- -- Enable MyModule
+-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
+-- MyModule = MyAddon:GetModule("MyModule")
+-- MyModule:Enable()
+function Enable(self)
+	self:SetEnabledState(true)
+
+	-- nevcairiel 2013-04-27: don't enable an addon/module if its queued for init still
+	-- it'll be enabled after the init process
+	if not queuedForInitialization(self) then
+		return AceAddon:EnableAddon(self)
+	end
+end
+
+--- Disables the Addon, if possible, return true or false depending on success.
+-- This internally calls AceAddon:DisableAddon(), thus dispatching a OnDisable callback
+-- and disabling all modules of the addon.\\
+-- :Disable() also sets the internal `enableState` variable to false
+-- @name //addon//:Disable
+-- @paramsig
+-- @usage
+-- -- Disable MyAddon
+-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
+-- MyAddon:Disable()
+function Disable(self)
+	self:SetEnabledState(false)
+	return AceAddon:DisableAddon(self)
+end
+
+--- Enables the Module, if possible, return true or false depending on success.
+-- Short-hand function that retrieves the module via `:GetModule` and calls `:Enable` on the module object.
+-- @name //addon//:EnableModule
+-- @paramsig name
+-- @usage
+-- -- Enable MyModule using :GetModule
+-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
+-- MyModule = MyAddon:GetModule("MyModule")
+-- MyModule:Enable()
+--
+-- -- Enable MyModule using the short-hand
+-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
+-- MyAddon:EnableModule("MyModule")
+function EnableModule(self, name)
+	local module = self:GetModule( name )
+	return module:Enable()
+end
+
+--- Disables the Module, if possible, return true or false depending on success.
+-- Short-hand function that retrieves the module via `:GetModule` and calls `:Disable` on the module object.
+-- @name //addon//:DisableModule
+-- @paramsig name
+-- @usage
+-- -- Disable MyModule using :GetModule
+-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
+-- MyModule = MyAddon:GetModule("MyModule")
+-- MyModule:Disable()
+--
+-- -- Disable MyModule using the short-hand
+-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
+-- MyAddon:DisableModule("MyModule")
+function DisableModule(self, name)
+	local module = self:GetModule( name )
+	return module:Disable()
+end
+
+--- Set the default libraries to be mixed into all modules created by this object.
+-- Note that you can only change the default module libraries before any module is created.
+-- @name //addon//:SetDefaultModuleLibraries
+-- @paramsig lib[, lib, ...]
+-- @param lib List of libraries to embed into the addon
+-- @usage
+-- -- Create the addon object
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon")
+-- -- Configure default libraries for modules (all modules need AceEvent-3.0)
+-- MyAddon:SetDefaultModuleLibraries("AceEvent-3.0")
+-- -- Create a module
+-- MyModule = MyAddon:NewModule("MyModule")
+function SetDefaultModuleLibraries(self, ...)
+	if next(self.modules) then
+		error("Usage: SetDefaultModuleLibraries(...): cannot change the module defaults after a module has been registered.", 2)
+	end
+	self.defaultModuleLibraries = {...}
+end
+
+--- Set the default state in which new modules are being created.
+-- Note that you can only change the default state before any module is created.
+-- @name //addon//:SetDefaultModuleState
+-- @paramsig state
+-- @param state Default state for new modules, true for enabled, false for disabled
+-- @usage
+-- -- Create the addon object
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon")
+-- -- Set the default state to "disabled"
+-- MyAddon:SetDefaultModuleState(false)
+-- -- Create a module and explicilty enable it
+-- MyModule = MyAddon:NewModule("MyModule")
+-- MyModule:Enable()
+function SetDefaultModuleState(self, state)
+	if next(self.modules) then
+		error("Usage: SetDefaultModuleState(state): cannot change the module defaults after a module has been registered.", 2)
+	end
+	self.defaultModuleState = state
+end
+
+--- Set the default prototype to use for new modules on creation.
+-- Note that you can only change the default prototype before any module is created.
+-- @name //addon//:SetDefaultModulePrototype
+-- @paramsig prototype
+-- @param prototype Default prototype for the new modules (table)
+-- @usage
+-- -- Define a prototype
+-- local prototype = { OnEnable = function(self) print("OnEnable called!") end }
+-- -- Set the default prototype
+-- MyAddon:SetDefaultModulePrototype(prototype)
+-- -- Create a module and explicitly Enable it
+-- MyModule = MyAddon:NewModule("MyModule")
+-- MyModule:Enable()
+-- -- should print "OnEnable called!" now
+-- @see NewModule
+function SetDefaultModulePrototype(self, prototype)
+	if next(self.modules) then
+		error("Usage: SetDefaultModulePrototype(prototype): cannot change the module defaults after a module has been registered.", 2)
+	end
+	if type(prototype) ~= "table" then
+		error(("Usage: SetDefaultModulePrototype(prototype): 'prototype' - table expected got '%s'."):format(type(prototype)), 2)
+	end
+	self.defaultModulePrototype = prototype
+end
+
+--- Set the state of an addon or module
+-- This should only be called before any enabling actually happend, e.g. in/before OnInitialize.
+-- @name //addon//:SetEnabledState
+-- @paramsig state
+-- @param state the state of an addon or module  (enabled=true, disabled=false)
+function SetEnabledState(self, state)
+	self.enabledState = state
+end
+
+
+--- Return an iterator of all modules associated to the addon.
+-- @name //addon//:IterateModules
+-- @paramsig
+-- @usage
+-- -- Enable all modules
+-- for name, module in MyAddon:IterateModules() do
+--    module:Enable()
+-- end
+local function IterateModules(self) return pairs(self.modules) end
+
+-- Returns an iterator of all embeds in the addon
+-- @name //addon//:IterateEmbeds
+-- @paramsig
+local function IterateEmbeds(self) return pairs(AceAddon.embeds[self]) end
+
+--- Query the enabledState of an addon.
+-- @name //addon//:IsEnabled
+-- @paramsig
+-- @usage
+-- if MyAddon:IsEnabled() then
+--     MyAddon:Disable()
+-- end
+local function IsEnabled(self) return self.enabledState end
+local mixins = {
+	NewModule = NewModule,
+	GetModule = GetModule,
+	Enable = Enable,
+	Disable = Disable,
+	EnableModule = EnableModule,
+	DisableModule = DisableModule,
+	IsEnabled = IsEnabled,
+	SetDefaultModuleLibraries = SetDefaultModuleLibraries,
+	SetDefaultModuleState = SetDefaultModuleState,
+	SetDefaultModulePrototype = SetDefaultModulePrototype,
+	SetEnabledState = SetEnabledState,
+	IterateModules = IterateModules,
+	IterateEmbeds = IterateEmbeds,
+	GetName = GetName,
+}
+local function IsModule(self) return false end
+local pmixins = {
+	defaultModuleState = true,
+	enabledState = true,
+	IsModule = IsModule,
+}
+-- Embed( target )
+-- target (object) - target object to embed aceaddon in
+--
+-- this is a local function specifically since it's meant to be only called internally
+function Embed(target, skipPMixins)
+	for k, v in pairs(mixins) do
+		target[k] = v
+	end
+	if not skipPMixins then
+		for k, v in pairs(pmixins) do
+			target[k] = target[k] or v
+		end
+	end
+end
+
+
+-- - Initialize the addon after creation.
+-- This function is only used internally during the ADDON_LOADED event
+-- It will call the **OnInitialize** function on the addon object (if present),
+-- and the **OnEmbedInitialize** function on all embeded libraries.
+--
+-- **Note:** Do not call this function manually, unless you're absolutely sure that you know what you are doing.
+-- @param addon addon object to intialize
+function AceAddon:InitializeAddon(addon)
+	safecall(addon.OnInitialize, addon)
+
+	local embeds = self.embeds[addon]
+	for i = 1, #embeds do
+		local lib = LibStub:GetLibrary(embeds[i], true)
+		if lib then safecall(lib.OnEmbedInitialize, lib, addon) end
+	end
+
+	-- we don't call InitializeAddon on modules specifically, this is handled
+	-- from the event handler and only done _once_
+end
+
+-- - Enable the addon after creation.
+-- Note: This function is only used internally during the PLAYER_LOGIN event, or during ADDON_LOADED,
+-- if IsLoggedIn() already returns true at that point, e.g. for LoD Addons.
+-- It will call the **OnEnable** function on the addon object (if present),
+-- and the **OnEmbedEnable** function on all embeded libraries.\\
+-- This function does not toggle the enable state of the addon itself, and will return early if the addon is disabled.
+--
+-- **Note:** Do not call this function manually, unless you're absolutely sure that you know what you are doing.
+-- Use :Enable on the addon itself instead.
+-- @param addon addon object to enable
+function AceAddon:EnableAddon(addon)
+	if type(addon) == "string" then addon = AceAddon:GetAddon(addon) end
+	if self.statuses[addon.name] or not addon.enabledState then return false end
+
+	-- set the statuses first, before calling the OnEnable. this allows for Disabling of the addon in OnEnable.
+	self.statuses[addon.name] = true
+
+	safecall(addon.OnEnable, addon)
+
+	-- make sure we're still enabled before continueing
+	if self.statuses[addon.name] then
+		local embeds = self.embeds[addon]
+		for i = 1, #embeds do
+			local lib = LibStub:GetLibrary(embeds[i], true)
+			if lib then safecall(lib.OnEmbedEnable, lib, addon) end
+		end
+
+		-- enable possible modules.
+		local modules = addon.orderedModules
+		for i = 1, #modules do
+			self:EnableAddon(modules[i])
+		end
+	end
+	return self.statuses[addon.name] -- return true if we're disabled
+end
+
+-- - Disable the addon
+-- Note: This function is only used internally.
+-- It will call the **OnDisable** function on the addon object (if present),
+-- and the **OnEmbedDisable** function on all embeded libraries.\\
+-- This function does not toggle the enable state of the addon itself, and will return early if the addon is still enabled.
+--
+-- **Note:** Do not call this function manually, unless you're absolutely sure that you know what you are doing.
+-- Use :Disable on the addon itself instead.
+-- @param addon addon object to enable
+function AceAddon:DisableAddon(addon)
+	if type(addon) == "string" then addon = AceAddon:GetAddon(addon) end
+	if not self.statuses[addon.name] then return false end
+
+	-- set statuses first before calling OnDisable, this allows for aborting the disable in OnDisable.
+	self.statuses[addon.name] = false
+
+	safecall( addon.OnDisable, addon )
+
+	-- make sure we're still disabling...
+	if not self.statuses[addon.name] then
+		local embeds = self.embeds[addon]
+		for i = 1, #embeds do
+			local lib = LibStub:GetLibrary(embeds[i], true)
+			if lib then safecall(lib.OnEmbedDisable, lib, addon) end
+		end
+		-- disable possible modules.
+		local modules = addon.orderedModules
+		for i = 1, #modules do
+			self:DisableAddon(modules[i])
+		end
+	end
+
+	return not self.statuses[addon.name] -- return true if we're disabled
+end
+
+--- Get an iterator over all registered addons.
+-- @usage
+-- -- Print a list of all installed AceAddon's
+-- for name, addon in AceAddon:IterateAddons() do
+--   print("Addon: " .. name)
+-- end
+function AceAddon:IterateAddons() return pairs(self.addons) end
+
+--- Get an iterator over the internal status registry.
+-- @usage
+-- -- Print a list of all enabled addons
+-- for name, status in AceAddon:IterateAddonStatus() do
+--   if status then
+--     print("EnabledAddon: " .. name)
+--   end
+-- end
+function AceAddon:IterateAddonStatus() return pairs(self.statuses) end
+
+-- Following Iterators are deprecated, and their addon specific versions should be used
+-- e.g. addon:IterateEmbeds() instead of :IterateEmbedsOnAddon(addon)
+function AceAddon:IterateEmbedsOnAddon(addon) return pairs(self.embeds[addon]) end
+function AceAddon:IterateModulesOfAddon(addon) return pairs(addon.modules) end
+
+-- Blizzard AddOns which can load very early in the loading process and mess with Ace3 addon loading
+local BlizzardEarlyLoadAddons = {
+	Blizzard_DebugTools = true,
+	Blizzard_TimeManager = true,
+	Blizzard_BattlefieldMap = true,
+	Blizzard_MapCanvas = true,
+	Blizzard_SharedMapDataProviders = true,
+	Blizzard_CombatLog = true,
+}
+
+-- Event Handling
+local function onEvent(this, event, arg1)
+	-- 2020-08-28 nevcairiel - ignore the load event of Blizzard addons which occur early in the loading process
+	if (event == "ADDON_LOADED"  and (arg1 == nil or not BlizzardEarlyLoadAddons[arg1])) or event == "PLAYER_LOGIN" then
+		-- if a addon loads another addon, recursion could happen here, so we need to validate the table on every iteration
+		while(#AceAddon.initializequeue > 0) do
+			local addon = tremove(AceAddon.initializequeue, 1)
+			-- this might be an issue with recursion - TODO: validate
+			if event == "ADDON_LOADED" then addon.baseName = arg1 end
+			AceAddon:InitializeAddon(addon)
+			tinsert(AceAddon.enablequeue, addon)
+		end
+
+		if IsLoggedIn() then
+			while(#AceAddon.enablequeue > 0) do
+				local addon = tremove(AceAddon.enablequeue, 1)
+				AceAddon:EnableAddon(addon)
+			end
+		end
+	end
+end
+
+AceAddon.frame:RegisterEvent("ADDON_LOADED")
+AceAddon.frame:RegisterEvent("PLAYER_LOGIN")
+AceAddon.frame:SetScript("OnEvent", onEvent)
+
+-- upgrade embeded
+for name, addon in pairs(AceAddon.addons) do
+	Embed(addon, true)
+end
+
+-- 2010-10-27 nevcairiel - add new "orderedModules" table
+if oldminor and oldminor < 10 then
+	for name, addon in pairs(AceAddon.addons) do
+		addon.orderedModules = {}
+		for module_name, module in pairs(addon.modules) do
+			tinsert(addon.orderedModules, module)
+		end
+	end
+end
diff --git a/Carbonite/Libs/AceAddon-3.0/AceAddon-3.0.xml b/Carbonite/Libs/AceAddon-3.0/AceAddon-3.0.xml
index c607008..dcf24c7 100644
--- a/Carbonite/Libs/AceAddon-3.0/AceAddon-3.0.xml
+++ b/Carbonite/Libs/AceAddon-3.0/AceAddon-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceAddon-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceAddon-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceBucket-3.0/AceBucket-3.0.lua b/Carbonite/Libs/AceBucket-3.0/AceBucket-3.0.lua
index 694fa33..cff6ac0 100644
--- a/Carbonite/Libs/AceBucket-3.0/AceBucket-3.0.lua
+++ b/Carbonite/Libs/AceBucket-3.0/AceBucket-3.0.lua
@@ -1,260 +1,260 @@
---- A bucket to catch events in. **AceBucket-3.0** provides throttling of events that fire in bursts and
--- your addon only needs to know about the full burst.
---
--- This Bucket implementation works as follows:\\
---   Initially, no schedule is running, and its waiting for the first event to happen.\\
---   The first event will start the bucket, and get the scheduler running, which will collect all
---   events in the given interval. When that interval is reached, the bucket is pushed to the
---   callback and a new schedule is started. When a bucket is empty after its interval, the scheduler is
---   stopped, and the bucket is only listening for the next event to happen, basically back in its initial state.
---
--- In addition, the buckets collect information about the "arg1" argument of the events that fire, and pass those as a
--- table to your callback. This functionality was mostly designed for the UNIT_* events.\\
--- The table will have the different values of "arg1" as keys, and the number of occurances as their value, e.g.\\
---   { ["player"] = 2, ["target"] = 1, ["party1"] = 1 }
---
--- **AceBucket-3.0** can be embeded into your addon, either explicitly by calling AceBucket:Embed(MyAddon) or by
--- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
--- and can be accessed directly, without having to explicitly call AceBucket itself.\\
--- It is recommended to embed AceBucket, otherwise you'll have to specify a custom `self` on all calls you
--- make into AceBucket.
--- @usage
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("BucketExample", "AceBucket-3.0")
---
--- function MyAddon:OnEnable()
---   -- Register a bucket that listens to all the HP related events,
---   -- and fires once per second
---   self:RegisterBucketEvent({"UNIT_HEALTH", "UNIT_MAXHEALTH"}, 1, "UpdateHealth")
--- end
---
--- function MyAddon:UpdateHealth(units)
---   if units.player then
---     print("Your HP changed!")
---   end
--- end
--- @class file
--- @name AceBucket-3.0.lua
--- @release $Id: AceBucket-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
-
-local MAJOR, MINOR = "AceBucket-3.0", 4
-local AceBucket, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceBucket then return end -- No Upgrade needed
-
-AceBucket.buckets = AceBucket.buckets or {}
-AceBucket.embeds = AceBucket.embeds or {}
-
--- the libraries will be lazyly bound later, to avoid errors due to loading order issues
-local AceEvent, AceTimer
-
--- Lua APIs
-local tconcat = table.concat
-local type, next, pairs, select = type, next, pairs, select
-local tonumber, tostring, rawset = tonumber, tostring, rawset
-local assert, loadstring, error = assert, loadstring, error
-
-local bucketCache = setmetatable({}, {__mode='k'})
-
---[[
-	 xpcall safecall implementation
-]]
-local xpcall = xpcall
-
-local function errorhandler(err)
-	return geterrorhandler()(err)
-end
-
-local function safecall(func, ...)
-	if func then
-		return xpcall(func, errorhandler, ...)
-	end
-end
-
--- FireBucket ( bucket )
---
--- send the bucket to the callback function and schedule the next FireBucket in interval seconds
-local function FireBucket(bucket)
-	local received = bucket.received
-
-	-- we dont want to fire empty buckets
-	if next(received) ~= nil then
-		local callback = bucket.callback
-		if type(callback) == "string" then
-			safecall(bucket.object[callback], bucket.object, received)
-		else
-			safecall(callback, received)
-		end
-
-		for k in pairs(received) do
-			received[k] = nil
-		end
-
-		-- if the bucket was not empty, schedule another FireBucket in interval seconds
-		bucket.timer = AceTimer.ScheduleTimer(bucket, FireBucket, bucket.interval, bucket)
-	else -- if it was empty, clear the timer and wait for the next event
-		bucket.timer = nil
-	end
-end
-
--- BucketHandler ( event, arg1 )
---
--- callback func for AceEvent
--- stores arg1 in the received table, and schedules the bucket if necessary
-local function BucketHandler(self, event, arg1)
-	if arg1 == nil then
-		arg1 = "nil"
-	end
-
-	self.received[arg1] = (self.received[arg1] or 0) + 1
-
-	-- if we are not scheduled yet, start a timer on the interval for our bucket to be cleared
-	if not self.timer then
-		self.timer = AceTimer.ScheduleTimer(self, FireBucket, self.interval, self)
-	end
-end
-
--- RegisterBucket( event, interval, callback, isMessage )
---
--- event(string or table) - the event, or a table with the events, that this bucket listens to
--- interval(int) - time between bucket fireings
--- callback(func or string) - function pointer, or method name of the object, that gets called when the bucket is cleared
--- isMessage(boolean) - register AceEvent Messages instead of game events
-local function RegisterBucket(self, event, interval, callback, isMessage)
-	-- try to fetch the librarys
-	if not AceEvent or not AceTimer then
-		AceEvent = LibStub:GetLibrary("AceEvent-3.0", true)
-		AceTimer = LibStub:GetLibrary("AceTimer-3.0", true)
-		if not AceEvent or not AceTimer then
-			error(MAJOR .. " requires AceEvent-3.0 and AceTimer-3.0", 3)
-		end
-	end
-
-	if type(event) ~= "string" and type(event) ~= "table" then error("Usage: RegisterBucket(event, interval, callback): 'event' - string or table expected.", 3) end
-	if not callback then
-		if type(event) == "string" then
-			callback = event
-		else
-			error("Usage: RegisterBucket(event, interval, callback): cannot omit callback when event is not a string.", 3)
-		end
-	end
-	if not tonumber(interval) then error("Usage: RegisterBucket(event, interval, callback): 'interval' - number expected.", 3) end
-	if type(callback) ~= "string" and type(callback) ~= "function" then error("Usage: RegisterBucket(event, interval, callback): 'callback' - string or function or nil expected.", 3) end
-	if type(callback) == "string" and type(self[callback]) ~= "function" then error("Usage: RegisterBucket(event, interval, callback): 'callback' - method not found on target object.", 3) end
-
-	local bucket = next(bucketCache)
-	if bucket then
-		bucketCache[bucket] = nil
-	else
-		bucket = { handler = BucketHandler, received = {} }
-	end
-	bucket.object, bucket.callback, bucket.interval = self, callback, tonumber(interval)
-
-	local regFunc = isMessage and AceEvent.RegisterMessage or AceEvent.RegisterEvent
-
-	if type(event) == "table" then
-		for _,e in pairs(event) do
-			regFunc(bucket, e, "handler")
-		end
-	else
-		regFunc(bucket, event, "handler")
-	end
-
-	local handle = tostring(bucket)
-	AceBucket.buckets[handle] = bucket
-
-	return handle
-end
-
---- Register a Bucket for an event (or a set of events)
--- @param event The event to listen for, or a table of events.
--- @param interval The Bucket interval (burst interval)
--- @param callback The callback function, either as a function reference, or a string pointing to a method of the addon object.
--- @return The handle of the bucket (for unregistering)
--- @usage
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceBucket-3.0")
--- MyAddon:RegisterBucketEvent("BAG_UPDATE", 0.2, "UpdateBags")
---
--- function MyAddon:UpdateBags()
---   -- do stuff
--- end
-function AceBucket:RegisterBucketEvent(event, interval, callback)
-	return RegisterBucket(self, event, interval, callback, false)
-end
-
---- Register a Bucket for an AceEvent-3.0 addon message (or a set of messages)
--- @param message The message to listen for, or a table of messages.
--- @param interval The Bucket interval (burst interval)
--- @param callback The callback function, either as a function reference, or a string pointing to a method of the addon object.
--- @return The handle of the bucket (for unregistering)
--- @usage
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceBucket-3.0")
--- MyAddon:RegisterBucketEvent("SomeAddon_InformationMessage", 0.2, "ProcessData")
---
--- function MyAddon:ProcessData()
---   -- do stuff
--- end
-function AceBucket:RegisterBucketMessage(message, interval, callback)
-	return RegisterBucket(self, message, interval, callback, true)
-end
-
---- Unregister any events and messages from the bucket and clear any remaining data.
--- @param handle The handle of the bucket as returned by RegisterBucket*
-function AceBucket:UnregisterBucket(handle)
-	local bucket = AceBucket.buckets[handle]
-	if bucket then
-		AceEvent.UnregisterAllEvents(bucket)
-		AceEvent.UnregisterAllMessages(bucket)
-
-		-- clear any remaining data in the bucket
-		for k in pairs(bucket.received) do
-			bucket.received[k] = nil
-		end
-
-		if bucket.timer then
-			AceTimer.CancelTimer(bucket, bucket.timer)
-			bucket.timer = nil
-		end
-
-		AceBucket.buckets[handle] = nil
-		-- store our bucket in the cache
-		bucketCache[bucket] = true
-	end
-end
-
---- Unregister all buckets of the current addon object (or custom "self").
-function AceBucket:UnregisterAllBuckets()
-	-- hmm can we do this more efficient? (it is not done often so shouldn't matter much)
-	for handle, bucket in pairs(AceBucket.buckets) do
-		if bucket.object == self then
-			AceBucket.UnregisterBucket(self, handle)
-		end
-	end
-end
-
-
-
--- embedding and embed handling
-local mixins = {
-	"RegisterBucketEvent",
-	"RegisterBucketMessage",
-	"UnregisterBucket",
-	"UnregisterAllBuckets",
-}
-
--- Embeds AceBucket into the target object making the functions from the mixins list available on target:..
--- @param target target object to embed AceBucket in
-function AceBucket:Embed( target )
-	for _, v in pairs( mixins ) do
-		target[v] = self[v]
-	end
-	self.embeds[target] = true
-	return target
-end
-
-function AceBucket:OnEmbedDisable( target )
-	target:UnregisterAllBuckets()
-end
-
-for addon in pairs(AceBucket.embeds) do
-	AceBucket:Embed(addon)
-end
+--- A bucket to catch events in. **AceBucket-3.0** provides throttling of events that fire in bursts and
+-- your addon only needs to know about the full burst.
+--
+-- This Bucket implementation works as follows:\\
+--   Initially, no schedule is running, and its waiting for the first event to happen.\\
+--   The first event will start the bucket, and get the scheduler running, which will collect all
+--   events in the given interval. When that interval is reached, the bucket is pushed to the
+--   callback and a new schedule is started. When a bucket is empty after its interval, the scheduler is
+--   stopped, and the bucket is only listening for the next event to happen, basically back in its initial state.
+--
+-- In addition, the buckets collect information about the "arg1" argument of the events that fire, and pass those as a
+-- table to your callback. This functionality was mostly designed for the UNIT_* events.\\
+-- The table will have the different values of "arg1" as keys, and the number of occurances as their value, e.g.\\
+--   { ["player"] = 2, ["target"] = 1, ["party1"] = 1 }
+--
+-- **AceBucket-3.0** can be embeded into your addon, either explicitly by calling AceBucket:Embed(MyAddon) or by
+-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
+-- and can be accessed directly, without having to explicitly call AceBucket itself.\\
+-- It is recommended to embed AceBucket, otherwise you'll have to specify a custom `self` on all calls you
+-- make into AceBucket.
+-- @usage
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("BucketExample", "AceBucket-3.0")
+--
+-- function MyAddon:OnEnable()
+--   -- Register a bucket that listens to all the HP related events,
+--   -- and fires once per second
+--   self:RegisterBucketEvent({"UNIT_HEALTH", "UNIT_MAXHEALTH"}, 1, "UpdateHealth")
+-- end
+--
+-- function MyAddon:UpdateHealth(units)
+--   if units.player then
+--     print("Your HP changed!")
+--   end
+-- end
+-- @class file
+-- @name AceBucket-3.0.lua
+-- @release $Id: AceBucket-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
+
+local MAJOR, MINOR = "AceBucket-3.0", 4
+local AceBucket, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceBucket then return end -- No Upgrade needed
+
+AceBucket.buckets = AceBucket.buckets or {}
+AceBucket.embeds = AceBucket.embeds or {}
+
+-- the libraries will be lazyly bound later, to avoid errors due to loading order issues
+local AceEvent, AceTimer
+
+-- Lua APIs
+local tconcat = table.concat
+local type, next, pairs, select = type, next, pairs, select
+local tonumber, tostring, rawset = tonumber, tostring, rawset
+local assert, loadstring, error = assert, loadstring, error
+
+local bucketCache = setmetatable({}, {__mode='k'})
+
+--[[
+	 xpcall safecall implementation
+]]
+local xpcall = xpcall
+
+local function errorhandler(err)
+	return geterrorhandler()(err)
+end
+
+local function safecall(func, ...)
+	if func then
+		return xpcall(func, errorhandler, ...)
+	end
+end
+
+-- FireBucket ( bucket )
+--
+-- send the bucket to the callback function and schedule the next FireBucket in interval seconds
+local function FireBucket(bucket)
+	local received = bucket.received
+
+	-- we dont want to fire empty buckets
+	if next(received) ~= nil then
+		local callback = bucket.callback
+		if type(callback) == "string" then
+			safecall(bucket.object[callback], bucket.object, received)
+		else
+			safecall(callback, received)
+		end
+
+		for k in pairs(received) do
+			received[k] = nil
+		end
+
+		-- if the bucket was not empty, schedule another FireBucket in interval seconds
+		bucket.timer = AceTimer.ScheduleTimer(bucket, FireBucket, bucket.interval, bucket)
+	else -- if it was empty, clear the timer and wait for the next event
+		bucket.timer = nil
+	end
+end
+
+-- BucketHandler ( event, arg1 )
+--
+-- callback func for AceEvent
+-- stores arg1 in the received table, and schedules the bucket if necessary
+local function BucketHandler(self, event, arg1)
+	if arg1 == nil then
+		arg1 = "nil"
+	end
+
+	self.received[arg1] = (self.received[arg1] or 0) + 1
+
+	-- if we are not scheduled yet, start a timer on the interval for our bucket to be cleared
+	if not self.timer then
+		self.timer = AceTimer.ScheduleTimer(self, FireBucket, self.interval, self)
+	end
+end
+
+-- RegisterBucket( event, interval, callback, isMessage )
+--
+-- event(string or table) - the event, or a table with the events, that this bucket listens to
+-- interval(int) - time between bucket fireings
+-- callback(func or string) - function pointer, or method name of the object, that gets called when the bucket is cleared
+-- isMessage(boolean) - register AceEvent Messages instead of game events
+local function RegisterBucket(self, event, interval, callback, isMessage)
+	-- try to fetch the librarys
+	if not AceEvent or not AceTimer then
+		AceEvent = LibStub:GetLibrary("AceEvent-3.0", true)
+		AceTimer = LibStub:GetLibrary("AceTimer-3.0", true)
+		if not AceEvent or not AceTimer then
+			error(MAJOR .. " requires AceEvent-3.0 and AceTimer-3.0", 3)
+		end
+	end
+
+	if type(event) ~= "string" and type(event) ~= "table" then error("Usage: RegisterBucket(event, interval, callback): 'event' - string or table expected.", 3) end
+	if not callback then
+		if type(event) == "string" then
+			callback = event
+		else
+			error("Usage: RegisterBucket(event, interval, callback): cannot omit callback when event is not a string.", 3)
+		end
+	end
+	if not tonumber(interval) then error("Usage: RegisterBucket(event, interval, callback): 'interval' - number expected.", 3) end
+	if type(callback) ~= "string" and type(callback) ~= "function" then error("Usage: RegisterBucket(event, interval, callback): 'callback' - string or function or nil expected.", 3) end
+	if type(callback) == "string" and type(self[callback]) ~= "function" then error("Usage: RegisterBucket(event, interval, callback): 'callback' - method not found on target object.", 3) end
+
+	local bucket = next(bucketCache)
+	if bucket then
+		bucketCache[bucket] = nil
+	else
+		bucket = { handler = BucketHandler, received = {} }
+	end
+	bucket.object, bucket.callback, bucket.interval = self, callback, tonumber(interval)
+
+	local regFunc = isMessage and AceEvent.RegisterMessage or AceEvent.RegisterEvent
+
+	if type(event) == "table" then
+		for _,e in pairs(event) do
+			regFunc(bucket, e, "handler")
+		end
+	else
+		regFunc(bucket, event, "handler")
+	end
+
+	local handle = tostring(bucket)
+	AceBucket.buckets[handle] = bucket
+
+	return handle
+end
+
+--- Register a Bucket for an event (or a set of events)
+-- @param event The event to listen for, or a table of events.
+-- @param interval The Bucket interval (burst interval)
+-- @param callback The callback function, either as a function reference, or a string pointing to a method of the addon object.
+-- @return The handle of the bucket (for unregistering)
+-- @usage
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceBucket-3.0")
+-- MyAddon:RegisterBucketEvent("BAG_UPDATE", 0.2, "UpdateBags")
+--
+-- function MyAddon:UpdateBags()
+--   -- do stuff
+-- end
+function AceBucket:RegisterBucketEvent(event, interval, callback)
+	return RegisterBucket(self, event, interval, callback, false)
+end
+
+--- Register a Bucket for an AceEvent-3.0 addon message (or a set of messages)
+-- @param message The message to listen for, or a table of messages.
+-- @param interval The Bucket interval (burst interval)
+-- @param callback The callback function, either as a function reference, or a string pointing to a method of the addon object.
+-- @return The handle of the bucket (for unregistering)
+-- @usage
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceBucket-3.0")
+-- MyAddon:RegisterBucketEvent("SomeAddon_InformationMessage", 0.2, "ProcessData")
+--
+-- function MyAddon:ProcessData()
+--   -- do stuff
+-- end
+function AceBucket:RegisterBucketMessage(message, interval, callback)
+	return RegisterBucket(self, message, interval, callback, true)
+end
+
+--- Unregister any events and messages from the bucket and clear any remaining data.
+-- @param handle The handle of the bucket as returned by RegisterBucket*
+function AceBucket:UnregisterBucket(handle)
+	local bucket = AceBucket.buckets[handle]
+	if bucket then
+		AceEvent.UnregisterAllEvents(bucket)
+		AceEvent.UnregisterAllMessages(bucket)
+
+		-- clear any remaining data in the bucket
+		for k in pairs(bucket.received) do
+			bucket.received[k] = nil
+		end
+
+		if bucket.timer then
+			AceTimer.CancelTimer(bucket, bucket.timer)
+			bucket.timer = nil
+		end
+
+		AceBucket.buckets[handle] = nil
+		-- store our bucket in the cache
+		bucketCache[bucket] = true
+	end
+end
+
+--- Unregister all buckets of the current addon object (or custom "self").
+function AceBucket:UnregisterAllBuckets()
+	-- hmm can we do this more efficient? (it is not done often so shouldn't matter much)
+	for handle, bucket in pairs(AceBucket.buckets) do
+		if bucket.object == self then
+			AceBucket.UnregisterBucket(self, handle)
+		end
+	end
+end
+
+
+
+-- embedding and embed handling
+local mixins = {
+	"RegisterBucketEvent",
+	"RegisterBucketMessage",
+	"UnregisterBucket",
+	"UnregisterAllBuckets",
+}
+
+-- Embeds AceBucket into the target object making the functions from the mixins list available on target:..
+-- @param target target object to embed AceBucket in
+function AceBucket:Embed( target )
+	for _, v in pairs( mixins ) do
+		target[v] = self[v]
+	end
+	self.embeds[target] = true
+	return target
+end
+
+function AceBucket:OnEmbedDisable( target )
+	target:UnregisterAllBuckets()
+end
+
+for addon in pairs(AceBucket.embeds) do
+	AceBucket:Embed(addon)
+end
diff --git a/Carbonite/Libs/AceBucket-3.0/AceBucket-3.0.xml b/Carbonite/Libs/AceBucket-3.0/AceBucket-3.0.xml
index bbda349..06ab712 100644
--- a/Carbonite/Libs/AceBucket-3.0/AceBucket-3.0.xml
+++ b/Carbonite/Libs/AceBucket-3.0/AceBucket-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceBucket-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceBucket-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceComm-3.0/AceComm-3.0.lua b/Carbonite/Libs/AceComm-3.0/AceComm-3.0.lua
index a4d5896..1fc7a37 100644
--- a/Carbonite/Libs/AceComm-3.0/AceComm-3.0.lua
+++ b/Carbonite/Libs/AceComm-3.0/AceComm-3.0.lua
@@ -1,301 +1,301 @@
---- **AceComm-3.0** allows you to send messages of unlimited length over the addon comm channels.
--- It'll automatically split the messages into multiple parts and rebuild them on the receiving end.\\
--- **ChatThrottleLib** is of course being used to avoid being disconnected by the server.
---
--- **AceComm-3.0** can be embeded into your addon, either explicitly by calling AceComm:Embed(MyAddon) or by
--- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
--- and can be accessed directly, without having to explicitly call AceComm itself.\\
--- It is recommended to embed AceComm, otherwise you'll have to specify a custom `self` on all calls you
--- make into AceComm.
--- @class file
--- @name AceComm-3.0
--- @release $Id: AceComm-3.0.lua 1333 2024-05-05 16:24:39Z nevcairiel $
-
---[[ AceComm-3.0
-
-TODO: Time out old data rotting around from dead senders? Not a HUGE deal since the number of possible sender names is somewhat limited.
-
-]]
-
-local CallbackHandler = LibStub("CallbackHandler-1.0")
-local CTL = assert(ChatThrottleLib, "AceComm-3.0 requires ChatThrottleLib")
-
-local MAJOR, MINOR = "AceComm-3.0", 14
-local AceComm,oldminor = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceComm then return end
-
--- Lua APIs
-local type, next, pairs, tostring = type, next, pairs, tostring
-local strsub, strfind = string.sub, string.find
-local match = string.match
-local tinsert, tconcat = table.insert, table.concat
-local error, assert = error, assert
-
--- WoW APIs
-local Ambiguate = Ambiguate
-
-AceComm.embeds = AceComm.embeds or {}
-
--- for my sanity and yours, let's give the message type bytes some names
-local MSG_MULTI_FIRST = "\001"
-local MSG_MULTI_NEXT  = "\002"
-local MSG_MULTI_LAST  = "\003"
-local MSG_ESCAPE = "\004"
-
--- remove old structures (pre WoW 4.0)
-AceComm.multipart_origprefixes = nil
-AceComm.multipart_reassemblers = nil
-
--- the multipart message spool: indexed by a combination of sender+distribution+
-AceComm.multipart_spool = AceComm.multipart_spool or {}
-
---- Register for Addon Traffic on a specified prefix
--- @param prefix A printable character (\032-\255) classification of the message (typically AddonName or AddonNameEvent), max 16 characters
--- @param method Callback to call on message reception: Function reference, or method name (string) to call on self. Defaults to "OnCommReceived"
-function AceComm:RegisterComm(prefix, method)
-	if method == nil then
-		method = "OnCommReceived"
-	end
-
-	if #prefix > 16 then -- TODO: 15?
-		error("AceComm:RegisterComm(prefix,method): prefix length is limited to 16 characters")
-	end
-	if C_ChatInfo then
-		C_ChatInfo.RegisterAddonMessagePrefix(prefix)
-	else
-		RegisterAddonMessagePrefix(prefix)
-	end
-
-	return AceComm._RegisterComm(self, prefix, method)	-- created by CallbackHandler
-end
-
-local warnedPrefix=false
-
---- Send a message over the Addon Channel
--- @param prefix A printable character (\032-\255) classification of the message (typically AddonName or AddonNameEvent)
--- @param text Data to send, nils (\000) not allowed. Any length.
--- @param distribution Addon channel, e.g. "RAID", "GUILD", etc; see SendAddonMessage API
--- @param target Destination for some distributions; see SendAddonMessage API
--- @param prio OPTIONAL: ChatThrottleLib priority, "BULK", "NORMAL" or "ALERT". Defaults to "NORMAL".
--- @param callbackFn OPTIONAL: callback function to be called as each chunk is sent. receives 3 args: the user supplied arg (see next), the number of bytes sent so far, and the number of bytes total to send.
--- @param callbackArg: OPTIONAL: first arg to the callback function. nil will be passed if not specified.
-function AceComm:SendCommMessage(prefix, text, distribution, target, prio, callbackFn, callbackArg)
-	prio = prio or "NORMAL"	-- pasta's reference implementation had different prio for singlepart and multipart, but that's a very bad idea since that can easily lead to out-of-sequence delivery!
-	if not( type(prefix)=="string" and
-			type(text)=="string" and
-			type(distribution)=="string" and
-			(target==nil or type(target)=="string" or type(target)=="number") and
-			(prio=="BULK" or prio=="NORMAL" or prio=="ALERT")
-		) then
-		error('Usage: SendCommMessage(addon, "prefix", "text", "distribution"[, "target"[, "prio"[, callbackFn, callbackarg]]])', 2)
-	end
-
-	local textlen = #text
-	local maxtextlen = 255  -- Yes, the max is 255 even if the dev post said 256. I tested. Char 256+ get silently truncated. /Mikk, 20110327
-	local queueName = prefix
-
-	local ctlCallback = nil
-	if callbackFn then
-		ctlCallback = function(sent, sendResult)
-			return callbackFn(callbackArg, sent, textlen, sendResult)
-		end
-	end
-
-	local forceMultipart
-	if match(text, "^[\001-\009]") then -- 4.1+: see if the first character is a control character
-		-- we need to escape the first character with a \004
-		if textlen+1 > maxtextlen then	-- would we go over the size limit?
-			forceMultipart = true	-- just make it multipart, no escape problems then
-		else
-			text = "\004" .. text
-		end
-	end
-
-	if not forceMultipart and textlen <= maxtextlen then
-		-- fits all in one message
-		CTL:SendAddonMessage(prio, prefix, text, distribution, target, queueName, ctlCallback, textlen)
-	else
-		maxtextlen = maxtextlen - 1	-- 1 extra byte for part indicator in prefix(4.0)/start of message(4.1)
-
-		-- first part
-		local chunk = strsub(text, 1, maxtextlen)
-		CTL:SendAddonMessage(prio, prefix, MSG_MULTI_FIRST..chunk, distribution, target, queueName, ctlCallback, maxtextlen)
-
-		-- continuation
-		local pos = 1+maxtextlen
-
-		while pos+maxtextlen <= textlen do
-			chunk = strsub(text, pos, pos+maxtextlen-1)
-			CTL:SendAddonMessage(prio, prefix, MSG_MULTI_NEXT..chunk, distribution, target, queueName, ctlCallback, pos+maxtextlen-1)
-			pos = pos + maxtextlen
-		end
-
-		-- final part
-		chunk = strsub(text, pos)
-		CTL:SendAddonMessage(prio, prefix, MSG_MULTI_LAST..chunk, distribution, target, queueName, ctlCallback, textlen)
-	end
-end
-
-
-----------------------------------------
--- Message receiving
-----------------------------------------
-
-do
-	local compost = setmetatable({}, {__mode = "k"})
-	local function new()
-		local t = next(compost)
-		if t then
-			compost[t]=nil
-			for i=#t,3,-1 do	-- faster than pairs loop. don't even nil out 1/2 since they'll be overwritten
-				t[i]=nil
-			end
-			return t
-		end
-
-		return {}
-	end
-
-	local function lostdatawarning(prefix,sender,where)
-		DEFAULT_CHAT_FRAME:AddMessage(MAJOR..": Warning: lost network data regarding '"..tostring(prefix).."' from '"..tostring(sender).."' (in "..where..")")
-	end
-
-	function AceComm:OnReceiveMultipartFirst(prefix, message, distribution, sender)
-		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
-		local spool = AceComm.multipart_spool
-
-		--[[
-		if spool[key] then
-			lostdatawarning(prefix,sender,"First")
-			-- continue and overwrite
-		end
-		--]]
-
-		spool[key] = message  -- plain string for now
-	end
-
-	function AceComm:OnReceiveMultipartNext(prefix, message, distribution, sender)
-		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
-		local spool = AceComm.multipart_spool
-		local olddata = spool[key]
-
-		if not olddata then
-			--lostdatawarning(prefix,sender,"Next")
-			return
-		end
-
-		if type(olddata)~="table" then
-			-- ... but what we have is not a table. So make it one. (Pull a composted one if available)
-			local t = new()
-			t[1] = olddata    -- add old data as first string
-			t[2] = message    -- and new message as second string
-			spool[key] = t    -- and put the table in the spool instead of the old string
-		else
-			tinsert(olddata, message)
-		end
-	end
-
-	function AceComm:OnReceiveMultipartLast(prefix, message, distribution, sender)
-		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
-		local spool = AceComm.multipart_spool
-		local olddata = spool[key]
-
-		if not olddata then
-			--lostdatawarning(prefix,sender,"End")
-			return
-		end
-
-		spool[key] = nil
-
-		if type(olddata) == "table" then
-			-- if we've received a "next", the spooled data will be a table for rapid & garbage-free tconcat
-			tinsert(olddata, message)
-			AceComm.callbacks:Fire(prefix, tconcat(olddata, ""), distribution, sender)
-			compost[olddata] = true
-		else
-			-- if we've only received a "first", the spooled data will still only be a string
-			AceComm.callbacks:Fire(prefix, olddata..message, distribution, sender)
-		end
-	end
-end
-
-
-
-
-
-
-----------------------------------------
--- Embed CallbackHandler
-----------------------------------------
-
-if not AceComm.callbacks then
-	AceComm.callbacks = CallbackHandler:New(AceComm,
-						"_RegisterComm",
-						"UnregisterComm",
-						"UnregisterAllComm")
-end
-
-AceComm.callbacks.OnUsed = nil
-AceComm.callbacks.OnUnused = nil
-
-local function OnEvent(self, event, prefix, message, distribution, sender)
-	if event == "CHAT_MSG_ADDON" then
-		sender = Ambiguate(sender, "none")
-		local control, rest = match(message, "^([\001-\009])(.*)")
-		if control then
-			if control==MSG_MULTI_FIRST then
-				AceComm:OnReceiveMultipartFirst(prefix, rest, distribution, sender)
-			elseif control==MSG_MULTI_NEXT then
-				AceComm:OnReceiveMultipartNext(prefix, rest, distribution, sender)
-			elseif control==MSG_MULTI_LAST then
-				AceComm:OnReceiveMultipartLast(prefix, rest, distribution, sender)
-			elseif control==MSG_ESCAPE then
-				AceComm.callbacks:Fire(prefix, rest, distribution, sender)
-			else
-				-- unknown control character, ignore SILENTLY (dont warn unnecessarily about future extensions!)
-			end
-		else
-			-- single part: fire it off immediately and let CallbackHandler decide if it's registered or not
-			AceComm.callbacks:Fire(prefix, message, distribution, sender)
-		end
-	else
-		assert(false, "Received "..tostring(event).." event?!")
-	end
-end
-
-AceComm.frame = AceComm.frame or CreateFrame("Frame", "AceComm30Frame")
-AceComm.frame:SetScript("OnEvent", OnEvent)
-AceComm.frame:UnregisterAllEvents()
-AceComm.frame:RegisterEvent("CHAT_MSG_ADDON")
-
-
-----------------------------------------
--- Base library stuff
-----------------------------------------
-
-local mixins = {
-	"RegisterComm",
-	"UnregisterComm",
-	"UnregisterAllComm",
-	"SendCommMessage",
-}
-
--- Embeds AceComm-3.0 into the target object making the functions from the mixins list available on target:..
--- @param target target object to embed AceComm-3.0 in
-function AceComm:Embed(target)
-	for k, v in pairs(mixins) do
-		target[v] = self[v]
-	end
-	self.embeds[target] = true
-	return target
-end
-
-function AceComm:OnEmbedDisable(target)
-	target:UnregisterAllComm()
-end
-
--- Update embeds
-for target, v in pairs(AceComm.embeds) do
-	AceComm:Embed(target)
-end
+--- **AceComm-3.0** allows you to send messages of unlimited length over the addon comm channels.
+-- It'll automatically split the messages into multiple parts and rebuild them on the receiving end.\\
+-- **ChatThrottleLib** is of course being used to avoid being disconnected by the server.
+--
+-- **AceComm-3.0** can be embeded into your addon, either explicitly by calling AceComm:Embed(MyAddon) or by
+-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
+-- and can be accessed directly, without having to explicitly call AceComm itself.\\
+-- It is recommended to embed AceComm, otherwise you'll have to specify a custom `self` on all calls you
+-- make into AceComm.
+-- @class file
+-- @name AceComm-3.0
+-- @release $Id: AceComm-3.0.lua 1333 2024-05-05 16:24:39Z nevcairiel $
+
+--[[ AceComm-3.0
+
+TODO: Time out old data rotting around from dead senders? Not a HUGE deal since the number of possible sender names is somewhat limited.
+
+]]
+
+local CallbackHandler = LibStub("CallbackHandler-1.0")
+local CTL = assert(ChatThrottleLib, "AceComm-3.0 requires ChatThrottleLib")
+
+local MAJOR, MINOR = "AceComm-3.0", 14
+local AceComm,oldminor = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceComm then return end
+
+-- Lua APIs
+local type, next, pairs, tostring = type, next, pairs, tostring
+local strsub, strfind = string.sub, string.find
+local match = string.match
+local tinsert, tconcat = table.insert, table.concat
+local error, assert = error, assert
+
+-- WoW APIs
+local Ambiguate = Ambiguate
+
+AceComm.embeds = AceComm.embeds or {}
+
+-- for my sanity and yours, let's give the message type bytes some names
+local MSG_MULTI_FIRST = "\001"
+local MSG_MULTI_NEXT  = "\002"
+local MSG_MULTI_LAST  = "\003"
+local MSG_ESCAPE = "\004"
+
+-- remove old structures (pre WoW 4.0)
+AceComm.multipart_origprefixes = nil
+AceComm.multipart_reassemblers = nil
+
+-- the multipart message spool: indexed by a combination of sender+distribution+
+AceComm.multipart_spool = AceComm.multipart_spool or {}
+
+--- Register for Addon Traffic on a specified prefix
+-- @param prefix A printable character (\032-\255) classification of the message (typically AddonName or AddonNameEvent), max 16 characters
+-- @param method Callback to call on message reception: Function reference, or method name (string) to call on self. Defaults to "OnCommReceived"
+function AceComm:RegisterComm(prefix, method)
+	if method == nil then
+		method = "OnCommReceived"
+	end
+
+	if #prefix > 16 then -- TODO: 15?
+		error("AceComm:RegisterComm(prefix,method): prefix length is limited to 16 characters")
+	end
+	if C_ChatInfo then
+		C_ChatInfo.RegisterAddonMessagePrefix(prefix)
+	else
+		RegisterAddonMessagePrefix(prefix)
+	end
+
+	return AceComm._RegisterComm(self, prefix, method)	-- created by CallbackHandler
+end
+
+local warnedPrefix=false
+
+--- Send a message over the Addon Channel
+-- @param prefix A printable character (\032-\255) classification of the message (typically AddonName or AddonNameEvent)
+-- @param text Data to send, nils (\000) not allowed. Any length.
+-- @param distribution Addon channel, e.g. "RAID", "GUILD", etc; see SendAddonMessage API
+-- @param target Destination for some distributions; see SendAddonMessage API
+-- @param prio OPTIONAL: ChatThrottleLib priority, "BULK", "NORMAL" or "ALERT". Defaults to "NORMAL".
+-- @param callbackFn OPTIONAL: callback function to be called as each chunk is sent. receives 3 args: the user supplied arg (see next), the number of bytes sent so far, and the number of bytes total to send.
+-- @param callbackArg: OPTIONAL: first arg to the callback function. nil will be passed if not specified.
+function AceComm:SendCommMessage(prefix, text, distribution, target, prio, callbackFn, callbackArg)
+	prio = prio or "NORMAL"	-- pasta's reference implementation had different prio for singlepart and multipart, but that's a very bad idea since that can easily lead to out-of-sequence delivery!
+	if not( type(prefix)=="string" and
+			type(text)=="string" and
+			type(distribution)=="string" and
+			(target==nil or type(target)=="string" or type(target)=="number") and
+			(prio=="BULK" or prio=="NORMAL" or prio=="ALERT")
+		) then
+		error('Usage: SendCommMessage(addon, "prefix", "text", "distribution"[, "target"[, "prio"[, callbackFn, callbackarg]]])', 2)
+	end
+
+	local textlen = #text
+	local maxtextlen = 255  -- Yes, the max is 255 even if the dev post said 256. I tested. Char 256+ get silently truncated. /Mikk, 20110327
+	local queueName = prefix
+
+	local ctlCallback = nil
+	if callbackFn then
+		ctlCallback = function(sent, sendResult)
+			return callbackFn(callbackArg, sent, textlen, sendResult)
+		end
+	end
+
+	local forceMultipart
+	if match(text, "^[\001-\009]") then -- 4.1+: see if the first character is a control character
+		-- we need to escape the first character with a \004
+		if textlen+1 > maxtextlen then	-- would we go over the size limit?
+			forceMultipart = true	-- just make it multipart, no escape problems then
+		else
+			text = "\004" .. text
+		end
+	end
+
+	if not forceMultipart and textlen <= maxtextlen then
+		-- fits all in one message
+		CTL:SendAddonMessage(prio, prefix, text, distribution, target, queueName, ctlCallback, textlen)
+	else
+		maxtextlen = maxtextlen - 1	-- 1 extra byte for part indicator in prefix(4.0)/start of message(4.1)
+
+		-- first part
+		local chunk = strsub(text, 1, maxtextlen)
+		CTL:SendAddonMessage(prio, prefix, MSG_MULTI_FIRST..chunk, distribution, target, queueName, ctlCallback, maxtextlen)
+
+		-- continuation
+		local pos = 1+maxtextlen
+
+		while pos+maxtextlen <= textlen do
+			chunk = strsub(text, pos, pos+maxtextlen-1)
+			CTL:SendAddonMessage(prio, prefix, MSG_MULTI_NEXT..chunk, distribution, target, queueName, ctlCallback, pos+maxtextlen-1)
+			pos = pos + maxtextlen
+		end
+
+		-- final part
+		chunk = strsub(text, pos)
+		CTL:SendAddonMessage(prio, prefix, MSG_MULTI_LAST..chunk, distribution, target, queueName, ctlCallback, textlen)
+	end
+end
+
+
+----------------------------------------
+-- Message receiving
+----------------------------------------
+
+do
+	local compost = setmetatable({}, {__mode = "k"})
+	local function new()
+		local t = next(compost)
+		if t then
+			compost[t]=nil
+			for i=#t,3,-1 do	-- faster than pairs loop. don't even nil out 1/2 since they'll be overwritten
+				t[i]=nil
+			end
+			return t
+		end
+
+		return {}
+	end
+
+	local function lostdatawarning(prefix,sender,where)
+		DEFAULT_CHAT_FRAME:AddMessage(MAJOR..": Warning: lost network data regarding '"..tostring(prefix).."' from '"..tostring(sender).."' (in "..where..")")
+	end
+
+	function AceComm:OnReceiveMultipartFirst(prefix, message, distribution, sender)
+		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
+		local spool = AceComm.multipart_spool
+
+		--[[
+		if spool[key] then
+			lostdatawarning(prefix,sender,"First")
+			-- continue and overwrite
+		end
+		--]]
+
+		spool[key] = message  -- plain string for now
+	end
+
+	function AceComm:OnReceiveMultipartNext(prefix, message, distribution, sender)
+		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
+		local spool = AceComm.multipart_spool
+		local olddata = spool[key]
+
+		if not olddata then
+			--lostdatawarning(prefix,sender,"Next")
+			return
+		end
+
+		if type(olddata)~="table" then
+			-- ... but what we have is not a table. So make it one. (Pull a composted one if available)
+			local t = new()
+			t[1] = olddata    -- add old data as first string
+			t[2] = message    -- and new message as second string
+			spool[key] = t    -- and put the table in the spool instead of the old string
+		else
+			tinsert(olddata, message)
+		end
+	end
+
+	function AceComm:OnReceiveMultipartLast(prefix, message, distribution, sender)
+		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
+		local spool = AceComm.multipart_spool
+		local olddata = spool[key]
+
+		if not olddata then
+			--lostdatawarning(prefix,sender,"End")
+			return
+		end
+
+		spool[key] = nil
+
+		if type(olddata) == "table" then
+			-- if we've received a "next", the spooled data will be a table for rapid & garbage-free tconcat
+			tinsert(olddata, message)
+			AceComm.callbacks:Fire(prefix, tconcat(olddata, ""), distribution, sender)
+			compost[olddata] = true
+		else
+			-- if we've only received a "first", the spooled data will still only be a string
+			AceComm.callbacks:Fire(prefix, olddata..message, distribution, sender)
+		end
+	end
+end
+
+
+
+
+
+
+----------------------------------------
+-- Embed CallbackHandler
+----------------------------------------
+
+if not AceComm.callbacks then
+	AceComm.callbacks = CallbackHandler:New(AceComm,
+						"_RegisterComm",
+						"UnregisterComm",
+						"UnregisterAllComm")
+end
+
+AceComm.callbacks.OnUsed = nil
+AceComm.callbacks.OnUnused = nil
+
+local function OnEvent(self, event, prefix, message, distribution, sender)
+	if event == "CHAT_MSG_ADDON" then
+		sender = Ambiguate(sender, "none")
+		local control, rest = match(message, "^([\001-\009])(.*)")
+		if control then
+			if control==MSG_MULTI_FIRST then
+				AceComm:OnReceiveMultipartFirst(prefix, rest, distribution, sender)
+			elseif control==MSG_MULTI_NEXT then
+				AceComm:OnReceiveMultipartNext(prefix, rest, distribution, sender)
+			elseif control==MSG_MULTI_LAST then
+				AceComm:OnReceiveMultipartLast(prefix, rest, distribution, sender)
+			elseif control==MSG_ESCAPE then
+				AceComm.callbacks:Fire(prefix, rest, distribution, sender)
+			else
+				-- unknown control character, ignore SILENTLY (dont warn unnecessarily about future extensions!)
+			end
+		else
+			-- single part: fire it off immediately and let CallbackHandler decide if it's registered or not
+			AceComm.callbacks:Fire(prefix, message, distribution, sender)
+		end
+	else
+		assert(false, "Received "..tostring(event).." event?!")
+	end
+end
+
+AceComm.frame = AceComm.frame or CreateFrame("Frame", "AceComm30Frame")
+AceComm.frame:SetScript("OnEvent", OnEvent)
+AceComm.frame:UnregisterAllEvents()
+AceComm.frame:RegisterEvent("CHAT_MSG_ADDON")
+
+
+----------------------------------------
+-- Base library stuff
+----------------------------------------
+
+local mixins = {
+	"RegisterComm",
+	"UnregisterComm",
+	"UnregisterAllComm",
+	"SendCommMessage",
+}
+
+-- Embeds AceComm-3.0 into the target object making the functions from the mixins list available on target:..
+-- @param target target object to embed AceComm-3.0 in
+function AceComm:Embed(target)
+	for k, v in pairs(mixins) do
+		target[v] = self[v]
+	end
+	self.embeds[target] = true
+	return target
+end
+
+function AceComm:OnEmbedDisable(target)
+	target:UnregisterAllComm()
+end
+
+-- Update embeds
+for target, v in pairs(AceComm.embeds) do
+	AceComm:Embed(target)
+end
diff --git a/Carbonite/Libs/AceComm-3.0/AceComm-3.0.xml b/Carbonite/Libs/AceComm-3.0/AceComm-3.0.xml
index af066eb..24fb43b 100644
--- a/Carbonite/Libs/AceComm-3.0/AceComm-3.0.xml
+++ b/Carbonite/Libs/AceComm-3.0/AceComm-3.0.xml
@@ -1,5 +1,5 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="ChatThrottleLib.lua"/>
-	<Script file="AceComm-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="ChatThrottleLib.lua"/>
+	<Script file="AceComm-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceComm-3.0/ChatThrottleLib.lua b/Carbonite/Libs/AceComm-3.0/ChatThrottleLib.lua
index 1a73b96..688d318 100644
--- a/Carbonite/Libs/AceComm-3.0/ChatThrottleLib.lua
+++ b/Carbonite/Libs/AceComm-3.0/ChatThrottleLib.lua
@@ -1,688 +1,688 @@
---
--- ChatThrottleLib by Mikk
---
--- Manages AddOn chat output to keep player from getting kicked off.
---
--- ChatThrottleLib:SendChatMessage/:SendAddonMessage functions that accept
--- a Priority ("BULK", "NORMAL", "ALERT") as well as prefix for SendChatMessage.
---
--- Priorities get an equal share of available bandwidth when fully loaded.
--- Communication channels are separated on extension+chattype+destination and
--- get round-robinned. (Destination only matters for whispers and channels,
--- obviously)
---
--- Will install hooks for SendChatMessage and SendAddonMessage to measure
--- bandwidth bypassing the library and use less bandwidth itself.
---
---
--- Fully embeddable library. Just copy this file into your addon directory,
--- add it to the .toc, and it's done.
---
--- Can run as a standalone addon also, but, really, just embed it! :-)
---
--- LICENSE: ChatThrottleLib is released into the Public Domain
---
-
-local CTL_VERSION = 29
-
-local _G = _G
-
-if _G.ChatThrottleLib then
-	if _G.ChatThrottleLib.version >= CTL_VERSION then
-		-- There's already a newer (or same) version loaded. Buh-bye.
-		return
-	elseif not _G.ChatThrottleLib.securelyHooked then
-		print("ChatThrottleLib: Warning: There's an ANCIENT ChatThrottleLib.lua (pre-wow 2.0, <v16) in an addon somewhere. Get the addon updated or copy in a newer ChatThrottleLib.lua (>=v16) in it!")
-		-- ATTEMPT to unhook; this'll behave badly if someone else has hooked...
-		-- ... and if someone has securehooked, they can kiss that goodbye too... >.<
-		_G.SendChatMessage = _G.ChatThrottleLib.ORIG_SendChatMessage
-		if _G.ChatThrottleLib.ORIG_SendAddonMessage then
-			_G.SendAddonMessage = _G.ChatThrottleLib.ORIG_SendAddonMessage
-		end
-	end
-	_G.ChatThrottleLib.ORIG_SendChatMessage = nil
-	_G.ChatThrottleLib.ORIG_SendAddonMessage = nil
-end
-
-if not _G.ChatThrottleLib then
-	_G.ChatThrottleLib = {}
-end
-
-ChatThrottleLib = _G.ChatThrottleLib  -- in case some addon does "local ChatThrottleLib" above us and we're copypasted (AceComm-2, sigh)
-local ChatThrottleLib = _G.ChatThrottleLib
-
-ChatThrottleLib.version = CTL_VERSION
-
-
-
------------------- TWEAKABLES -----------------
-
-ChatThrottleLib.MAX_CPS = 800			  -- 2000 seems to be safe if NOTHING ELSE is happening. let's call it 800.
-ChatThrottleLib.MSG_OVERHEAD = 40		-- Guesstimate overhead for sending a message; source+dest+chattype+protocolstuff
-
-ChatThrottleLib.BURST = 4000				-- WoW's server buffer seems to be about 32KB. 8KB should be safe, but seen disconnects on _some_ servers. Using 4KB now.
-
-ChatThrottleLib.MIN_FPS = 20				-- Reduce output CPS to half (and don't burst) if FPS drops below this value
-
-
-local setmetatable = setmetatable
-local table_remove = table.remove
-local tostring = tostring
-local GetTime = GetTime
-local math_min = math.min
-local math_max = math.max
-local next = next
-local strlen = string.len
-local GetFramerate = GetFramerate
-local unpack,type,pairs,wipe = unpack,type,pairs,table.wipe
-
-
------------------------------------------------------------------------
--- Double-linked ring implementation
-
-local Ring = {}
-local RingMeta = { __index = Ring }
-
-function Ring:New()
-	local ret = {}
-	setmetatable(ret, RingMeta)
-	return ret
-end
-
-function Ring:Add(obj)	-- Append at the "far end" of the ring (aka just before the current position)
-	if self.pos then
-		obj.prev = self.pos.prev
-		obj.prev.next = obj
-		obj.next = self.pos
-		obj.next.prev = obj
-	else
-		obj.next = obj
-		obj.prev = obj
-		self.pos = obj
-	end
-end
-
-function Ring:Remove(obj)
-	obj.next.prev = obj.prev
-	obj.prev.next = obj.next
-	if self.pos == obj then
-		self.pos = obj.next
-		if self.pos == obj then
-			self.pos = nil
-		end
-	end
-end
-
--- Note that this is local because there's no upgrade logic for existing ring
--- metatables, and this isn't present on rings created in versions older than
--- v25.
-local function Ring_Link(self, other)  -- Move and append all contents of another ring to this ring
-	if not self.pos then
-		-- This ring is empty, so just transfer ownership.
-		self.pos = other.pos
-		other.pos = nil
-	elseif other.pos then
-		-- Our tail should point to their head, and their tail to our head.
-		self.pos.prev.next, other.pos.prev.next = other.pos, self.pos
-		-- Our head should point to their tail, and their head to our tail.
-		self.pos.prev, other.pos.prev = other.pos.prev, self.pos.prev
-		other.pos = nil
-	end
-end
-
-
-
------------------------------------------------------------------------
--- Recycling bin for pipes
--- A pipe is a plain integer-indexed queue of messages
--- Pipes normally live in Rings of pipes  (3 rings total, one per priority)
-
-ChatThrottleLib.PipeBin = nil -- pre-v19, drastically different
-local PipeBin = setmetatable({}, {__mode="k"})
-
-local function DelPipe(pipe)
-	PipeBin[pipe] = true
-end
-
-local function NewPipe()
-	local pipe = next(PipeBin)
-	if pipe then
-		wipe(pipe)
-		PipeBin[pipe] = nil
-		return pipe
-	end
-	return {}
-end
-
-
-
-
------------------------------------------------------------------------
--- Recycling bin for messages
-
-ChatThrottleLib.MsgBin = nil -- pre-v19, drastically different
-local MsgBin = setmetatable({}, {__mode="k"})
-
-local function DelMsg(msg)
-	msg[1] = nil
-	-- there's more parameters, but they're very repetetive so the string pool doesn't suffer really, and it's faster to just not delete them.
-	MsgBin[msg] = true
-end
-
-local function NewMsg()
-	local msg = next(MsgBin)
-	if msg then
-		MsgBin[msg] = nil
-		return msg
-	end
-	return {}
-end
-
-
------------------------------------------------------------------------
--- ChatThrottleLib:Init
--- Initialize queues, set up frame for OnUpdate, etc
-
-
-function ChatThrottleLib:Init()
-
-	-- Set up queues
-	if not self.Prio then
-		self.Prio = {}
-		self.Prio["ALERT"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
-		self.Prio["NORMAL"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
-		self.Prio["BULK"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
-	end
-
-	if not self.BlockedQueuesDelay then
-		-- v25: Add blocked queues to rings to handle new client throttles.
-		for _, Prio in pairs(self.Prio) do
-			Prio.Blocked = Ring:New()
-		end
-	end
-
-	-- v4: total send counters per priority
-	for _, Prio in pairs(self.Prio) do
-		Prio.nTotalSent = Prio.nTotalSent or 0
-	end
-
-	if not self.avail then
-		self.avail = 0 -- v5
-	end
-	if not self.nTotalSent then
-		self.nTotalSent = 0 -- v5
-	end
-
-
-	-- Set up a frame to get OnUpdate events
-	if not self.Frame then
-		self.Frame = CreateFrame("Frame")
-		self.Frame:Hide()
-	end
-	self.Frame:SetScript("OnUpdate", self.OnUpdate)
-	self.Frame:SetScript("OnEvent", self.OnEvent)	-- v11: Monitor P_E_W so we can throttle hard for a few seconds
-	self.Frame:RegisterEvent("PLAYER_ENTERING_WORLD")
-	self.OnUpdateDelay = 0
-	self.BlockedQueuesDelay = 0
-	self.LastAvailUpdate = GetTime()
-	self.HardThrottlingBeginTime = GetTime()	-- v11: Throttle hard for a few seconds after startup
-
-	-- Hook SendChatMessage and SendAddonMessage so we can measure unpiped traffic and avoid overloads (v7)
-	if not self.securelyHooked then
-		-- Use secure hooks as of v16. Old regular hook support yanked out in v21.
-		self.securelyHooked = true
-		--SendChatMessage
-		hooksecurefunc("SendChatMessage", function(...)
-			return ChatThrottleLib.Hook_SendChatMessage(...)
-		end)
-		--SendAddonMessage
-		hooksecurefunc(_G.C_ChatInfo, "SendAddonMessage", function(...)
-			return ChatThrottleLib.Hook_SendAddonMessage(...)
-		end)
-	end
-
-	-- v26: Hook SendAddonMessageLogged for traffic logging
-	if not self.securelyHookedLogged then
-		self.securelyHookedLogged = true
-		hooksecurefunc(_G.C_ChatInfo, "SendAddonMessageLogged", function(...)
-			return ChatThrottleLib.Hook_SendAddonMessageLogged(...)
-		end)
-	end
-
-	-- v29: Hook BNSendGameData for traffic logging
-	if not self.securelyHookedBNGameData then
-		self.securelyHookedBNGameData = true
-		hooksecurefunc("BNSendGameData", function(...)
-			return ChatThrottleLib.Hook_BNSendGameData(...)
-		end)
-	end
-
-	self.nBypass = 0
-end
-
-
------------------------------------------------------------------------
--- ChatThrottleLib.Hook_SendChatMessage / .Hook_SendAddonMessage
-
-local bMyTraffic = false
-
-function ChatThrottleLib.Hook_SendChatMessage(text, chattype, language, destination, ...)
-	if bMyTraffic then
-		return
-	end
-	local self = ChatThrottleLib
-	local size = strlen(tostring(text or "")) + strlen(tostring(destination or "")) + self.MSG_OVERHEAD
-	self.avail = self.avail - size
-	self.nBypass = self.nBypass + size	-- just a statistic
-end
-function ChatThrottleLib.Hook_SendAddonMessage(prefix, text, chattype, destination, ...)
-	if bMyTraffic then
-		return
-	end
-	local self = ChatThrottleLib
-	local size = tostring(text or ""):len() + tostring(prefix or ""):len();
-	size = size + tostring(destination or ""):len() + self.MSG_OVERHEAD
-	self.avail = self.avail - size
-	self.nBypass = self.nBypass + size	-- just a statistic
-end
-function ChatThrottleLib.Hook_SendAddonMessageLogged(prefix, text, chattype, destination, ...)
-	ChatThrottleLib.Hook_SendAddonMessage(prefix, text, chattype, destination, ...)
-end
-function ChatThrottleLib.Hook_BNSendGameData(destination, prefix, text)
-	ChatThrottleLib.Hook_SendAddonMessage(prefix, text, "WHISPER", destination)
-end
-
-
-
------------------------------------------------------------------------
--- ChatThrottleLib:UpdateAvail
--- Update self.avail with how much bandwidth is currently available
-
-function ChatThrottleLib:UpdateAvail()
-	local now = GetTime()
-	local MAX_CPS = self.MAX_CPS;
-	local newavail = MAX_CPS * (now - self.LastAvailUpdate)
-	local avail = self.avail
-
-	if now - self.HardThrottlingBeginTime < 5 then
-		-- First 5 seconds after startup/zoning: VERY hard clamping to avoid irritating the server rate limiter, it seems very cranky then
-		avail = math_min(avail + (newavail*0.1), MAX_CPS*0.5)
-		self.bChoking = true
-	elseif GetFramerate() < self.MIN_FPS then		-- GetFrameRate call takes ~0.002 secs
-		avail = math_min(MAX_CPS, avail + newavail*0.5)
-		self.bChoking = true		-- just a statistic
-	else
-		avail = math_min(self.BURST, avail + newavail)
-		self.bChoking = false
-	end
-
-	avail = math_max(avail, 0-(MAX_CPS*2))	-- Can go negative when someone is eating bandwidth past the lib. but we refuse to stay silent for more than 2 seconds; if they can do it, we can.
-
-	self.avail = avail
-	self.LastAvailUpdate = now
-
-	return avail
-end
-
-
------------------------------------------------------------------------
--- Despooling logic
--- Reminder:
--- - We have 3 Priorities, each containing a "Ring" construct ...
--- - ... made up of N "Pipe"s (1 for each destination/pipename)
--- - and each pipe contains messages
-
-local SendAddonMessageResult = Enum.SendAddonMessageResult or {
-	Success = 0,
-	AddonMessageThrottle = 3,
-	NotInGroup = 5,
-	ChannelThrottle = 8,
-	GeneralError = 9,
-}
-
-local function MapToSendResult(ok, ...)
-	local result
-
-	if not ok then
-		-- The send function itself errored; don't look at anything else.
-		result = SendAddonMessageResult.GeneralError
-	else
-		-- Grab the last return value from the send function and remap
-		-- it from a boolean to an enum code. If there are no results,
-		-- assume success (true).
-
-		result = select(-1, true, ...)
-
-		if result == true then
-			result = SendAddonMessageResult.Success
-		elseif result == false then
-			result = SendAddonMessageResult.GeneralError
-		end
-	end
-
-	return result
-end
-
-local function IsThrottledSendResult(result)
-	return result == SendAddonMessageResult.AddonMessageThrottle
-end
-
--- A copy of this function exists in FrameXML, but for clarity it's here too.
-local function CallErrorHandler(...)
-	return geterrorhandler()(...)
-end
-
-local function PerformSend(sendFunction, ...)
-	bMyTraffic = true
-	local sendResult = MapToSendResult(xpcall(sendFunction, CallErrorHandler, ...))
-	bMyTraffic = false
-	return sendResult
-end
-
-function ChatThrottleLib:Despool(Prio)
-	local ring = Prio.Ring
-	while ring.pos and Prio.avail > ring.pos[1].nSize do
-		local pipe = ring.pos
-		local msg = pipe[1]
-		local sendResult = PerformSend(msg.f, unpack(msg, 1, msg.n))
-
-		if IsThrottledSendResult(sendResult) then
-			-- Message was throttled; move the pipe into the blocked ring.
-			Prio.Ring:Remove(pipe)
-			Prio.Blocked:Add(pipe)
-		else
-			-- Dequeue message after submission.
-			table_remove(pipe, 1)
-			DelMsg(msg)
-
-			if not pipe[1] then  -- did we remove last msg in this pipe?
-				Prio.Ring:Remove(pipe)
-				Prio.ByName[pipe.name] = nil
-				DelPipe(pipe)
-			else
-				ring.pos = ring.pos.next
-			end
-
-			-- Update bandwidth counters on successful sends.
-			local didSend = (sendResult == SendAddonMessageResult.Success)
-			if didSend then
-				Prio.avail = Prio.avail - msg.nSize
-				Prio.nTotalSent = Prio.nTotalSent + msg.nSize
-			end
-
-			-- Notify caller of message submission.
-			if msg.callbackFn then
-				securecallfunction(msg.callbackFn, msg.callbackArg, didSend, sendResult)
-			end
-		end
-	end
-end
-
-
-function ChatThrottleLib.OnEvent(this,event)
-	-- v11: We know that the rate limiter is touchy after login. Assume that it's touchy after zoning, too.
-	local self = ChatThrottleLib
-	if event == "PLAYER_ENTERING_WORLD" then
-		self.HardThrottlingBeginTime = GetTime()	-- Throttle hard for a few seconds after zoning
-		self.avail = 0
-	end
-end
-
-
-function ChatThrottleLib.OnUpdate(this,delay)
-	local self = ChatThrottleLib
-
-	self.OnUpdateDelay = self.OnUpdateDelay + delay
-	self.BlockedQueuesDelay = self.BlockedQueuesDelay + delay
-	if self.OnUpdateDelay < 0.08 then
-		return
-	end
-	self.OnUpdateDelay = 0
-
-	self:UpdateAvail()
-
-	if self.avail < 0  then
-		return -- argh. some bastard is spewing stuff past the lib. just bail early to save cpu.
-	end
-
-	-- Integrate blocked queues back into their rings periodically.
-	if self.BlockedQueuesDelay >= 0.35 then
-		for _, Prio in pairs(self.Prio) do
-			Ring_Link(Prio.Ring, Prio.Blocked)
-		end
-
-		self.BlockedQueuesDelay = 0
-	end
-
-	-- See how many of our priorities have queued messages. This is split
-	-- into two counters because priorities that consist only of blocked
-	-- queues must keep our OnUpdate alive, but shouldn't count toward
-	-- bandwidth distribution.
-	local nSendablePrios = 0
-	local nBlockedPrios = 0
-
-	for prioname, Prio in pairs(self.Prio) do
-		if Prio.Ring.pos then
-			nSendablePrios = nSendablePrios + 1
-		elseif Prio.Blocked.pos then
-			nBlockedPrios = nBlockedPrios + 1
-		end
-
-		-- Collect unused bandwidth from priorities with nothing to send.
-		if not Prio.Ring.pos then
-			self.avail = self.avail + Prio.avail
-			Prio.avail = 0
-		end
-	end
-
-	-- Bandwidth reclamation may take us back over the burst cap.
-	self.avail = math_min(self.avail, self.BURST)
-
-	-- If we can't currently send on any priorities, stop processing early.
-	if nSendablePrios == 0 then
-		-- If we're completely out of data to send, disable queue processing.
-		if nBlockedPrios == 0 then
-			self.bQueueing = false
-			self.Frame:Hide()
-		end
-
-		return
-	end
-
-	-- There's stuff queued. Hand out available bandwidth to priorities as needed and despool their queues
-	local avail = self.avail / nSendablePrios
-	self.avail = 0
-
-	for prioname, Prio in pairs(self.Prio) do
-		if Prio.Ring.pos then
-			Prio.avail = Prio.avail + avail
-			self:Despool(Prio)
-		end
-	end
-end
-
-
-
-
------------------------------------------------------------------------
--- Spooling logic
-
-function ChatThrottleLib:Enqueue(prioname, pipename, msg)
-	local Prio = self.Prio[prioname]
-	local pipe = Prio.ByName[pipename]
-	if not pipe then
-		self.Frame:Show()
-		pipe = NewPipe()
-		pipe.name = pipename
-		Prio.ByName[pipename] = pipe
-		Prio.Ring:Add(pipe)
-	end
-
-	pipe[#pipe + 1] = msg
-
-	self.bQueueing = true
-end
-
-function ChatThrottleLib:SendChatMessage(prio, prefix,   text, chattype, language, destination, queueName, callbackFn, callbackArg)
-	if not self or not prio or not prefix or not text or not self.Prio[prio] then
-		error('Usage: ChatThrottleLib:SendChatMessage("{BULK||NORMAL||ALERT}", "prefix", "text"[, "chattype"[, "language"[, "destination"]]]', 2)
-	end
-	if callbackFn and type(callbackFn)~="function" then
-		error('ChatThrottleLib:ChatMessage(): callbackFn: expected function, got '..type(callbackFn), 2)
-	end
-
-	local nSize = text:len()
-
-	if nSize>255 then
-		error("ChatThrottleLib:SendChatMessage(): message length cannot exceed 255 bytes", 2)
-	end
-
-	nSize = nSize + self.MSG_OVERHEAD
-
-	-- Check if there's room in the global available bandwidth gauge to send directly
-	if not self.bQueueing and nSize < self:UpdateAvail() then
-		local sendResult = PerformSend(_G.SendChatMessage, text, chattype, language, destination)
-
-		if not IsThrottledSendResult(sendResult) then
-			local didSend = (sendResult == SendAddonMessageResult.Success)
-
-			if didSend then
-				self.avail = self.avail - nSize
-				self.Prio[prio].nTotalSent = self.Prio[prio].nTotalSent + nSize
-			end
-
-			if callbackFn then
-				securecallfunction(callbackFn, callbackArg, didSend, sendResult)
-			end
-
-			return
-		end
-	end
-
-	-- Message needs to be queued
-	local msg = NewMsg()
-	msg.f = _G.SendChatMessage
-	msg[1] = text
-	msg[2] = chattype or "SAY"
-	msg[3] = language
-	msg[4] = destination
-	msg.n = 4
-	msg.nSize = nSize
-	msg.callbackFn = callbackFn
-	msg.callbackArg = callbackArg
-
-	self:Enqueue(prio, queueName or prefix, msg)
-end
-
-
-local function SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
-	local nSize = #text + self.MSG_OVERHEAD
-
-	-- Check if there's room in the global available bandwidth gauge to send directly
-	if not self.bQueueing and nSize < self:UpdateAvail() then
-		local sendResult = PerformSend(sendFunction, prefix, text, chattype, target)
-
-		if not IsThrottledSendResult(sendResult) then
-			local didSend = (sendResult == SendAddonMessageResult.Success)
-
-			if didSend then
-				self.avail = self.avail - nSize
-				self.Prio[prio].nTotalSent = self.Prio[prio].nTotalSent + nSize
-			end
-
-			if callbackFn then
-				securecallfunction(callbackFn, callbackArg, didSend, sendResult)
-			end
-
-			return
-		end
-	end
-
-	-- Message needs to be queued
-	local msg = NewMsg()
-	msg.f = sendFunction
-	msg[1] = prefix
-	msg[2] = text
-	msg[3] = chattype
-	msg[4] = target
-	msg.n = (target~=nil) and 4 or 3;
-	msg.nSize = nSize
-	msg.callbackFn = callbackFn
-	msg.callbackArg = callbackArg
-
-	self:Enqueue(prio, queueName or prefix, msg)
-end
-
-
-function ChatThrottleLib:SendAddonMessage(prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
-	if not self or not prio or not prefix or not text or not chattype or not self.Prio[prio] then
-		error('Usage: ChatThrottleLib:SendAddonMessage("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype"[, "target"])', 2)
-	elseif callbackFn and type(callbackFn)~="function" then
-		error('ChatThrottleLib:SendAddonMessage(): callbackFn: expected function, got '..type(callbackFn), 2)
-	elseif #text>255 then
-		error("ChatThrottleLib:SendAddonMessage(): message length cannot exceed 255 bytes", 2)
-	end
-
-	local sendFunction = _G.C_ChatInfo.SendAddonMessage
-	SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
-end
-
-
-function ChatThrottleLib:SendAddonMessageLogged(prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
-	if not self or not prio or not prefix or not text or not chattype or not self.Prio[prio] then
-		error('Usage: ChatThrottleLib:SendAddonMessageLogged("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype"[, "target"])', 2)
-	elseif callbackFn and type(callbackFn)~="function" then
-		error('ChatThrottleLib:SendAddonMessageLogged(): callbackFn: expected function, got '..type(callbackFn), 2)
-	elseif #text>255 then
-		error("ChatThrottleLib:SendAddonMessageLogged(): message length cannot exceed 255 bytes", 2)
-	end
-
-	local sendFunction = _G.C_ChatInfo.SendAddonMessageLogged
-	SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
-end
-
-local function BNSendGameDataReordered(prefix, text, _, gameAccountID)
-	return _G.BNSendGameData(gameAccountID, prefix, text)
-end
-
-function ChatThrottleLib:BNSendGameData(prio, prefix, text, chattype, gameAccountID, queueName, callbackFn, callbackArg)
-	-- Note that this API is intentionally limited to 255 bytes of data
-	-- for reasons of traffic fairness, which is less than the 4078 bytes
-	-- BNSendGameData natively supports. Additionally, a chat type is required
-	-- but must always be set to 'WHISPER' to match what is exposed by the
-	-- receipt event.
-	--
-	-- If splitting messages, callers must also be aware that message
-	-- delivery over BNSendGameData is unordered.
-
-	if not self or not prio or not prefix or not text or not gameAccountID or not chattype or not self.Prio[prio] then
-		error('Usage: ChatThrottleLib:BNSendGameData("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype", gameAccountID)', 2)
-	elseif callbackFn and type(callbackFn)~="function" then
-		error('ChatThrottleLib:BNSendGameData(): callbackFn: expected function, got '..type(callbackFn), 2)
-	elseif #text>255 then
-		error("ChatThrottleLib:BNSendGameData(): message length cannot exceed 255 bytes", 2)
-	elseif chattype ~= "WHISPER" then
-		error("ChatThrottleLib:BNSendGameData(): chat type must be 'WHISPER'", 2)
-	end
-
-	local sendFunction = BNSendGameDataReordered
-	SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, gameAccountID, queueName, callbackFn, callbackArg)
-end
-
-
------------------------------------------------------------------------
--- Get the ball rolling!
-
-ChatThrottleLib:Init()
-
---[[ WoWBench debugging snippet
-if(WOWB_VER) then
-	local function SayTimer()
-		print("SAY: "..GetTime().." "..arg1)
-	end
-	ChatThrottleLib.Frame:SetScript("OnEvent", SayTimer)
-	ChatThrottleLib.Frame:RegisterEvent("CHAT_MSG_SAY")
-end
-]]
-
-
+--
+-- ChatThrottleLib by Mikk
+--
+-- Manages AddOn chat output to keep player from getting kicked off.
+--
+-- ChatThrottleLib:SendChatMessage/:SendAddonMessage functions that accept
+-- a Priority ("BULK", "NORMAL", "ALERT") as well as prefix for SendChatMessage.
+--
+-- Priorities get an equal share of available bandwidth when fully loaded.
+-- Communication channels are separated on extension+chattype+destination and
+-- get round-robinned. (Destination only matters for whispers and channels,
+-- obviously)
+--
+-- Will install hooks for SendChatMessage and SendAddonMessage to measure
+-- bandwidth bypassing the library and use less bandwidth itself.
+--
+--
+-- Fully embeddable library. Just copy this file into your addon directory,
+-- add it to the .toc, and it's done.
+--
+-- Can run as a standalone addon also, but, really, just embed it! :-)
+--
+-- LICENSE: ChatThrottleLib is released into the Public Domain
+--
+
+local CTL_VERSION = 29
+
+local _G = _G
+
+if _G.ChatThrottleLib then
+	if _G.ChatThrottleLib.version >= CTL_VERSION then
+		-- There's already a newer (or same) version loaded. Buh-bye.
+		return
+	elseif not _G.ChatThrottleLib.securelyHooked then
+		print("ChatThrottleLib: Warning: There's an ANCIENT ChatThrottleLib.lua (pre-wow 2.0, <v16) in an addon somewhere. Get the addon updated or copy in a newer ChatThrottleLib.lua (>=v16) in it!")
+		-- ATTEMPT to unhook; this'll behave badly if someone else has hooked...
+		-- ... and if someone has securehooked, they can kiss that goodbye too... >.<
+		_G.SendChatMessage = _G.ChatThrottleLib.ORIG_SendChatMessage
+		if _G.ChatThrottleLib.ORIG_SendAddonMessage then
+			_G.SendAddonMessage = _G.ChatThrottleLib.ORIG_SendAddonMessage
+		end
+	end
+	_G.ChatThrottleLib.ORIG_SendChatMessage = nil
+	_G.ChatThrottleLib.ORIG_SendAddonMessage = nil
+end
+
+if not _G.ChatThrottleLib then
+	_G.ChatThrottleLib = {}
+end
+
+ChatThrottleLib = _G.ChatThrottleLib  -- in case some addon does "local ChatThrottleLib" above us and we're copypasted (AceComm-2, sigh)
+local ChatThrottleLib = _G.ChatThrottleLib
+
+ChatThrottleLib.version = CTL_VERSION
+
+
+
+------------------ TWEAKABLES -----------------
+
+ChatThrottleLib.MAX_CPS = 800			  -- 2000 seems to be safe if NOTHING ELSE is happening. let's call it 800.
+ChatThrottleLib.MSG_OVERHEAD = 40		-- Guesstimate overhead for sending a message; source+dest+chattype+protocolstuff
+
+ChatThrottleLib.BURST = 4000				-- WoW's server buffer seems to be about 32KB. 8KB should be safe, but seen disconnects on _some_ servers. Using 4KB now.
+
+ChatThrottleLib.MIN_FPS = 20				-- Reduce output CPS to half (and don't burst) if FPS drops below this value
+
+
+local setmetatable = setmetatable
+local table_remove = table.remove
+local tostring = tostring
+local GetTime = GetTime
+local math_min = math.min
+local math_max = math.max
+local next = next
+local strlen = string.len
+local GetFramerate = GetFramerate
+local unpack,type,pairs,wipe = unpack,type,pairs,table.wipe
+
+
+-----------------------------------------------------------------------
+-- Double-linked ring implementation
+
+local Ring = {}
+local RingMeta = { __index = Ring }
+
+function Ring:New()
+	local ret = {}
+	setmetatable(ret, RingMeta)
+	return ret
+end
+
+function Ring:Add(obj)	-- Append at the "far end" of the ring (aka just before the current position)
+	if self.pos then
+		obj.prev = self.pos.prev
+		obj.prev.next = obj
+		obj.next = self.pos
+		obj.next.prev = obj
+	else
+		obj.next = obj
+		obj.prev = obj
+		self.pos = obj
+	end
+end
+
+function Ring:Remove(obj)
+	obj.next.prev = obj.prev
+	obj.prev.next = obj.next
+	if self.pos == obj then
+		self.pos = obj.next
+		if self.pos == obj then
+			self.pos = nil
+		end
+	end
+end
+
+-- Note that this is local because there's no upgrade logic for existing ring
+-- metatables, and this isn't present on rings created in versions older than
+-- v25.
+local function Ring_Link(self, other)  -- Move and append all contents of another ring to this ring
+	if not self.pos then
+		-- This ring is empty, so just transfer ownership.
+		self.pos = other.pos
+		other.pos = nil
+	elseif other.pos then
+		-- Our tail should point to their head, and their tail to our head.
+		self.pos.prev.next, other.pos.prev.next = other.pos, self.pos
+		-- Our head should point to their tail, and their head to our tail.
+		self.pos.prev, other.pos.prev = other.pos.prev, self.pos.prev
+		other.pos = nil
+	end
+end
+
+
+
+-----------------------------------------------------------------------
+-- Recycling bin for pipes
+-- A pipe is a plain integer-indexed queue of messages
+-- Pipes normally live in Rings of pipes  (3 rings total, one per priority)
+
+ChatThrottleLib.PipeBin = nil -- pre-v19, drastically different
+local PipeBin = setmetatable({}, {__mode="k"})
+
+local function DelPipe(pipe)
+	PipeBin[pipe] = true
+end
+
+local function NewPipe()
+	local pipe = next(PipeBin)
+	if pipe then
+		wipe(pipe)
+		PipeBin[pipe] = nil
+		return pipe
+	end
+	return {}
+end
+
+
+
+
+-----------------------------------------------------------------------
+-- Recycling bin for messages
+
+ChatThrottleLib.MsgBin = nil -- pre-v19, drastically different
+local MsgBin = setmetatable({}, {__mode="k"})
+
+local function DelMsg(msg)
+	msg[1] = nil
+	-- there's more parameters, but they're very repetetive so the string pool doesn't suffer really, and it's faster to just not delete them.
+	MsgBin[msg] = true
+end
+
+local function NewMsg()
+	local msg = next(MsgBin)
+	if msg then
+		MsgBin[msg] = nil
+		return msg
+	end
+	return {}
+end
+
+
+-----------------------------------------------------------------------
+-- ChatThrottleLib:Init
+-- Initialize queues, set up frame for OnUpdate, etc
+
+
+function ChatThrottleLib:Init()
+
+	-- Set up queues
+	if not self.Prio then
+		self.Prio = {}
+		self.Prio["ALERT"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
+		self.Prio["NORMAL"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
+		self.Prio["BULK"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
+	end
+
+	if not self.BlockedQueuesDelay then
+		-- v25: Add blocked queues to rings to handle new client throttles.
+		for _, Prio in pairs(self.Prio) do
+			Prio.Blocked = Ring:New()
+		end
+	end
+
+	-- v4: total send counters per priority
+	for _, Prio in pairs(self.Prio) do
+		Prio.nTotalSent = Prio.nTotalSent or 0
+	end
+
+	if not self.avail then
+		self.avail = 0 -- v5
+	end
+	if not self.nTotalSent then
+		self.nTotalSent = 0 -- v5
+	end
+
+
+	-- Set up a frame to get OnUpdate events
+	if not self.Frame then
+		self.Frame = CreateFrame("Frame")
+		self.Frame:Hide()
+	end
+	self.Frame:SetScript("OnUpdate", self.OnUpdate)
+	self.Frame:SetScript("OnEvent", self.OnEvent)	-- v11: Monitor P_E_W so we can throttle hard for a few seconds
+	self.Frame:RegisterEvent("PLAYER_ENTERING_WORLD")
+	self.OnUpdateDelay = 0
+	self.BlockedQueuesDelay = 0
+	self.LastAvailUpdate = GetTime()
+	self.HardThrottlingBeginTime = GetTime()	-- v11: Throttle hard for a few seconds after startup
+
+	-- Hook SendChatMessage and SendAddonMessage so we can measure unpiped traffic and avoid overloads (v7)
+	if not self.securelyHooked then
+		-- Use secure hooks as of v16. Old regular hook support yanked out in v21.
+		self.securelyHooked = true
+		--SendChatMessage
+		hooksecurefunc("SendChatMessage", function(...)
+			return ChatThrottleLib.Hook_SendChatMessage(...)
+		end)
+		--SendAddonMessage
+		hooksecurefunc(_G.C_ChatInfo, "SendAddonMessage", function(...)
+			return ChatThrottleLib.Hook_SendAddonMessage(...)
+		end)
+	end
+
+	-- v26: Hook SendAddonMessageLogged for traffic logging
+	if not self.securelyHookedLogged then
+		self.securelyHookedLogged = true
+		hooksecurefunc(_G.C_ChatInfo, "SendAddonMessageLogged", function(...)
+			return ChatThrottleLib.Hook_SendAddonMessageLogged(...)
+		end)
+	end
+
+	-- v29: Hook BNSendGameData for traffic logging
+	if not self.securelyHookedBNGameData then
+		self.securelyHookedBNGameData = true
+		hooksecurefunc("BNSendGameData", function(...)
+			return ChatThrottleLib.Hook_BNSendGameData(...)
+		end)
+	end
+
+	self.nBypass = 0
+end
+
+
+-----------------------------------------------------------------------
+-- ChatThrottleLib.Hook_SendChatMessage / .Hook_SendAddonMessage
+
+local bMyTraffic = false
+
+function ChatThrottleLib.Hook_SendChatMessage(text, chattype, language, destination, ...)
+	if bMyTraffic then
+		return
+	end
+	local self = ChatThrottleLib
+	local size = strlen(tostring(text or "")) + strlen(tostring(destination or "")) + self.MSG_OVERHEAD
+	self.avail = self.avail - size
+	self.nBypass = self.nBypass + size	-- just a statistic
+end
+function ChatThrottleLib.Hook_SendAddonMessage(prefix, text, chattype, destination, ...)
+	if bMyTraffic then
+		return
+	end
+	local self = ChatThrottleLib
+	local size = tostring(text or ""):len() + tostring(prefix or ""):len();
+	size = size + tostring(destination or ""):len() + self.MSG_OVERHEAD
+	self.avail = self.avail - size
+	self.nBypass = self.nBypass + size	-- just a statistic
+end
+function ChatThrottleLib.Hook_SendAddonMessageLogged(prefix, text, chattype, destination, ...)
+	ChatThrottleLib.Hook_SendAddonMessage(prefix, text, chattype, destination, ...)
+end
+function ChatThrottleLib.Hook_BNSendGameData(destination, prefix, text)
+	ChatThrottleLib.Hook_SendAddonMessage(prefix, text, "WHISPER", destination)
+end
+
+
+
+-----------------------------------------------------------------------
+-- ChatThrottleLib:UpdateAvail
+-- Update self.avail with how much bandwidth is currently available
+
+function ChatThrottleLib:UpdateAvail()
+	local now = GetTime()
+	local MAX_CPS = self.MAX_CPS;
+	local newavail = MAX_CPS * (now - self.LastAvailUpdate)
+	local avail = self.avail
+
+	if now - self.HardThrottlingBeginTime < 5 then
+		-- First 5 seconds after startup/zoning: VERY hard clamping to avoid irritating the server rate limiter, it seems very cranky then
+		avail = math_min(avail + (newavail*0.1), MAX_CPS*0.5)
+		self.bChoking = true
+	elseif GetFramerate() < self.MIN_FPS then		-- GetFrameRate call takes ~0.002 secs
+		avail = math_min(MAX_CPS, avail + newavail*0.5)
+		self.bChoking = true		-- just a statistic
+	else
+		avail = math_min(self.BURST, avail + newavail)
+		self.bChoking = false
+	end
+
+	avail = math_max(avail, 0-(MAX_CPS*2))	-- Can go negative when someone is eating bandwidth past the lib. but we refuse to stay silent for more than 2 seconds; if they can do it, we can.
+
+	self.avail = avail
+	self.LastAvailUpdate = now
+
+	return avail
+end
+
+
+-----------------------------------------------------------------------
+-- Despooling logic
+-- Reminder:
+-- - We have 3 Priorities, each containing a "Ring" construct ...
+-- - ... made up of N "Pipe"s (1 for each destination/pipename)
+-- - and each pipe contains messages
+
+local SendAddonMessageResult = Enum.SendAddonMessageResult or {
+	Success = 0,
+	AddonMessageThrottle = 3,
+	NotInGroup = 5,
+	ChannelThrottle = 8,
+	GeneralError = 9,
+}
+
+local function MapToSendResult(ok, ...)
+	local result
+
+	if not ok then
+		-- The send function itself errored; don't look at anything else.
+		result = SendAddonMessageResult.GeneralError
+	else
+		-- Grab the last return value from the send function and remap
+		-- it from a boolean to an enum code. If there are no results,
+		-- assume success (true).
+
+		result = select(-1, true, ...)
+
+		if result == true then
+			result = SendAddonMessageResult.Success
+		elseif result == false then
+			result = SendAddonMessageResult.GeneralError
+		end
+	end
+
+	return result
+end
+
+local function IsThrottledSendResult(result)
+	return result == SendAddonMessageResult.AddonMessageThrottle
+end
+
+-- A copy of this function exists in FrameXML, but for clarity it's here too.
+local function CallErrorHandler(...)
+	return geterrorhandler()(...)
+end
+
+local function PerformSend(sendFunction, ...)
+	bMyTraffic = true
+	local sendResult = MapToSendResult(xpcall(sendFunction, CallErrorHandler, ...))
+	bMyTraffic = false
+	return sendResult
+end
+
+function ChatThrottleLib:Despool(Prio)
+	local ring = Prio.Ring
+	while ring.pos and Prio.avail > ring.pos[1].nSize do
+		local pipe = ring.pos
+		local msg = pipe[1]
+		local sendResult = PerformSend(msg.f, unpack(msg, 1, msg.n))
+
+		if IsThrottledSendResult(sendResult) then
+			-- Message was throttled; move the pipe into the blocked ring.
+			Prio.Ring:Remove(pipe)
+			Prio.Blocked:Add(pipe)
+		else
+			-- Dequeue message after submission.
+			table_remove(pipe, 1)
+			DelMsg(msg)
+
+			if not pipe[1] then  -- did we remove last msg in this pipe?
+				Prio.Ring:Remove(pipe)
+				Prio.ByName[pipe.name] = nil
+				DelPipe(pipe)
+			else
+				ring.pos = ring.pos.next
+			end
+
+			-- Update bandwidth counters on successful sends.
+			local didSend = (sendResult == SendAddonMessageResult.Success)
+			if didSend then
+				Prio.avail = Prio.avail - msg.nSize
+				Prio.nTotalSent = Prio.nTotalSent + msg.nSize
+			end
+
+			-- Notify caller of message submission.
+			if msg.callbackFn then
+				securecallfunction(msg.callbackFn, msg.callbackArg, didSend, sendResult)
+			end
+		end
+	end
+end
+
+
+function ChatThrottleLib.OnEvent(this,event)
+	-- v11: We know that the rate limiter is touchy after login. Assume that it's touchy after zoning, too.
+	local self = ChatThrottleLib
+	if event == "PLAYER_ENTERING_WORLD" then
+		self.HardThrottlingBeginTime = GetTime()	-- Throttle hard for a few seconds after zoning
+		self.avail = 0
+	end
+end
+
+
+function ChatThrottleLib.OnUpdate(this,delay)
+	local self = ChatThrottleLib
+
+	self.OnUpdateDelay = self.OnUpdateDelay + delay
+	self.BlockedQueuesDelay = self.BlockedQueuesDelay + delay
+	if self.OnUpdateDelay < 0.08 then
+		return
+	end
+	self.OnUpdateDelay = 0
+
+	self:UpdateAvail()
+
+	if self.avail < 0  then
+		return -- argh. some bastard is spewing stuff past the lib. just bail early to save cpu.
+	end
+
+	-- Integrate blocked queues back into their rings periodically.
+	if self.BlockedQueuesDelay >= 0.35 then
+		for _, Prio in pairs(self.Prio) do
+			Ring_Link(Prio.Ring, Prio.Blocked)
+		end
+
+		self.BlockedQueuesDelay = 0
+	end
+
+	-- See how many of our priorities have queued messages. This is split
+	-- into two counters because priorities that consist only of blocked
+	-- queues must keep our OnUpdate alive, but shouldn't count toward
+	-- bandwidth distribution.
+	local nSendablePrios = 0
+	local nBlockedPrios = 0
+
+	for prioname, Prio in pairs(self.Prio) do
+		if Prio.Ring.pos then
+			nSendablePrios = nSendablePrios + 1
+		elseif Prio.Blocked.pos then
+			nBlockedPrios = nBlockedPrios + 1
+		end
+
+		-- Collect unused bandwidth from priorities with nothing to send.
+		if not Prio.Ring.pos then
+			self.avail = self.avail + Prio.avail
+			Prio.avail = 0
+		end
+	end
+
+	-- Bandwidth reclamation may take us back over the burst cap.
+	self.avail = math_min(self.avail, self.BURST)
+
+	-- If we can't currently send on any priorities, stop processing early.
+	if nSendablePrios == 0 then
+		-- If we're completely out of data to send, disable queue processing.
+		if nBlockedPrios == 0 then
+			self.bQueueing = false
+			self.Frame:Hide()
+		end
+
+		return
+	end
+
+	-- There's stuff queued. Hand out available bandwidth to priorities as needed and despool their queues
+	local avail = self.avail / nSendablePrios
+	self.avail = 0
+
+	for prioname, Prio in pairs(self.Prio) do
+		if Prio.Ring.pos then
+			Prio.avail = Prio.avail + avail
+			self:Despool(Prio)
+		end
+	end
+end
+
+
+
+
+-----------------------------------------------------------------------
+-- Spooling logic
+
+function ChatThrottleLib:Enqueue(prioname, pipename, msg)
+	local Prio = self.Prio[prioname]
+	local pipe = Prio.ByName[pipename]
+	if not pipe then
+		self.Frame:Show()
+		pipe = NewPipe()
+		pipe.name = pipename
+		Prio.ByName[pipename] = pipe
+		Prio.Ring:Add(pipe)
+	end
+
+	pipe[#pipe + 1] = msg
+
+	self.bQueueing = true
+end
+
+function ChatThrottleLib:SendChatMessage(prio, prefix,   text, chattype, language, destination, queueName, callbackFn, callbackArg)
+	if not self or not prio or not prefix or not text or not self.Prio[prio] then
+		error('Usage: ChatThrottleLib:SendChatMessage("{BULK||NORMAL||ALERT}", "prefix", "text"[, "chattype"[, "language"[, "destination"]]]', 2)
+	end
+	if callbackFn and type(callbackFn)~="function" then
+		error('ChatThrottleLib:ChatMessage(): callbackFn: expected function, got '..type(callbackFn), 2)
+	end
+
+	local nSize = text:len()
+
+	if nSize>255 then
+		error("ChatThrottleLib:SendChatMessage(): message length cannot exceed 255 bytes", 2)
+	end
+
+	nSize = nSize + self.MSG_OVERHEAD
+
+	-- Check if there's room in the global available bandwidth gauge to send directly
+	if not self.bQueueing and nSize < self:UpdateAvail() then
+		local sendResult = PerformSend(_G.SendChatMessage, text, chattype, language, destination)
+
+		if not IsThrottledSendResult(sendResult) then
+			local didSend = (sendResult == SendAddonMessageResult.Success)
+
+			if didSend then
+				self.avail = self.avail - nSize
+				self.Prio[prio].nTotalSent = self.Prio[prio].nTotalSent + nSize
+			end
+
+			if callbackFn then
+				securecallfunction(callbackFn, callbackArg, didSend, sendResult)
+			end
+
+			return
+		end
+	end
+
+	-- Message needs to be queued
+	local msg = NewMsg()
+	msg.f = _G.SendChatMessage
+	msg[1] = text
+	msg[2] = chattype or "SAY"
+	msg[3] = language
+	msg[4] = destination
+	msg.n = 4
+	msg.nSize = nSize
+	msg.callbackFn = callbackFn
+	msg.callbackArg = callbackArg
+
+	self:Enqueue(prio, queueName or prefix, msg)
+end
+
+
+local function SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
+	local nSize = #text + self.MSG_OVERHEAD
+
+	-- Check if there's room in the global available bandwidth gauge to send directly
+	if not self.bQueueing and nSize < self:UpdateAvail() then
+		local sendResult = PerformSend(sendFunction, prefix, text, chattype, target)
+
+		if not IsThrottledSendResult(sendResult) then
+			local didSend = (sendResult == SendAddonMessageResult.Success)
+
+			if didSend then
+				self.avail = self.avail - nSize
+				self.Prio[prio].nTotalSent = self.Prio[prio].nTotalSent + nSize
+			end
+
+			if callbackFn then
+				securecallfunction(callbackFn, callbackArg, didSend, sendResult)
+			end
+
+			return
+		end
+	end
+
+	-- Message needs to be queued
+	local msg = NewMsg()
+	msg.f = sendFunction
+	msg[1] = prefix
+	msg[2] = text
+	msg[3] = chattype
+	msg[4] = target
+	msg.n = (target~=nil) and 4 or 3;
+	msg.nSize = nSize
+	msg.callbackFn = callbackFn
+	msg.callbackArg = callbackArg
+
+	self:Enqueue(prio, queueName or prefix, msg)
+end
+
+
+function ChatThrottleLib:SendAddonMessage(prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
+	if not self or not prio or not prefix or not text or not chattype or not self.Prio[prio] then
+		error('Usage: ChatThrottleLib:SendAddonMessage("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype"[, "target"])', 2)
+	elseif callbackFn and type(callbackFn)~="function" then
+		error('ChatThrottleLib:SendAddonMessage(): callbackFn: expected function, got '..type(callbackFn), 2)
+	elseif #text>255 then
+		error("ChatThrottleLib:SendAddonMessage(): message length cannot exceed 255 bytes", 2)
+	end
+
+	local sendFunction = _G.C_ChatInfo.SendAddonMessage
+	SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
+end
+
+
+function ChatThrottleLib:SendAddonMessageLogged(prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
+	if not self or not prio or not prefix or not text or not chattype or not self.Prio[prio] then
+		error('Usage: ChatThrottleLib:SendAddonMessageLogged("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype"[, "target"])', 2)
+	elseif callbackFn and type(callbackFn)~="function" then
+		error('ChatThrottleLib:SendAddonMessageLogged(): callbackFn: expected function, got '..type(callbackFn), 2)
+	elseif #text>255 then
+		error("ChatThrottleLib:SendAddonMessageLogged(): message length cannot exceed 255 bytes", 2)
+	end
+
+	local sendFunction = _G.C_ChatInfo.SendAddonMessageLogged
+	SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
+end
+
+local function BNSendGameDataReordered(prefix, text, _, gameAccountID)
+	return _G.BNSendGameData(gameAccountID, prefix, text)
+end
+
+function ChatThrottleLib:BNSendGameData(prio, prefix, text, chattype, gameAccountID, queueName, callbackFn, callbackArg)
+	-- Note that this API is intentionally limited to 255 bytes of data
+	-- for reasons of traffic fairness, which is less than the 4078 bytes
+	-- BNSendGameData natively supports. Additionally, a chat type is required
+	-- but must always be set to 'WHISPER' to match what is exposed by the
+	-- receipt event.
+	--
+	-- If splitting messages, callers must also be aware that message
+	-- delivery over BNSendGameData is unordered.
+
+	if not self or not prio or not prefix or not text or not gameAccountID or not chattype or not self.Prio[prio] then
+		error('Usage: ChatThrottleLib:BNSendGameData("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype", gameAccountID)', 2)
+	elseif callbackFn and type(callbackFn)~="function" then
+		error('ChatThrottleLib:BNSendGameData(): callbackFn: expected function, got '..type(callbackFn), 2)
+	elseif #text>255 then
+		error("ChatThrottleLib:BNSendGameData(): message length cannot exceed 255 bytes", 2)
+	elseif chattype ~= "WHISPER" then
+		error("ChatThrottleLib:BNSendGameData(): chat type must be 'WHISPER'", 2)
+	end
+
+	local sendFunction = BNSendGameDataReordered
+	SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, gameAccountID, queueName, callbackFn, callbackArg)
+end
+
+
+-----------------------------------------------------------------------
+-- Get the ball rolling!
+
+ChatThrottleLib:Init()
+
+--[[ WoWBench debugging snippet
+if(WOWB_VER) then
+	local function SayTimer()
+		print("SAY: "..GetTime().." "..arg1)
+	end
+	ChatThrottleLib.Frame:SetScript("OnEvent", SayTimer)
+	ChatThrottleLib.Frame:RegisterEvent("CHAT_MSG_SAY")
+end
+]]
+
+
diff --git a/Carbonite/Libs/AceConfig-3.0/AceConfig-3.0.lua b/Carbonite/Libs/AceConfig-3.0/AceConfig-3.0.lua
index a717985..ab91c9e 100644
--- a/Carbonite/Libs/AceConfig-3.0/AceConfig-3.0.lua
+++ b/Carbonite/Libs/AceConfig-3.0/AceConfig-3.0.lua
@@ -1,58 +1,58 @@
---- AceConfig-3.0 wrapper library.
--- Provides an API to register an options table with the config registry,
--- as well as associate it with a slash command.
--- @class file
--- @name AceConfig-3.0
--- @release $Id: AceConfig-3.0.lua 1335 2024-05-05 19:35:16Z nevcairiel $
-
---[[
-AceConfig-3.0
-
-Very light wrapper library that combines all the AceConfig subcomponents into one more easily used whole.
-
-]]
-
-local cfgreg = LibStub("AceConfigRegistry-3.0")
-local cfgcmd = LibStub("AceConfigCmd-3.0")
-
-local MAJOR, MINOR = "AceConfig-3.0", 3
-local AceConfig = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceConfig then return end
-
---TODO: local cfgdlg = LibStub("AceConfigDialog-3.0", true)
---TODO: local cfgdrp = LibStub("AceConfigDropdown-3.0", true)
-
--- Lua APIs
-local pcall, error, type, pairs = pcall, error, type, pairs
-
--- -------------------------------------------------------------------
--- :RegisterOptionsTable(appName, options, slashcmd)
---
--- - appName - (string) application name
--- - options - table or function ref, see AceConfigRegistry
--- - slashcmd - slash command (string) or table with commands, or nil to NOT create a slash command
-
---- Register a option table with the AceConfig registry.
--- You can supply a slash command (or a table of slash commands) to register with AceConfigCmd directly.
--- @paramsig appName, options [, slashcmd]
--- @param appName The application name for the config table.
--- @param options The option table (or a function to generate one on demand).  http://www.wowace.com/addons/ace3/pages/ace-config-3-0-options-tables/
--- @param slashcmd A slash command to register for the option table, or a table of slash commands.
--- @usage
--- local AceConfig = LibStub("AceConfig-3.0")
--- AceConfig:RegisterOptionsTable("MyAddon", myOptions, {"/myslash", "/my"})
-function AceConfig:RegisterOptionsTable(appName, options, slashcmd)
-	local ok,msg = pcall(cfgreg.RegisterOptionsTable, self, appName, options)
-	if not ok then error(msg, 2) end
-
-	if slashcmd then
-		if type(slashcmd) == "table" then
-			for _,cmd in pairs(slashcmd) do
-				cfgcmd:CreateChatCommand(cmd, appName)
-			end
-		else
-			cfgcmd:CreateChatCommand(slashcmd, appName)
-		end
-	end
-end
+--- AceConfig-3.0 wrapper library.
+-- Provides an API to register an options table with the config registry,
+-- as well as associate it with a slash command.
+-- @class file
+-- @name AceConfig-3.0
+-- @release $Id: AceConfig-3.0.lua 1335 2024-05-05 19:35:16Z nevcairiel $
+
+--[[
+AceConfig-3.0
+
+Very light wrapper library that combines all the AceConfig subcomponents into one more easily used whole.
+
+]]
+
+local cfgreg = LibStub("AceConfigRegistry-3.0")
+local cfgcmd = LibStub("AceConfigCmd-3.0")
+
+local MAJOR, MINOR = "AceConfig-3.0", 3
+local AceConfig = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceConfig then return end
+
+--TODO: local cfgdlg = LibStub("AceConfigDialog-3.0", true)
+--TODO: local cfgdrp = LibStub("AceConfigDropdown-3.0", true)
+
+-- Lua APIs
+local pcall, error, type, pairs = pcall, error, type, pairs
+
+-- -------------------------------------------------------------------
+-- :RegisterOptionsTable(appName, options, slashcmd)
+--
+-- - appName - (string) application name
+-- - options - table or function ref, see AceConfigRegistry
+-- - slashcmd - slash command (string) or table with commands, or nil to NOT create a slash command
+
+--- Register a option table with the AceConfig registry.
+-- You can supply a slash command (or a table of slash commands) to register with AceConfigCmd directly.
+-- @paramsig appName, options [, slashcmd]
+-- @param appName The application name for the config table.
+-- @param options The option table (or a function to generate one on demand).  http://www.wowace.com/addons/ace3/pages/ace-config-3-0-options-tables/
+-- @param slashcmd A slash command to register for the option table, or a table of slash commands.
+-- @usage
+-- local AceConfig = LibStub("AceConfig-3.0")
+-- AceConfig:RegisterOptionsTable("MyAddon", myOptions, {"/myslash", "/my"})
+function AceConfig:RegisterOptionsTable(appName, options, slashcmd)
+	local ok,msg = pcall(cfgreg.RegisterOptionsTable, self, appName, options)
+	if not ok then error(msg, 2) end
+
+	if slashcmd then
+		if type(slashcmd) == "table" then
+			for _,cmd in pairs(slashcmd) do
+				cfgcmd:CreateChatCommand(cmd, appName)
+			end
+		else
+			cfgcmd:CreateChatCommand(slashcmd, appName)
+		end
+	end
+end
diff --git a/Carbonite/Libs/AceConfig-3.0/AceConfig-3.0.xml b/Carbonite/Libs/AceConfig-3.0/AceConfig-3.0.xml
index 84c8d03..a3569b7 100644
--- a/Carbonite/Libs/AceConfig-3.0/AceConfig-3.0.xml
+++ b/Carbonite/Libs/AceConfig-3.0/AceConfig-3.0.xml
@@ -1,8 +1,8 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Include file="AceConfigRegistry-3.0\AceConfigRegistry-3.0.xml"/>
-	<Include file="AceConfigCmd-3.0\AceConfigCmd-3.0.xml"/>
-	<Include file="AceConfigDialog-3.0\AceConfigDialog-3.0.xml"/>
-	<!--<Include file="AceConfigDropdown-3.0\AceConfigDropdown-3.0.xml"/>-->
-	<Script file="AceConfig-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Include file="AceConfigRegistry-3.0\AceConfigRegistry-3.0.xml"/>
+	<Include file="AceConfigCmd-3.0\AceConfigCmd-3.0.xml"/>
+	<Include file="AceConfigDialog-3.0\AceConfigDialog-3.0.xml"/>
+	<!--<Include file="AceConfigDropdown-3.0\AceConfigDropdown-3.0.xml"/>-->
+	<Script file="AceConfig-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.lua b/Carbonite/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.lua
index a4240ce..6dd6438 100644
--- a/Carbonite/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.lua
+++ b/Carbonite/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.lua
@@ -1,787 +1,787 @@
---- AceConfigCmd-3.0 handles access to an options table through the "command line" interface via the ChatFrames.
--- @class file
--- @name AceConfigCmd-3.0
--- @release $Id: AceConfigCmd-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
-
---[[
-AceConfigCmd-3.0
-
-Handles commandline optionstable access
-
-REQUIRES: AceConsole-3.0 for command registration (loaded on demand)
-
-]]
-
--- TODO: plugin args
-
-local cfgreg = LibStub("AceConfigRegistry-3.0")
-
-local MAJOR, MINOR = "AceConfigCmd-3.0", 14
-local AceConfigCmd = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceConfigCmd then return end
-
-AceConfigCmd.commands = AceConfigCmd.commands or {}
-local commands = AceConfigCmd.commands
-
-local AceConsole -- LoD
-local AceConsoleName = "AceConsole-3.0"
-
--- Lua APIs
-local strsub, strsplit, strlower, strmatch, strtrim = string.sub, string.split, string.lower, string.match, string.trim
-local format, tonumber, tostring = string.format, tonumber, tostring
-local tsort, tinsert = table.sort, table.insert
-local select, pairs, next, type = select, pairs, next, type
-local error, assert = error, assert
-
--- WoW APIs
-local _G = _G
-
-local L = setmetatable({}, {	-- TODO: replace with proper locale
-	__index = function(self,k) return k end
-})
-
-local function print(msg)
-	(SELECTED_CHAT_FRAME or DEFAULT_CHAT_FRAME):AddMessage(msg)
-end
-
--- constants used by getparam() calls below
-
-local handlertypes = {["table"]=true}
-local handlermsg = "expected a table"
-
-local functypes = {["function"]=true, ["string"]=true}
-local funcmsg = "expected function or member name"
-
-
--- pickfirstset() - picks the first non-nil value and returns it
-
-local function pickfirstset(...)
-	for i=1,select("#",...) do
-		if select(i,...)~=nil then
-			return select(i,...)
-		end
-	end
-end
-
-
--- err() - produce real error() regarding malformed options tables etc
-
-local function err(info,inputpos,msg )
-	local cmdstr=" "..strsub(info.input, 1, inputpos-1)
-	error(MAJOR..": /" ..info[0] ..cmdstr ..": "..(msg or "malformed options table"), 2)
-end
-
-
--- usererr() - produce chatframe message regarding bad slash syntax etc
-
-local function usererr(info,inputpos,msg )
-	local cmdstr=strsub(info.input, 1, inputpos-1);
-	print("/" ..info[0] .. " "..cmdstr ..": "..(msg or "malformed options table"))
-end
-
-
--- callmethod() - call a given named method (e.g. "get", "set") with given arguments
-
-local function callmethod(info, inputpos, tab, methodtype, ...)
-	local method = info[methodtype]
-	if not method then
-		err(info, inputpos, "'"..methodtype.."': not set")
-	end
-
-	info.arg = tab.arg
-	info.option = tab
-	info.type = tab.type
-
-	if type(method)=="function" then
-		return method(info, ...)
-	elseif type(method)=="string" then
-		if type(info.handler[method])~="function" then
-			err(info, inputpos, "'"..methodtype.."': '"..method.."' is not a member function of "..tostring(info.handler))
-		end
-		return info.handler[method](info.handler, info, ...)
-	else
-		assert(false)	-- type should have already been checked on read
-	end
-end
-
--- callfunction() - call a given named function (e.g. "name", "desc") with given arguments
-
-local function callfunction(info, tab, methodtype, ...)
-	local method = tab[methodtype]
-
-	info.arg = tab.arg
-	info.option = tab
-	info.type = tab.type
-
-	if type(method)=="function" then
-		return method(info, ...)
-	else
-		assert(false) -- type should have already been checked on read
-	end
-end
-
--- do_final() - do the final step (set/execute) along with validation and confirmation
-
-local function do_final(info, inputpos, tab, methodtype, ...)
-	if info.validate then
-		local res = callmethod(info,inputpos,tab,"validate",...)
-		if type(res)=="string" then
-			usererr(info, inputpos, "'"..strsub(info.input, inputpos).."' - "..res)
-			return
-		end
-	end
-	-- console ignores .confirm
-
-	callmethod(info,inputpos,tab,methodtype, ...)
-end
-
-
--- getparam() - used by handle() to retreive and store "handler", "get", "set", etc
-
-local function getparam(info, inputpos, tab, depth, paramname, types, errormsg)
-	local old,oldat = info[paramname], info[paramname.."_at"]
-	local val=tab[paramname]
-	if val~=nil then
-		if val==false then
-			val=nil
-		elseif not types[type(val)] then
-			err(info, inputpos, "'" .. paramname.. "' - "..errormsg)
-		end
-		info[paramname] = val
-		info[paramname.."_at"] = depth
-	end
-	return old,oldat
-end
-
-
--- iterateargs(tab) - custom iterator that iterates both t.args and t.plugins.*
-local dummytable={}
-
-local function iterateargs(tab)
-	if not tab.plugins then
-		return pairs(tab.args)
-	end
-
-	local argtabkey,argtab=next(tab.plugins)
-	local v
-
-	return function(_, k)
-		while argtab do
-			k,v = next(argtab, k)
-			if k then return k,v end
-			if argtab==tab.args then
-				argtab=nil
-			else
-				argtabkey,argtab = next(tab.plugins, argtabkey)
-				if not argtabkey then
-					argtab=tab.args
-				end
-			end
-		end
-	end
-end
-
-local function checkhidden(info, inputpos, tab)
-	if tab.cmdHidden~=nil then
-		return tab.cmdHidden
-	end
-	local hidden = tab.hidden
-	if type(hidden) == "function" or type(hidden) == "string" then
-		info.hidden = hidden
-		hidden = callmethod(info, inputpos, tab, 'hidden')
-		info.hidden = nil
-	end
-	return hidden
-end
-
-local function showhelp(info, inputpos, tab, depth, noHead)
-	if not noHead then
-		print("|cff33ff99"..info.appName.."|r: Arguments to |cffffff78/"..info[0].."|r "..strsub(info.input,1,inputpos-1)..":")
-	end
-
-	local sortTbl = {}	-- [1..n]=name
-	local refTbl = {}   -- [name]=tableref
-
-	for k,v in iterateargs(tab) do
-		if not refTbl[k] then	-- a plugin overriding something in .args
-			tinsert(sortTbl, k)
-			refTbl[k] = v
-		end
-	end
-
-	tsort(sortTbl, function(one, two)
-		local o1 = refTbl[one].order or 100
-		local o2 = refTbl[two].order or 100
-		if type(o1) == "function" or type(o1) == "string" then
-			info.order = o1
-			info[#info+1] = one
-			o1 = callmethod(info, inputpos, refTbl[one], "order")
-			info[#info] = nil
-			info.order = nil
-		end
-		if type(o2) == "function" or type(o1) == "string" then
-			info.order = o2
-			info[#info+1] = two
-			o2 = callmethod(info, inputpos, refTbl[two], "order")
-			info[#info] = nil
-			info.order = nil
-		end
-		if o1<0 and o2<0 then return o1<o2 end
-		if o2<0 then return true end
-		if o1<0 then return false end
-		if o1==o2 then return tostring(one)<tostring(two) end   -- compare names
-		return o1<o2
-	end)
-
-	for i = 1, #sortTbl do
-		local k = sortTbl[i]
-		local v = refTbl[k]
-		if not checkhidden(info, inputpos, v) then
-			if v.type ~= "description" and v.type ~= "header" then
-				-- recursively show all inline groups
-				local name, desc = v.name, v.desc
-				if type(name) == "function" then
-					name = callfunction(info, v, 'name')
-				end
-				if type(desc) == "function" then
-					desc = callfunction(info, v, 'desc')
-				end
-				if v.type == "group" and pickfirstset(v.cmdInline, v.inline, false) then
-					print("  "..(desc or name)..":")
-					local oldhandler,oldhandler_at = getparam(info, inputpos, v, depth, "handler", handlertypes, handlermsg)
-					showhelp(info, inputpos, v, depth, true)
-					info.handler,info.handler_at = oldhandler,oldhandler_at
-				else
-					local key = k:gsub(" ", "_")
-					print("  |cffffff78"..key.."|r - "..(desc or name or ""))
-				end
-			end
-		end
-	end
-end
-
-
-local function keybindingValidateFunc(text)
-	if text == nil or text == "NONE" then
-		return nil
-	end
-	text = text:upper()
-	local shift, ctrl, alt
-	local modifier
-	while true do
-		if text == "-" then
-			break
-		end
-		modifier, text = strsplit('-', text, 2)
-		if text then
-			if modifier ~= "SHIFT" and modifier ~= "CTRL" and modifier ~= "ALT" then
-				return false
-			end
-			if modifier == "SHIFT" then
-				if shift then
-					return false
-				end
-				shift = true
-			end
-			if modifier == "CTRL" then
-				if ctrl then
-					return false
-				end
-				ctrl = true
-			end
-			if modifier == "ALT" then
-				if alt then
-					return false
-				end
-				alt = true
-			end
-		else
-			text = modifier
-			break
-		end
-	end
-	if text == "" then
-		return false
-	end
-	if not text:find("^F%d+$") and text ~= "CAPSLOCK" and text:len() ~= 1 and (text:byte() < 128 or text:len() > 4) and not _G["KEY_" .. text] then
-		return false
-	end
-	local s = text
-	if shift then
-		s = "SHIFT-" .. s
-	end
-	if ctrl then
-		s = "CTRL-" .. s
-	end
-	if alt then
-		s = "ALT-" .. s
-	end
-	return s
-end
-
--- handle() - selfrecursing function that processes input->optiontable
--- - depth - starts at 0
--- - retfalse - return false rather than produce error if a match is not found (used by inlined groups)
-
-local function handle(info, inputpos, tab, depth, retfalse)
-
-	if not(type(tab)=="table" and type(tab.type)=="string") then err(info,inputpos) end
-
-	-------------------------------------------------------------------
-	-- Grab hold of handler,set,get,func,etc if set (and remember old ones)
-	-- Note that we do NOT validate if method names are correct at this stage,
-	-- the handler may change before they're actually used!
-
-	local oldhandler,oldhandler_at = getparam(info,inputpos,tab,depth,"handler",handlertypes,handlermsg)
-	local oldset,oldset_at = getparam(info,inputpos,tab,depth,"set",functypes,funcmsg)
-	local oldget,oldget_at = getparam(info,inputpos,tab,depth,"get",functypes,funcmsg)
-	local oldfunc,oldfunc_at = getparam(info,inputpos,tab,depth,"func",functypes,funcmsg)
-	local oldvalidate,oldvalidate_at = getparam(info,inputpos,tab,depth,"validate",functypes,funcmsg)
-	--local oldconfirm,oldconfirm_at = getparam(info,inputpos,tab,depth,"confirm",functypes,funcmsg)
-
-	-------------------------------------------------------------------
-	-- Act according to .type of this table
-
-	if tab.type=="group" then
-		------------ group --------------------------------------------
-
-		if type(tab.args)~="table" then err(info, inputpos) end
-		if tab.plugins and type(tab.plugins)~="table" then err(info,inputpos) end
-
-		-- grab next arg from input
-		local _,nextpos,arg = (info.input):find(" *([^ ]+) *", inputpos)
-		if not arg then
-			showhelp(info, inputpos, tab, depth)
-			return
-		end
-		nextpos=nextpos+1
-
-		-- loop .args and try to find a key with a matching name
-		for k,v in iterateargs(tab) do
-			if not(type(k)=="string" and type(v)=="table" and type(v.type)=="string") then err(info,inputpos, "options table child '"..tostring(k).."' is malformed") end
-
-			-- is this child an inline group? if so, traverse into it
-			if v.type=="group" and pickfirstset(v.cmdInline, v.inline, false) then
-				info[depth+1] = k
-				if handle(info, inputpos, v, depth+1, true)==false then
-					info[depth+1] = nil
-					-- wasn't found in there, but that's ok, we just keep looking down here
-				else
-					return	-- done, name was found in inline group
-				end
-			-- matching name and not a inline group
-			elseif strlower(arg)==strlower(k:gsub(" ", "_")) then
-				info[depth+1] = k
-				return handle(info,nextpos,v,depth+1)
-			end
-		end
-
-		-- no match
-		if retfalse then
-			-- restore old infotable members and return false to indicate failure
-			info.handler,info.handler_at = oldhandler,oldhandler_at
-			info.set,info.set_at = oldset,oldset_at
-			info.get,info.get_at = oldget,oldget_at
-			info.func,info.func_at = oldfunc,oldfunc_at
-			info.validate,info.validate_at = oldvalidate,oldvalidate_at
-			--info.confirm,info.confirm_at = oldconfirm,oldconfirm_at
-			return false
-		end
-
-		-- couldn't find the command, display error
-		usererr(info, inputpos, "'"..arg.."' - " .. L["unknown argument"])
-		return
-	end
-
-	local strInput = strsub(info.input,inputpos);
-
-	if tab.type=="execute" then
-		------------ execute --------------------------------------------
-		do_final(info, inputpos, tab, "func")
-
-
-
-	elseif tab.type=="input" then
-		------------ input --------------------------------------------
-
-		local res = true
-		if tab.pattern then
-			if type(tab.pattern)~="string" then err(info, inputpos, "'pattern' - expected a string") end
-			if not strmatch(strInput, tab.pattern) then
-				usererr(info, inputpos, "'"..strInput.."' - " .. L["invalid input"])
-				return
-			end
-		end
-
-		do_final(info, inputpos, tab, "set", strInput)
-
-
-
-	elseif tab.type=="toggle" then
-		------------ toggle --------------------------------------------
-		local b
-		local str = strtrim(strlower(strInput))
-		if str=="" then
-			b = callmethod(info, inputpos, tab, "get")
-
-			if tab.tristate then
-				--cycle in true, nil, false order
-				if b then
-					b = nil
-				elseif b == nil then
-					b = false
-				else
-					b = true
-				end
-			else
-				b = not b
-			end
-
-		elseif str==L["on"] then
-			b = true
-		elseif str==L["off"] then
-			b = false
-		elseif tab.tristate and str==L["default"] then
-			b = nil
-		else
-			if tab.tristate then
-				usererr(info, inputpos, format(L["'%s' - expected 'on', 'off' or 'default', or no argument to toggle."], str))
-			else
-				usererr(info, inputpos, format(L["'%s' - expected 'on' or 'off', or no argument to toggle."], str))
-			end
-			return
-		end
-
-		do_final(info, inputpos, tab, "set", b)
-
-
-	elseif tab.type=="range" then
-		------------ range --------------------------------------------
-		local val = tonumber(strInput)
-		if not val then
-			usererr(info, inputpos, "'"..strInput.."' - "..L["expected number"])
-			return
-		end
-		if type(info.step)=="number" then
-			val = val- (val % info.step)
-		end
-		if type(info.min)=="number" and val<info.min then
-			usererr(info, inputpos, val.." - "..format(L["must be equal to or higher than %s"], tostring(info.min)) )
-			return
-		end
-		if type(info.max)=="number" and val>info.max then
-			usererr(info, inputpos, val.." - "..format(L["must be equal to or lower than %s"], tostring(info.max)) )
-			return
-		end
-
-		do_final(info, inputpos, tab, "set", val)
-
-
-	elseif tab.type=="select" then
-		------------ select ------------------------------------
-		local str = strtrim(strlower(strInput))
-
-		local values = tab.values
-		if type(values) == "function" or type(values) == "string" then
-			info.values = values
-			values = callmethod(info, inputpos, tab, "values")
-			info.values = nil
-		end
-
-		if str == "" then
-			local b = callmethod(info, inputpos, tab, "get")
-			local fmt = "|cffffff78- [%s]|r %s"
-			local fmt_sel = "|cffffff78- [%s]|r %s |cffff0000*|r"
-			print(L["Options for |cffffff78"..info[#info].."|r:"])
-			for k, v in pairs(values) do
-				if b == k then
-					print(fmt_sel:format(k, v))
-				else
-					print(fmt:format(k, v))
-				end
-			end
-			return
-		end
-
-		local ok
-		for k,v in pairs(values) do
-			if strlower(k)==str then
-				str = k	-- overwrite with key (in case of case mismatches)
-				ok = true
-				break
-			end
-		end
-		if not ok then
-			usererr(info, inputpos, "'"..str.."' - "..L["unknown selection"])
-			return
-		end
-
-		do_final(info, inputpos, tab, "set", str)
-
-	elseif tab.type=="multiselect" then
-		------------ multiselect -------------------------------------------
-		local str = strtrim(strlower(strInput))
-
-		local values = tab.values
-		if type(values) == "function" or type(values) == "string" then
-			info.values = values
-			values = callmethod(info, inputpos, tab, "values")
-			info.values = nil
-		end
-
-		if str == "" then
-			local fmt = "|cffffff78- [%s]|r %s"
-			local fmt_sel = "|cffffff78- [%s]|r %s |cffff0000*|r"
-			print(L["Options for |cffffff78"..info[#info].."|r (multiple possible):"])
-			for k, v in pairs(values) do
-				if callmethod(info, inputpos, tab, "get", k) then
-					print(fmt_sel:format(k, v))
-				else
-					print(fmt:format(k, v))
-				end
-			end
-			return
-		end
-
-		--build a table of the selections, checking that they exist
-		--parse for =on =off =default in the process
-		--table will be key = true for options that should toggle, key = [on|off|default] for options to be set
-		local sels = {}
-		for v in str:gmatch("[^ ]+") do
-			--parse option=on etc
-			local opt, val = v:match('(.+)=(.+)')
-			--get option if toggling
-			if not opt then
-				opt = v
-			end
-
-			--check that the opt is valid
-			local ok
-			for k in pairs(values) do
-				if strlower(k)==opt then
-					opt = k	-- overwrite with key (in case of case mismatches)
-					ok = true
-					break
-				end
-			end
-
-			if not ok then
-				usererr(info, inputpos, "'"..opt.."' - "..L["unknown selection"])
-				return
-			end
-
-			--check that if val was supplied it is valid
-			if val then
-				if val == L["on"] or val == L["off"] or (tab.tristate and val == L["default"]) then
-					--val is valid insert it
-					sels[opt] = val
-				else
-					if tab.tristate then
-						usererr(info, inputpos, format(L["'%s' '%s' - expected 'on', 'off' or 'default', or no argument to toggle."], v, val))
-					else
-						usererr(info, inputpos, format(L["'%s' '%s' - expected 'on' or 'off', or no argument to toggle."], v, val))
-					end
-					return
-				end
-			else
-				-- no val supplied, toggle
-				sels[opt] = true
-			end
-		end
-
-		for opt, val in pairs(sels) do
-			local newval
-
-			if (val == true) then
-				--toggle the option
-				local b = callmethod(info, inputpos, tab, "get", opt)
-
-				if tab.tristate then
-					--cycle in true, nil, false order
-					if b then
-						b = nil
-					elseif b == nil then
-						b = false
-					else
-						b = true
-					end
-				else
-					b = not b
-				end
-				newval = b
-			else
-				--set the option as specified
-				if val==L["on"] then
-					newval = true
-				elseif val==L["off"] then
-					newval = false
-				elseif val==L["default"] then
-					newval = nil
-				end
-			end
-
-			do_final(info, inputpos, tab, "set", opt, newval)
-		end
-
-
-	elseif tab.type=="color" then
-		------------ color --------------------------------------------
-		local str = strtrim(strlower(strInput))
-		if str == "" then
-			--TODO: Show current value
-			return
-		end
-
-		local r, g, b, a
-
-		local hasAlpha = tab.hasAlpha
-		if type(hasAlpha) == "function" or type(hasAlpha) == "string" then
-			info.hasAlpha = hasAlpha
-			hasAlpha = callmethod(info, inputpos, tab, 'hasAlpha')
-			info.hasAlpha = nil
-		end
-
-		if hasAlpha then
-			if str:len() == 8 and str:find("^%x*$")  then
-				--parse a hex string
-				r,g,b,a = tonumber(str:sub(1, 2), 16) / 255, tonumber(str:sub(3, 4), 16) / 255, tonumber(str:sub(5, 6), 16) / 255, tonumber(str:sub(7, 8), 16) / 255
-			else
-				--parse seperate values
-				r,g,b,a = str:match("^([%d%.]+) ([%d%.]+) ([%d%.]+) ([%d%.]+)$")
-				r,g,b,a = tonumber(r), tonumber(g), tonumber(b), tonumber(a)
-			end
-			if not (r and g and b and a) then
-				usererr(info, inputpos, format(L["'%s' - expected 'RRGGBBAA' or 'r g b a'."], str))
-				return
-			end
-
-			if r >= 0.0 and r <= 1.0 and g >= 0.0 and g <= 1.0 and b >= 0.0 and b <= 1.0 and a >= 0.0 and a <= 1.0 then
-				--values are valid
-			elseif r >= 0 and r <= 255 and g >= 0 and g <= 255 and b >= 0 and b <= 255 and a >= 0 and a <= 255 then
-				--values are valid 0..255, convert to 0..1
-				r = r / 255
-				g = g / 255
-				b = b / 255
-				a = a / 255
-			else
-				--values are invalid
-				usererr(info, inputpos, format(L["'%s' - values must all be either in the range 0..1 or 0..255."], str))
-			end
-		else
-			a = 1.0
-			if str:len() == 6 and str:find("^%x*$") then
-				--parse a hex string
-				r,g,b = tonumber(str:sub(1, 2), 16) / 255, tonumber(str:sub(3, 4), 16) / 255, tonumber(str:sub(5, 6), 16) / 255
-			else
-				--parse seperate values
-				r,g,b = str:match("^([%d%.]+) ([%d%.]+) ([%d%.]+)$")
-				r,g,b = tonumber(r), tonumber(g), tonumber(b)
-			end
-			if not (r and g and b) then
-				usererr(info, inputpos, format(L["'%s' - expected 'RRGGBB' or 'r g b'."], str))
-				return
-			end
-			if r >= 0.0 and r <= 1.0 and g >= 0.0 and g <= 1.0 and b >= 0.0 and b <= 1.0 then
-				--values are valid
-			elseif r >= 0 and r <= 255 and g >= 0 and g <= 255 and b >= 0 and b <= 255 then
-				--values are valid 0..255, convert to 0..1
-				r = r / 255
-				g = g / 255
-				b = b / 255
-			else
-				--values are invalid
-				usererr(info, inputpos, format(L["'%s' - values must all be either in the range 0-1 or 0-255."], str))
-			end
-		end
-
-		do_final(info, inputpos, tab, "set", r,g,b,a)
-
-	elseif tab.type=="keybinding" then
-		------------ keybinding --------------------------------------------
-		local str = strtrim(strlower(strInput))
-		if str == "" then
-			--TODO: Show current value
-			return
-		end
-		local value = keybindingValidateFunc(str:upper())
-		if value == false then
-			usererr(info, inputpos, format(L["'%s' - Invalid Keybinding."], str))
-			return
-		end
-
-		do_final(info, inputpos, tab, "set", value)
-
-	elseif tab.type=="description" then
-		------------ description --------------------
-		-- ignore description, GUI config only
-	else
-		err(info, inputpos, "unknown options table item type '"..tostring(tab.type).."'")
-	end
-end
-
---- Handle the chat command.
--- This is usually called from a chat command handler to parse the command input as operations on an aceoptions table.\\
--- AceConfigCmd uses this function internally when a slash command is registered with `:CreateChatCommand`
--- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
--- @param appName The application name as given to `:RegisterOptionsTable()`
--- @param input The commandline input (as given by the WoW handler, i.e. without the command itself)
--- @usage
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceConsole-3.0")
--- -- Use AceConsole-3.0 to register a Chat Command
--- MyAddon:RegisterChatCommand("mychat", "ChatCommand")
---
--- -- Show the GUI if no input is supplied, otherwise handle the chat input.
--- function MyAddon:ChatCommand(input)
---   -- Assuming "MyOptions" is the appName of a valid options table
---   if not input or input:trim() == "" then
---     LibStub("AceConfigDialog-3.0"):Open("MyOptions")
---   else
---     LibStub("AceConfigCmd-3.0").HandleCommand(MyAddon, "mychat", "MyOptions", input)
---   end
--- end
-function AceConfigCmd:HandleCommand(slashcmd, appName, input)
-
-	local optgetter = cfgreg:GetOptionsTable(appName)
-	if not optgetter then
-		error([[Usage: HandleCommand("slashcmd", "appName", "input"): 'appName' - no options table "]]..tostring(appName)..[[" has been registered]], 2)
-	end
-	local options = assert( optgetter("cmd", MAJOR) )
-
-	local info = {   -- Don't try to recycle this, it gets handed off to callbacks and whatnot
-		[0] = slashcmd,
-		appName = appName,
-		options = options,
-		input = input,
-		self = self,
-		handler = self,
-		uiType = "cmd",
-		uiName = MAJOR,
-	}
-
-	handle(info, 1, options, 0)  -- (info, inputpos, table, depth)
-end
-
---- Utility function to create a slash command handler.
--- Also registers tab completion with AceTab
--- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
--- @param appName The application name as given to `:RegisterOptionsTable()`
-function AceConfigCmd:CreateChatCommand(slashcmd, appName)
-	if not AceConsole then
-		AceConsole = LibStub(AceConsoleName)
-	end
-	if AceConsole.RegisterChatCommand(self, slashcmd, function(input)
-				AceConfigCmd.HandleCommand(self, slashcmd, appName, input)	-- upgradable
-		end,
-	true) then -- succesfully registered so lets get the command -> app table in
-		commands[slashcmd] = appName
-	end
-end
-
---- Utility function that returns the options table that belongs to a slashcommand.
--- Designed to be used for the AceTab interface.
--- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
--- @return The options table associated with the slash command (or nil if the slash command was not registered)
-function AceConfigCmd:GetChatCommandOptions(slashcmd)
-	return commands[slashcmd]
-end
+--- AceConfigCmd-3.0 handles access to an options table through the "command line" interface via the ChatFrames.
+-- @class file
+-- @name AceConfigCmd-3.0
+-- @release $Id: AceConfigCmd-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
+
+--[[
+AceConfigCmd-3.0
+
+Handles commandline optionstable access
+
+REQUIRES: AceConsole-3.0 for command registration (loaded on demand)
+
+]]
+
+-- TODO: plugin args
+
+local cfgreg = LibStub("AceConfigRegistry-3.0")
+
+local MAJOR, MINOR = "AceConfigCmd-3.0", 14
+local AceConfigCmd = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceConfigCmd then return end
+
+AceConfigCmd.commands = AceConfigCmd.commands or {}
+local commands = AceConfigCmd.commands
+
+local AceConsole -- LoD
+local AceConsoleName = "AceConsole-3.0"
+
+-- Lua APIs
+local strsub, strsplit, strlower, strmatch, strtrim = string.sub, string.split, string.lower, string.match, string.trim
+local format, tonumber, tostring = string.format, tonumber, tostring
+local tsort, tinsert = table.sort, table.insert
+local select, pairs, next, type = select, pairs, next, type
+local error, assert = error, assert
+
+-- WoW APIs
+local _G = _G
+
+local L = setmetatable({}, {	-- TODO: replace with proper locale
+	__index = function(self,k) return k end
+})
+
+local function print(msg)
+	(SELECTED_CHAT_FRAME or DEFAULT_CHAT_FRAME):AddMessage(msg)
+end
+
+-- constants used by getparam() calls below
+
+local handlertypes = {["table"]=true}
+local handlermsg = "expected a table"
+
+local functypes = {["function"]=true, ["string"]=true}
+local funcmsg = "expected function or member name"
+
+
+-- pickfirstset() - picks the first non-nil value and returns it
+
+local function pickfirstset(...)
+	for i=1,select("#",...) do
+		if select(i,...)~=nil then
+			return select(i,...)
+		end
+	end
+end
+
+
+-- err() - produce real error() regarding malformed options tables etc
+
+local function err(info,inputpos,msg )
+	local cmdstr=" "..strsub(info.input, 1, inputpos-1)
+	error(MAJOR..": /" ..info[0] ..cmdstr ..": "..(msg or "malformed options table"), 2)
+end
+
+
+-- usererr() - produce chatframe message regarding bad slash syntax etc
+
+local function usererr(info,inputpos,msg )
+	local cmdstr=strsub(info.input, 1, inputpos-1);
+	print("/" ..info[0] .. " "..cmdstr ..": "..(msg or "malformed options table"))
+end
+
+
+-- callmethod() - call a given named method (e.g. "get", "set") with given arguments
+
+local function callmethod(info, inputpos, tab, methodtype, ...)
+	local method = info[methodtype]
+	if not method then
+		err(info, inputpos, "'"..methodtype.."': not set")
+	end
+
+	info.arg = tab.arg
+	info.option = tab
+	info.type = tab.type
+
+	if type(method)=="function" then
+		return method(info, ...)
+	elseif type(method)=="string" then
+		if type(info.handler[method])~="function" then
+			err(info, inputpos, "'"..methodtype.."': '"..method.."' is not a member function of "..tostring(info.handler))
+		end
+		return info.handler[method](info.handler, info, ...)
+	else
+		assert(false)	-- type should have already been checked on read
+	end
+end
+
+-- callfunction() - call a given named function (e.g. "name", "desc") with given arguments
+
+local function callfunction(info, tab, methodtype, ...)
+	local method = tab[methodtype]
+
+	info.arg = tab.arg
+	info.option = tab
+	info.type = tab.type
+
+	if type(method)=="function" then
+		return method(info, ...)
+	else
+		assert(false) -- type should have already been checked on read
+	end
+end
+
+-- do_final() - do the final step (set/execute) along with validation and confirmation
+
+local function do_final(info, inputpos, tab, methodtype, ...)
+	if info.validate then
+		local res = callmethod(info,inputpos,tab,"validate",...)
+		if type(res)=="string" then
+			usererr(info, inputpos, "'"..strsub(info.input, inputpos).."' - "..res)
+			return
+		end
+	end
+	-- console ignores .confirm
+
+	callmethod(info,inputpos,tab,methodtype, ...)
+end
+
+
+-- getparam() - used by handle() to retreive and store "handler", "get", "set", etc
+
+local function getparam(info, inputpos, tab, depth, paramname, types, errormsg)
+	local old,oldat = info[paramname], info[paramname.."_at"]
+	local val=tab[paramname]
+	if val~=nil then
+		if val==false then
+			val=nil
+		elseif not types[type(val)] then
+			err(info, inputpos, "'" .. paramname.. "' - "..errormsg)
+		end
+		info[paramname] = val
+		info[paramname.."_at"] = depth
+	end
+	return old,oldat
+end
+
+
+-- iterateargs(tab) - custom iterator that iterates both t.args and t.plugins.*
+local dummytable={}
+
+local function iterateargs(tab)
+	if not tab.plugins then
+		return pairs(tab.args)
+	end
+
+	local argtabkey,argtab=next(tab.plugins)
+	local v
+
+	return function(_, k)
+		while argtab do
+			k,v = next(argtab, k)
+			if k then return k,v end
+			if argtab==tab.args then
+				argtab=nil
+			else
+				argtabkey,argtab = next(tab.plugins, argtabkey)
+				if not argtabkey then
+					argtab=tab.args
+				end
+			end
+		end
+	end
+end
+
+local function checkhidden(info, inputpos, tab)
+	if tab.cmdHidden~=nil then
+		return tab.cmdHidden
+	end
+	local hidden = tab.hidden
+	if type(hidden) == "function" or type(hidden) == "string" then
+		info.hidden = hidden
+		hidden = callmethod(info, inputpos, tab, 'hidden')
+		info.hidden = nil
+	end
+	return hidden
+end
+
+local function showhelp(info, inputpos, tab, depth, noHead)
+	if not noHead then
+		print("|cff33ff99"..info.appName.."|r: Arguments to |cffffff78/"..info[0].."|r "..strsub(info.input,1,inputpos-1)..":")
+	end
+
+	local sortTbl = {}	-- [1..n]=name
+	local refTbl = {}   -- [name]=tableref
+
+	for k,v in iterateargs(tab) do
+		if not refTbl[k] then	-- a plugin overriding something in .args
+			tinsert(sortTbl, k)
+			refTbl[k] = v
+		end
+	end
+
+	tsort(sortTbl, function(one, two)
+		local o1 = refTbl[one].order or 100
+		local o2 = refTbl[two].order or 100
+		if type(o1) == "function" or type(o1) == "string" then
+			info.order = o1
+			info[#info+1] = one
+			o1 = callmethod(info, inputpos, refTbl[one], "order")
+			info[#info] = nil
+			info.order = nil
+		end
+		if type(o2) == "function" or type(o1) == "string" then
+			info.order = o2
+			info[#info+1] = two
+			o2 = callmethod(info, inputpos, refTbl[two], "order")
+			info[#info] = nil
+			info.order = nil
+		end
+		if o1<0 and o2<0 then return o1<o2 end
+		if o2<0 then return true end
+		if o1<0 then return false end
+		if o1==o2 then return tostring(one)<tostring(two) end   -- compare names
+		return o1<o2
+	end)
+
+	for i = 1, #sortTbl do
+		local k = sortTbl[i]
+		local v = refTbl[k]
+		if not checkhidden(info, inputpos, v) then
+			if v.type ~= "description" and v.type ~= "header" then
+				-- recursively show all inline groups
+				local name, desc = v.name, v.desc
+				if type(name) == "function" then
+					name = callfunction(info, v, 'name')
+				end
+				if type(desc) == "function" then
+					desc = callfunction(info, v, 'desc')
+				end
+				if v.type == "group" and pickfirstset(v.cmdInline, v.inline, false) then
+					print("  "..(desc or name)..":")
+					local oldhandler,oldhandler_at = getparam(info, inputpos, v, depth, "handler", handlertypes, handlermsg)
+					showhelp(info, inputpos, v, depth, true)
+					info.handler,info.handler_at = oldhandler,oldhandler_at
+				else
+					local key = k:gsub(" ", "_")
+					print("  |cffffff78"..key.."|r - "..(desc or name or ""))
+				end
+			end
+		end
+	end
+end
+
+
+local function keybindingValidateFunc(text)
+	if text == nil or text == "NONE" then
+		return nil
+	end
+	text = text:upper()
+	local shift, ctrl, alt
+	local modifier
+	while true do
+		if text == "-" then
+			break
+		end
+		modifier, text = strsplit('-', text, 2)
+		if text then
+			if modifier ~= "SHIFT" and modifier ~= "CTRL" and modifier ~= "ALT" then
+				return false
+			end
+			if modifier == "SHIFT" then
+				if shift then
+					return false
+				end
+				shift = true
+			end
+			if modifier == "CTRL" then
+				if ctrl then
+					return false
+				end
+				ctrl = true
+			end
+			if modifier == "ALT" then
+				if alt then
+					return false
+				end
+				alt = true
+			end
+		else
+			text = modifier
+			break
+		end
+	end
+	if text == "" then
+		return false
+	end
+	if not text:find("^F%d+$") and text ~= "CAPSLOCK" and text:len() ~= 1 and (text:byte() < 128 or text:len() > 4) and not _G["KEY_" .. text] then
+		return false
+	end
+	local s = text
+	if shift then
+		s = "SHIFT-" .. s
+	end
+	if ctrl then
+		s = "CTRL-" .. s
+	end
+	if alt then
+		s = "ALT-" .. s
+	end
+	return s
+end
+
+-- handle() - selfrecursing function that processes input->optiontable
+-- - depth - starts at 0
+-- - retfalse - return false rather than produce error if a match is not found (used by inlined groups)
+
+local function handle(info, inputpos, tab, depth, retfalse)
+
+	if not(type(tab)=="table" and type(tab.type)=="string") then err(info,inputpos) end
+
+	-------------------------------------------------------------------
+	-- Grab hold of handler,set,get,func,etc if set (and remember old ones)
+	-- Note that we do NOT validate if method names are correct at this stage,
+	-- the handler may change before they're actually used!
+
+	local oldhandler,oldhandler_at = getparam(info,inputpos,tab,depth,"handler",handlertypes,handlermsg)
+	local oldset,oldset_at = getparam(info,inputpos,tab,depth,"set",functypes,funcmsg)
+	local oldget,oldget_at = getparam(info,inputpos,tab,depth,"get",functypes,funcmsg)
+	local oldfunc,oldfunc_at = getparam(info,inputpos,tab,depth,"func",functypes,funcmsg)
+	local oldvalidate,oldvalidate_at = getparam(info,inputpos,tab,depth,"validate",functypes,funcmsg)
+	--local oldconfirm,oldconfirm_at = getparam(info,inputpos,tab,depth,"confirm",functypes,funcmsg)
+
+	-------------------------------------------------------------------
+	-- Act according to .type of this table
+
+	if tab.type=="group" then
+		------------ group --------------------------------------------
+
+		if type(tab.args)~="table" then err(info, inputpos) end
+		if tab.plugins and type(tab.plugins)~="table" then err(info,inputpos) end
+
+		-- grab next arg from input
+		local _,nextpos,arg = (info.input):find(" *([^ ]+) *", inputpos)
+		if not arg then
+			showhelp(info, inputpos, tab, depth)
+			return
+		end
+		nextpos=nextpos+1
+
+		-- loop .args and try to find a key with a matching name
+		for k,v in iterateargs(tab) do
+			if not(type(k)=="string" and type(v)=="table" and type(v.type)=="string") then err(info,inputpos, "options table child '"..tostring(k).."' is malformed") end
+
+			-- is this child an inline group? if so, traverse into it
+			if v.type=="group" and pickfirstset(v.cmdInline, v.inline, false) then
+				info[depth+1] = k
+				if handle(info, inputpos, v, depth+1, true)==false then
+					info[depth+1] = nil
+					-- wasn't found in there, but that's ok, we just keep looking down here
+				else
+					return	-- done, name was found in inline group
+				end
+			-- matching name and not a inline group
+			elseif strlower(arg)==strlower(k:gsub(" ", "_")) then
+				info[depth+1] = k
+				return handle(info,nextpos,v,depth+1)
+			end
+		end
+
+		-- no match
+		if retfalse then
+			-- restore old infotable members and return false to indicate failure
+			info.handler,info.handler_at = oldhandler,oldhandler_at
+			info.set,info.set_at = oldset,oldset_at
+			info.get,info.get_at = oldget,oldget_at
+			info.func,info.func_at = oldfunc,oldfunc_at
+			info.validate,info.validate_at = oldvalidate,oldvalidate_at
+			--info.confirm,info.confirm_at = oldconfirm,oldconfirm_at
+			return false
+		end
+
+		-- couldn't find the command, display error
+		usererr(info, inputpos, "'"..arg.."' - " .. L["unknown argument"])
+		return
+	end
+
+	local strInput = strsub(info.input,inputpos);
+
+	if tab.type=="execute" then
+		------------ execute --------------------------------------------
+		do_final(info, inputpos, tab, "func")
+
+
+
+	elseif tab.type=="input" then
+		------------ input --------------------------------------------
+
+		local res = true
+		if tab.pattern then
+			if type(tab.pattern)~="string" then err(info, inputpos, "'pattern' - expected a string") end
+			if not strmatch(strInput, tab.pattern) then
+				usererr(info, inputpos, "'"..strInput.."' - " .. L["invalid input"])
+				return
+			end
+		end
+
+		do_final(info, inputpos, tab, "set", strInput)
+
+
+
+	elseif tab.type=="toggle" then
+		------------ toggle --------------------------------------------
+		local b
+		local str = strtrim(strlower(strInput))
+		if str=="" then
+			b = callmethod(info, inputpos, tab, "get")
+
+			if tab.tristate then
+				--cycle in true, nil, false order
+				if b then
+					b = nil
+				elseif b == nil then
+					b = false
+				else
+					b = true
+				end
+			else
+				b = not b
+			end
+
+		elseif str==L["on"] then
+			b = true
+		elseif str==L["off"] then
+			b = false
+		elseif tab.tristate and str==L["default"] then
+			b = nil
+		else
+			if tab.tristate then
+				usererr(info, inputpos, format(L["'%s' - expected 'on', 'off' or 'default', or no argument to toggle."], str))
+			else
+				usererr(info, inputpos, format(L["'%s' - expected 'on' or 'off', or no argument to toggle."], str))
+			end
+			return
+		end
+
+		do_final(info, inputpos, tab, "set", b)
+
+
+	elseif tab.type=="range" then
+		------------ range --------------------------------------------
+		local val = tonumber(strInput)
+		if not val then
+			usererr(info, inputpos, "'"..strInput.."' - "..L["expected number"])
+			return
+		end
+		if type(info.step)=="number" then
+			val = val- (val % info.step)
+		end
+		if type(info.min)=="number" and val<info.min then
+			usererr(info, inputpos, val.." - "..format(L["must be equal to or higher than %s"], tostring(info.min)) )
+			return
+		end
+		if type(info.max)=="number" and val>info.max then
+			usererr(info, inputpos, val.." - "..format(L["must be equal to or lower than %s"], tostring(info.max)) )
+			return
+		end
+
+		do_final(info, inputpos, tab, "set", val)
+
+
+	elseif tab.type=="select" then
+		------------ select ------------------------------------
+		local str = strtrim(strlower(strInput))
+
+		local values = tab.values
+		if type(values) == "function" or type(values) == "string" then
+			info.values = values
+			values = callmethod(info, inputpos, tab, "values")
+			info.values = nil
+		end
+
+		if str == "" then
+			local b = callmethod(info, inputpos, tab, "get")
+			local fmt = "|cffffff78- [%s]|r %s"
+			local fmt_sel = "|cffffff78- [%s]|r %s |cffff0000*|r"
+			print(L["Options for |cffffff78"..info[#info].."|r:"])
+			for k, v in pairs(values) do
+				if b == k then
+					print(fmt_sel:format(k, v))
+				else
+					print(fmt:format(k, v))
+				end
+			end
+			return
+		end
+
+		local ok
+		for k,v in pairs(values) do
+			if strlower(k)==str then
+				str = k	-- overwrite with key (in case of case mismatches)
+				ok = true
+				break
+			end
+		end
+		if not ok then
+			usererr(info, inputpos, "'"..str.."' - "..L["unknown selection"])
+			return
+		end
+
+		do_final(info, inputpos, tab, "set", str)
+
+	elseif tab.type=="multiselect" then
+		------------ multiselect -------------------------------------------
+		local str = strtrim(strlower(strInput))
+
+		local values = tab.values
+		if type(values) == "function" or type(values) == "string" then
+			info.values = values
+			values = callmethod(info, inputpos, tab, "values")
+			info.values = nil
+		end
+
+		if str == "" then
+			local fmt = "|cffffff78- [%s]|r %s"
+			local fmt_sel = "|cffffff78- [%s]|r %s |cffff0000*|r"
+			print(L["Options for |cffffff78"..info[#info].."|r (multiple possible):"])
+			for k, v in pairs(values) do
+				if callmethod(info, inputpos, tab, "get", k) then
+					print(fmt_sel:format(k, v))
+				else
+					print(fmt:format(k, v))
+				end
+			end
+			return
+		end
+
+		--build a table of the selections, checking that they exist
+		--parse for =on =off =default in the process
+		--table will be key = true for options that should toggle, key = [on|off|default] for options to be set
+		local sels = {}
+		for v in str:gmatch("[^ ]+") do
+			--parse option=on etc
+			local opt, val = v:match('(.+)=(.+)')
+			--get option if toggling
+			if not opt then
+				opt = v
+			end
+
+			--check that the opt is valid
+			local ok
+			for k in pairs(values) do
+				if strlower(k)==opt then
+					opt = k	-- overwrite with key (in case of case mismatches)
+					ok = true
+					break
+				end
+			end
+
+			if not ok then
+				usererr(info, inputpos, "'"..opt.."' - "..L["unknown selection"])
+				return
+			end
+
+			--check that if val was supplied it is valid
+			if val then
+				if val == L["on"] or val == L["off"] or (tab.tristate and val == L["default"]) then
+					--val is valid insert it
+					sels[opt] = val
+				else
+					if tab.tristate then
+						usererr(info, inputpos, format(L["'%s' '%s' - expected 'on', 'off' or 'default', or no argument to toggle."], v, val))
+					else
+						usererr(info, inputpos, format(L["'%s' '%s' - expected 'on' or 'off', or no argument to toggle."], v, val))
+					end
+					return
+				end
+			else
+				-- no val supplied, toggle
+				sels[opt] = true
+			end
+		end
+
+		for opt, val in pairs(sels) do
+			local newval
+
+			if (val == true) then
+				--toggle the option
+				local b = callmethod(info, inputpos, tab, "get", opt)
+
+				if tab.tristate then
+					--cycle in true, nil, false order
+					if b then
+						b = nil
+					elseif b == nil then
+						b = false
+					else
+						b = true
+					end
+				else
+					b = not b
+				end
+				newval = b
+			else
+				--set the option as specified
+				if val==L["on"] then
+					newval = true
+				elseif val==L["off"] then
+					newval = false
+				elseif val==L["default"] then
+					newval = nil
+				end
+			end
+
+			do_final(info, inputpos, tab, "set", opt, newval)
+		end
+
+
+	elseif tab.type=="color" then
+		------------ color --------------------------------------------
+		local str = strtrim(strlower(strInput))
+		if str == "" then
+			--TODO: Show current value
+			return
+		end
+
+		local r, g, b, a
+
+		local hasAlpha = tab.hasAlpha
+		if type(hasAlpha) == "function" or type(hasAlpha) == "string" then
+			info.hasAlpha = hasAlpha
+			hasAlpha = callmethod(info, inputpos, tab, 'hasAlpha')
+			info.hasAlpha = nil
+		end
+
+		if hasAlpha then
+			if str:len() == 8 and str:find("^%x*$")  then
+				--parse a hex string
+				r,g,b,a = tonumber(str:sub(1, 2), 16) / 255, tonumber(str:sub(3, 4), 16) / 255, tonumber(str:sub(5, 6), 16) / 255, tonumber(str:sub(7, 8), 16) / 255
+			else
+				--parse seperate values
+				r,g,b,a = str:match("^([%d%.]+) ([%d%.]+) ([%d%.]+) ([%d%.]+)$")
+				r,g,b,a = tonumber(r), tonumber(g), tonumber(b), tonumber(a)
+			end
+			if not (r and g and b and a) then
+				usererr(info, inputpos, format(L["'%s' - expected 'RRGGBBAA' or 'r g b a'."], str))
+				return
+			end
+
+			if r >= 0.0 and r <= 1.0 and g >= 0.0 and g <= 1.0 and b >= 0.0 and b <= 1.0 and a >= 0.0 and a <= 1.0 then
+				--values are valid
+			elseif r >= 0 and r <= 255 and g >= 0 and g <= 255 and b >= 0 and b <= 255 and a >= 0 and a <= 255 then
+				--values are valid 0..255, convert to 0..1
+				r = r / 255
+				g = g / 255
+				b = b / 255
+				a = a / 255
+			else
+				--values are invalid
+				usererr(info, inputpos, format(L["'%s' - values must all be either in the range 0..1 or 0..255."], str))
+			end
+		else
+			a = 1.0
+			if str:len() == 6 and str:find("^%x*$") then
+				--parse a hex string
+				r,g,b = tonumber(str:sub(1, 2), 16) / 255, tonumber(str:sub(3, 4), 16) / 255, tonumber(str:sub(5, 6), 16) / 255
+			else
+				--parse seperate values
+				r,g,b = str:match("^([%d%.]+) ([%d%.]+) ([%d%.]+)$")
+				r,g,b = tonumber(r), tonumber(g), tonumber(b)
+			end
+			if not (r and g and b) then
+				usererr(info, inputpos, format(L["'%s' - expected 'RRGGBB' or 'r g b'."], str))
+				return
+			end
+			if r >= 0.0 and r <= 1.0 and g >= 0.0 and g <= 1.0 and b >= 0.0 and b <= 1.0 then
+				--values are valid
+			elseif r >= 0 and r <= 255 and g >= 0 and g <= 255 and b >= 0 and b <= 255 then
+				--values are valid 0..255, convert to 0..1
+				r = r / 255
+				g = g / 255
+				b = b / 255
+			else
+				--values are invalid
+				usererr(info, inputpos, format(L["'%s' - values must all be either in the range 0-1 or 0-255."], str))
+			end
+		end
+
+		do_final(info, inputpos, tab, "set", r,g,b,a)
+
+	elseif tab.type=="keybinding" then
+		------------ keybinding --------------------------------------------
+		local str = strtrim(strlower(strInput))
+		if str == "" then
+			--TODO: Show current value
+			return
+		end
+		local value = keybindingValidateFunc(str:upper())
+		if value == false then
+			usererr(info, inputpos, format(L["'%s' - Invalid Keybinding."], str))
+			return
+		end
+
+		do_final(info, inputpos, tab, "set", value)
+
+	elseif tab.type=="description" then
+		------------ description --------------------
+		-- ignore description, GUI config only
+	else
+		err(info, inputpos, "unknown options table item type '"..tostring(tab.type).."'")
+	end
+end
+
+--- Handle the chat command.
+-- This is usually called from a chat command handler to parse the command input as operations on an aceoptions table.\\
+-- AceConfigCmd uses this function internally when a slash command is registered with `:CreateChatCommand`
+-- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+-- @param input The commandline input (as given by the WoW handler, i.e. without the command itself)
+-- @usage
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceConsole-3.0")
+-- -- Use AceConsole-3.0 to register a Chat Command
+-- MyAddon:RegisterChatCommand("mychat", "ChatCommand")
+--
+-- -- Show the GUI if no input is supplied, otherwise handle the chat input.
+-- function MyAddon:ChatCommand(input)
+--   -- Assuming "MyOptions" is the appName of a valid options table
+--   if not input or input:trim() == "" then
+--     LibStub("AceConfigDialog-3.0"):Open("MyOptions")
+--   else
+--     LibStub("AceConfigCmd-3.0").HandleCommand(MyAddon, "mychat", "MyOptions", input)
+--   end
+-- end
+function AceConfigCmd:HandleCommand(slashcmd, appName, input)
+
+	local optgetter = cfgreg:GetOptionsTable(appName)
+	if not optgetter then
+		error([[Usage: HandleCommand("slashcmd", "appName", "input"): 'appName' - no options table "]]..tostring(appName)..[[" has been registered]], 2)
+	end
+	local options = assert( optgetter("cmd", MAJOR) )
+
+	local info = {   -- Don't try to recycle this, it gets handed off to callbacks and whatnot
+		[0] = slashcmd,
+		appName = appName,
+		options = options,
+		input = input,
+		self = self,
+		handler = self,
+		uiType = "cmd",
+		uiName = MAJOR,
+	}
+
+	handle(info, 1, options, 0)  -- (info, inputpos, table, depth)
+end
+
+--- Utility function to create a slash command handler.
+-- Also registers tab completion with AceTab
+-- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+function AceConfigCmd:CreateChatCommand(slashcmd, appName)
+	if not AceConsole then
+		AceConsole = LibStub(AceConsoleName)
+	end
+	if AceConsole.RegisterChatCommand(self, slashcmd, function(input)
+				AceConfigCmd.HandleCommand(self, slashcmd, appName, input)	-- upgradable
+		end,
+	true) then -- succesfully registered so lets get the command -> app table in
+		commands[slashcmd] = appName
+	end
+end
+
+--- Utility function that returns the options table that belongs to a slashcommand.
+-- Designed to be used for the AceTab interface.
+-- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
+-- @return The options table associated with the slash command (or nil if the slash command was not registered)
+function AceConfigCmd:GetChatCommandOptions(slashcmd)
+	return commands[slashcmd]
+end
diff --git a/Carbonite/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.xml b/Carbonite/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.xml
index c8caf34..9e157b5 100644
--- a/Carbonite/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.xml
+++ b/Carbonite/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceConfigCmd-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceConfigCmd-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.lua b/Carbonite/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.lua
index 146bb7c..11254eb 100644
--- a/Carbonite/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.lua
+++ b/Carbonite/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.lua
@@ -1,2028 +1,2028 @@
---- AceConfigDialog-3.0 generates AceGUI-3.0 based windows based on option tables.
--- @class file
--- @name AceConfigDialog-3.0
--- @release $Id: AceConfigDialog-3.0.lua 1296 2022-11-04 18:50:10Z nevcairiel $
-
-local LibStub = LibStub
-local gui = LibStub("AceGUI-3.0")
-local reg = LibStub("AceConfigRegistry-3.0")
-
-local MAJOR, MINOR = "AceConfigDialog-3.0", 86
-local AceConfigDialog, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceConfigDialog then return end
-
-AceConfigDialog.OpenFrames = AceConfigDialog.OpenFrames or {}
-AceConfigDialog.Status = AceConfigDialog.Status or {}
-AceConfigDialog.frame = AceConfigDialog.frame or CreateFrame("Frame")
-AceConfigDialog.tooltip = AceConfigDialog.tooltip or CreateFrame("GameTooltip", "AceConfigDialogTooltip", UIParent, "GameTooltipTemplate")
-
-AceConfigDialog.frame.apps = AceConfigDialog.frame.apps or {}
-AceConfigDialog.frame.closing = AceConfigDialog.frame.closing or {}
-AceConfigDialog.frame.closeAllOverride = AceConfigDialog.frame.closeAllOverride or {}
-
--- Lua APIs
-local tinsert, tsort, tremove, wipe = table.insert, table.sort, table.remove, table.wipe
-local strmatch, format = string.match, string.format
-local error = error
-local pairs, next, select, type, unpack, ipairs = pairs, next, select, type, unpack, ipairs
-local tostring, tonumber = tostring, tonumber
-local math_min, math_max, math_floor = math.min, math.max, math.floor
-
-local emptyTbl = {}
-
---[[
-	 xpcall safecall implementation
-]]
-local xpcall = xpcall
-
-local function errorhandler(err)
-	return geterrorhandler()(err)
-end
-
-local function safecall(func, ...)
-	if func then
-		return xpcall(func, errorhandler, ...)
-	end
-end
-
-local width_multiplier = 170
-
---[[
-Group Types
-  Tree 	- All Descendant Groups will all become nodes on the tree, direct child options will appear above the tree
-        - Descendant Groups with inline=true and thier children will not become nodes
-
-  Tab	- Direct Child Groups will become tabs, direct child options will appear above the tab control
-        - Grandchild groups will default to inline unless specified otherwise
-
-  Select- Same as Tab but with entries in a dropdown rather than tabs
-
-
-  Inline Groups
-    - Will not become nodes of a select group, they will be effectivly part of thier parent group seperated by a border
-    - If declared on a direct child of a root node of a select group, they will appear above the group container control
-    - When a group is displayed inline, all descendants will also be inline members of the group
-
-]]
-
--- Recycling functions
-local new, del, copy
---newcount, delcount,createdcount,cached = 0,0,0
-do
-	local pool = setmetatable({},{__mode="k"})
-	function new()
-		--newcount = newcount + 1
-		local t = next(pool)
-		if t then
-			pool[t] = nil
-			return t
-		else
-			--createdcount = createdcount + 1
-			return {}
-		end
-	end
-	function copy(t)
-		local c = new()
-		for k, v in pairs(t) do
-			c[k] = v
-		end
-		return c
-	end
-	function del(t)
-		--delcount = delcount + 1
-		wipe(t)
-		pool[t] = true
-	end
---	function cached()
---		local n = 0
---		for k in pairs(pool) do
---			n = n + 1
---		end
---		return n
---	end
-end
-
--- picks the first non-nil value and returns it
-local function pickfirstset(...)
-  for i=1,select("#",...) do
-    if select(i,...)~=nil then
-      return select(i,...)
-    end
-  end
-end
-
---gets an option from a given group, checking plugins
-local function GetSubOption(group, key)
-	if group.plugins then
-		for plugin, t in pairs(group.plugins) do
-			if t[key] then
-				return t[key]
-			end
-		end
-	end
-
-	return group.args[key]
-end
-
---Option member type definitions, used to decide how to access it
-
---Is the member Inherited from parent options
-local isInherited = {
-	set = true,
-	get = true,
-	func = true,
-	confirm = true,
-	validate = true,
-	disabled = true,
-	hidden = true
-}
-
---Does a string type mean a literal value, instead of the default of a method of the handler
-local stringIsLiteral = {
-	name = true,
-	desc = true,
-	icon = true,
-	usage = true,
-	width = true,
-	image = true,
-	fontSize = true,
-	tooltipHyperlink = true
-}
-
---Is Never a function or method
-local allIsLiteral = {
-	type = true,
-	descStyle = true,
-	imageWidth = true,
-	imageHeight = true,
-}
-
---gets the value for a member that could be a function
---function refs are called with an info arg
---every other type is returned
-local function GetOptionsMemberValue(membername, option, options, path, appName, ...)
-	--get definition for the member
-	local inherits = isInherited[membername]
-
-
-	--get the member of the option, traversing the tree if it can be inherited
-	local member
-
-	if inherits then
-		local group = options
-		if group[membername] ~= nil then
-			member = group[membername]
-		end
-		for i = 1, #path do
-			group = GetSubOption(group, path[i])
-			if group[membername] ~= nil then
-				member = group[membername]
-			end
-		end
-	else
-		member = option[membername]
-	end
-
-	--check if we need to call a functon, or if we have a literal value
-	if ( not allIsLiteral[membername] ) and ( type(member) == "function" or ((not stringIsLiteral[membername]) and type(member) == "string") ) then
-		--We have a function to call
-		local info = new()
-		--traverse the options table, picking up the handler and filling the info with the path
-		local group = options
-		local handler = group.handler
-
-		for i = 1, #path do
-			group = GetSubOption(group, path[i])
-			info[i] = path[i]
-			handler = group.handler or handler
-		end
-
-		info.options = options
-		info.appName = appName
-		info[0] = appName
-		info.arg = option.arg
-		info.handler = handler
-		info.option = option
-		info.type = option.type
-		info.uiType = "dialog"
-		info.uiName = MAJOR
-
-		local a, b, c ,d
-		--using 4 returns for the get of a color type, increase if a type needs more
-		if type(member) == "function" then
-			--Call the function
-			a,b,c,d = member(info, ...)
-		else
-			--Call the method
-			if handler and handler[member] then
-				a,b,c,d = handler[member](handler, info, ...)
-			else
-				error(format("Method %s doesn't exist in handler for type %s", member, membername))
-			end
-		end
-		del(info)
-		return a,b,c,d
-	else
-		--The value isnt a function to call, return it
-		return member
-	end
-end
-
---[[calls an options function that could be inherited, method name or function ref
-local function CallOptionsFunction(funcname ,option, options, path, appName, ...)
-	local info = new()
-
-	local func
-	local group = options
-	local handler
-
-	--build the info table containing the path
-	-- pick up functions while traversing the tree
-	if group[funcname] ~= nil then
-		func = group[funcname]
-	end
-	handler = group.handler or handler
-
-	for i, v in ipairs(path) do
-		group = GetSubOption(group, v)
-		info[i] = v
-		if group[funcname] ~= nil then
-			func =  group[funcname]
-		end
-		handler = group.handler or handler
-	end
-
-	info.options = options
-	info[0] = appName
-	info.arg = option.arg
-
-	local a, b, c ,d
-	if type(func) == "string" then
-		if handler and handler[func] then
-			a,b,c,d = handler[func](handler, info, ...)
-		else
-			error(string.format("Method %s doesn't exist in handler for type func", func))
-		end
-	elseif type(func) == "function" then
-		a,b,c,d = func(info, ...)
-	end
-	del(info)
-	return a,b,c,d
-end
---]]
-
---tables to hold orders and names for options being sorted, will be created with new()
---prevents needing to call functions repeatedly while sorting
-local tempOrders
-local tempNames
-
-local function compareOptions(a,b)
-	if not a then
-		return true
-	end
-	if not b then
-		return false
-	end
-	local OrderA, OrderB = tempOrders[a] or 100, tempOrders[b] or 100
-	if OrderA == OrderB then
-		local NameA = (type(tempNames[a]) == "string") and tempNames[a] or ""
-		local NameB = (type(tempNames[b]) == "string") and tempNames[b] or ""
-		return NameA:upper() < NameB:upper()
-	end
-	if OrderA < 0 then
-		if OrderB >= 0 then
-			return false
-		end
-	else
-		if OrderB < 0 then
-			return true
-		end
-	end
-	return OrderA < OrderB
-end
-
-
-
---builds 2 tables out of an options group
--- keySort, sorted keys
--- opts, combined options from .plugins and args
-local function BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
-	tempOrders = new()
-	tempNames = new()
-
-	if group.plugins then
-		for plugin, t in pairs(group.plugins) do
-			for k, v in pairs(t) do
-				if not opts[k] then
-					tinsert(keySort, k)
-					opts[k] = v
-
-					path[#path+1] = k
-					tempOrders[k] = GetOptionsMemberValue("order", v, options, path, appName)
-					tempNames[k] = GetOptionsMemberValue("name", v, options, path, appName)
-					path[#path] = nil
-				end
-			end
-		end
-	end
-
-	for k, v in pairs(group.args) do
-		if not opts[k] then
-			tinsert(keySort, k)
-			opts[k] = v
-
-			path[#path+1] = k
-			tempOrders[k] = GetOptionsMemberValue("order", v, options, path, appName)
-			tempNames[k] = GetOptionsMemberValue("name", v, options, path, appName)
-			path[#path] = nil
-		end
-	end
-
-	tsort(keySort, compareOptions)
-
-	del(tempOrders)
-	del(tempNames)
-end
-
-local function DelTree(tree)
-	if tree.children then
-		local childs = tree.children
-		for i = 1, #childs do
-			DelTree(childs[i])
-			del(childs[i])
-		end
-		del(childs)
-	end
-end
-
-local function CleanUserData(widget, event)
-
-	local user = widget:GetUserDataTable()
-
-	if user.path then
-		del(user.path)
-	end
-
-	if widget.type == "TreeGroup" then
-		local tree = user.tree
-		widget:SetTree(nil)
-		if tree then
-			for i = 1, #tree do
-				DelTree(tree[i])
-				del(tree[i])
-			end
-			del(tree)
-		end
-	end
-
-	if widget.type == "TabGroup" then
-		widget:SetTabs(nil)
-		if user.tablist then
-			del(user.tablist)
-		end
-	end
-
-	if widget.type == "DropdownGroup" then
-		widget:SetGroupList(nil)
-		if user.grouplist then
-			del(user.grouplist)
-		end
-		if user.orderlist then
-			del(user.orderlist)
-		end
-	end
-end
-
--- - Gets a status table for the given appname and options path.
--- @param appName The application name as given to `:RegisterOptionsTable()`
--- @param path The path to the options (a table with all group keys)
--- @return
-function AceConfigDialog:GetStatusTable(appName, path)
-	local status = self.Status
-
-	if not status[appName] then
-		status[appName] = {}
-		status[appName].status = {}
-		status[appName].children = {}
-	end
-
-	status = status[appName]
-
-	if path then
-		for i = 1, #path do
-			local v = path[i]
-			if not status.children[v] then
-				status.children[v] = {}
-				status.children[v].status = {}
-				status.children[v].children = {}
-			end
-			status = status.children[v]
-		end
-	end
-
-	return status.status
-end
-
---- Selects the specified path in the options window.
--- The path specified has to match the keys of the groups in the table.
--- @param appName The application name as given to `:RegisterOptionsTable()`
--- @param ... The path to the key that should be selected
-function AceConfigDialog:SelectGroup(appName, ...)
-	local path = new()
-
-
-	local app = reg:GetOptionsTable(appName)
-	if not app then
-		error(("%s isn't registed with AceConfigRegistry, unable to open config"):format(appName), 2)
-	end
-	local options = app("dialog", MAJOR)
-	local group = options
-	local status = self:GetStatusTable(appName, path)
-	if not status.groups then
-		status.groups = {}
-	end
-	status = status.groups
-	local treevalue
-	local treestatus
-
-	for n = 1, select("#",...) do
-		local key = select(n, ...)
-
-		if group.childGroups == "tab" or group.childGroups == "select" then
-			--if this is a tab or select group, select the group
-			status.selected = key
-			--children of this group are no longer extra levels of a tree
-			treevalue = nil
-		else
-			--tree group by default
-			if treevalue then
-				--this is an extra level of a tree group, build a uniquevalue for it
-				treevalue = treevalue.."\001"..key
-			else
-				--this is the top level of a tree group, the uniquevalue is the same as the key
-				treevalue = key
-				if not status.groups then
-					status.groups = {}
-				end
-				--save this trees status table for any extra levels or groups
-				treestatus = status
-			end
-			--make sure that the tree entry is open, and select it.
-			--the selected group will be overwritten if a child is the final target but still needs to be open
-			treestatus.selected = treevalue
-			treestatus.groups[treevalue] = true
-
-		end
-
-		--move to the next group in the path
-		group = GetSubOption(group, key)
-		if not group then
-			break
-		end
-		tinsert(path, key)
-		status = self:GetStatusTable(appName, path)
-		if not status.groups then
-			status.groups = {}
-		end
-		status = status.groups
-	end
-
-	del(path)
-	reg:NotifyChange(appName)
-end
-
-local function OptionOnMouseOver(widget, event)
-	--show a tooltip/set the status bar to the desc text
-	local user = widget:GetUserDataTable()
-	local opt = user.option
-	local options = user.options
-	local path = user.path
-	local appName = user.appName
-	local tooltip = AceConfigDialog.tooltip
-
-	tooltip:SetOwner(widget.frame, "ANCHOR_TOPRIGHT")
-
-	local tooltipHyperlink = GetOptionsMemberValue("tooltipHyperlink", opt, options, path, appName)
-	if tooltipHyperlink then
-		tooltip:SetHyperlink(tooltipHyperlink)
-		tooltip:Show()
-		return
-	end
-
-	local name = GetOptionsMemberValue("name", opt, options, path, appName)
-	local desc = GetOptionsMemberValue("desc", opt, options, path, appName)
-	local usage = GetOptionsMemberValue("usage", opt, options, path, appName)
-	local descStyle = opt.descStyle
-
-	if descStyle and descStyle ~= "tooltip" then return end
-
-	tooltip:SetText(name, 1, .82, 0, true)
-
-	if opt.type == "multiselect" then
-		tooltip:AddLine(user.text, 0.5, 0.5, 0.8, true)
-	end
-	if type(desc) == "string" then
-		tooltip:AddLine(desc, 1, 1, 1, true)
-	end
-	if type(usage) == "string" then
-		tooltip:AddLine("Usage: "..usage, NORMAL_FONT_COLOR.r, NORMAL_FONT_COLOR.g, NORMAL_FONT_COLOR.b, true)
-	end
-
-	tooltip:Show()
-end
-
-local function OptionOnMouseLeave(widget, event)
-	AceConfigDialog.tooltip:Hide()
-end
-
-local function GetFuncName(option)
-	if option.type == "execute" then
-		return "func"
-	else
-		return "set"
-	end
-end
-do
-	local frame = AceConfigDialog.popup
-	if not frame or oldminor < 81 then
-		frame = CreateFrame("Frame", nil, UIParent)
-		AceConfigDialog.popup = frame
-		frame:Hide()
-		frame:SetPoint("CENTER", UIParent, "CENTER")
-		frame:SetSize(320, 72)
-		frame:EnableMouse(true) -- Do not allow click-through on the frame
-		frame:SetFrameStrata("TOOLTIP")
-		frame:SetFrameLevel(100) -- Lots of room to draw under it
-		frame:SetScript("OnKeyDown", function(self, key)
-			if key == "ESCAPE" then
-				self:SetPropagateKeyboardInput(false)
-				if self.cancel:IsShown() then
-					self.cancel:Click()
-				else -- Showing a validation error
-					self:Hide()
-				end
-			else
-				self:SetPropagateKeyboardInput(true)
-			end
-		end)
-
-		local border = CreateFrame("Frame", nil, frame, "DialogBorderOpaqueTemplate")
-		border:SetAllPoints(frame)
-		frame:SetFixedFrameStrata(true)
-		frame:SetFixedFrameLevel(true)
-
-		local text = frame:CreateFontString(nil, "ARTWORK", "GameFontHighlight")
-		text:SetSize(290, 0)
-		text:SetPoint("TOP", 0, -16)
-		frame.text = text
-
-		local function newButton(newText)
-			local button = CreateFrame("Button", nil, frame)
-			button:SetSize(128, 21)
-			button:SetNormalFontObject(GameFontNormal)
-			button:SetHighlightFontObject(GameFontHighlight)
-			button:SetNormalTexture(130763) -- "Interface\\Buttons\\UI-DialogBox-Button-Up"
-			button:GetNormalTexture():SetTexCoord(0.0, 1.0, 0.0, 0.71875)
-			button:SetPushedTexture(130761) -- "Interface\\Buttons\\UI-DialogBox-Button-Down"
-			button:GetPushedTexture():SetTexCoord(0.0, 1.0, 0.0, 0.71875)
-			button:SetHighlightTexture(130762) -- "Interface\\Buttons\\UI-DialogBox-Button-Highlight"
-			button:GetHighlightTexture():SetTexCoord(0.0, 1.0, 0.0, 0.71875)
-			button:SetText(newText)
-			return button
-		end
-
-		local accept = newButton(ACCEPT)
-		accept:SetPoint("BOTTOMRIGHT", frame, "BOTTOM", -6, 16)
-		frame.accept = accept
-
-		local cancel = newButton(CANCEL)
-		cancel:SetPoint("LEFT", accept, "RIGHT", 13, 0)
-		frame.cancel = cancel
-	end
-end
-local function confirmPopup(appName, rootframe, basepath, info, message, func, ...)
-	local frame = AceConfigDialog.popup
-	frame:Show()
-	frame.text:SetText(message)
-	-- From StaticPopup.lua
-	-- local height = 32 + text:GetHeight() + 2;
-	-- height = height + 6 + accept:GetHeight()
-	-- We add 32 + 2 + 6 + 21 (button height) == 61
-	local height = 61 + frame.text:GetHeight()
-	frame:SetHeight(height)
-
-	frame.accept:ClearAllPoints()
-	frame.accept:SetPoint("BOTTOMRIGHT", frame, "BOTTOM", -6, 16)
-	frame.cancel:Show()
-
-	local t = {...}
-	local tCount = select("#", ...)
-	frame.accept:SetScript("OnClick", function(self)
-		safecall(func, unpack(t, 1, tCount)) -- Manually set count as unpack() stops on nil (bug with #table)
-		AceConfigDialog:Open(appName, rootframe, unpack(basepath or emptyTbl))
-		frame:Hide()
-		self:SetScript("OnClick", nil)
-		frame.cancel:SetScript("OnClick", nil)
-		del(info)
-	end)
-	frame.cancel:SetScript("OnClick", function(self)
-		AceConfigDialog:Open(appName, rootframe, unpack(basepath or emptyTbl))
-		frame:Hide()
-		self:SetScript("OnClick", nil)
-		frame.accept:SetScript("OnClick", nil)
-		del(info)
-	end)
-end
-
-local function validationErrorPopup(message)
-	local frame = AceConfigDialog.popup
-	frame:Show()
-	frame.text:SetText(message)
-	-- From StaticPopup.lua
-	-- local height = 32 + text:GetHeight() + 2;
-	-- height = height + 6 + accept:GetHeight()
-	-- We add 32 + 2 + 6 + 21 (button height) == 61
-	local height = 61 + frame.text:GetHeight()
-	frame:SetHeight(height)
-
-	frame.accept:ClearAllPoints()
-	frame.accept:SetPoint("BOTTOM", frame, "BOTTOM", 0, 16)
-	frame.cancel:Hide()
-
-	frame.accept:SetScript("OnClick", function()
-		frame:Hide()
-	end)
-end
-
-local function ActivateControl(widget, event, ...)
-	--This function will call the set / execute handler for the widget
-	--widget:GetUserDataTable() contains the needed info
-	local user = widget:GetUserDataTable()
-	local option = user.option
-	local options = user.options
-	local path = user.path
-	local info = new()
-
-	local func
-	local group = options
-	local funcname = GetFuncName(option)
-	local handler
-	local confirm
-	local validate
-	--build the info table containing the path
-	-- pick up functions while traversing the tree
-	if group[funcname] ~= nil then
-		func =  group[funcname]
-	end
-	handler = group.handler
-	confirm = group.confirm
-	validate = group.validate
-	for i = 1, #path do
-		local v = path[i]
-		group = GetSubOption(group, v)
-		info[i] = v
-		if group[funcname] ~= nil then
-			func =  group[funcname]
-		end
-		handler = group.handler or handler
-		if group.confirm ~= nil then
-			confirm = group.confirm
-		end
-		if group.validate ~= nil then
-			validate = group.validate
-		end
-	end
-
-	info.options = options
-	info.appName = user.appName
-	info.arg = option.arg
-	info.handler = handler
-	info.option = option
-	info.type = option.type
-	info.uiType = "dialog"
-	info.uiName = MAJOR
-
-	local name
-	if type(option.name) == "function" then
-		name = option.name(info)
-	elseif type(option.name) == "string" then
-		name = option.name
-	else
-		name = ""
-	end
-	local usage = option.usage
-	local pattern = option.pattern
-
-	local validated = true
-
-	if option.type == "input" then
-		if type(pattern)=="string" then
-			if not strmatch(..., pattern) then
-				validated = false
-			end
-		end
-	end
-
-	local success
-	if validated and option.type ~= "execute" then
-		if type(validate) == "string" then
-			if handler and handler[validate] then
-				success, validated = safecall(handler[validate], handler, info, ...)
-				if not success then validated = false end
-			else
-				error(format("Method %s doesn't exist in handler for type execute", validate))
-			end
-		elseif type(validate) == "function" then
-			success, validated = safecall(validate, info, ...)
-			if not success then validated = false end
-		end
-	end
-
-	if not validated or type(validated) == "string" then
-		if not validated then
-			if usage then
-				validated = name..": "..usage
-			else
-				if pattern then
-					validated = name..": Expected "..pattern
-				else
-					validated = name..": Invalid Value"
-				end
-			end
-		end
-
-		-- show validate message
-		if user.rootframe.SetStatusText then
-			user.rootframe:SetStatusText(validated)
-		else
-			validationErrorPopup(validated)
-		end
-		PlaySound(882) -- SOUNDKIT.IG_PLAYER_INVITE_DECLINE || _DECLINE is actually missing from the table
-		del(info)
-		return true
-	else
-
-		local confirmText = option.confirmText
-		--call confirm func/method
-		if type(confirm) == "string" then
-			if handler and handler[confirm] then
-				success, confirm = safecall(handler[confirm], handler, info, ...)
-				if success and type(confirm) == "string" then
-					confirmText = confirm
-					confirm = true
-				elseif not success then
-					confirm = false
-				end
-			else
-				error(format("Method %s doesn't exist in handler for type confirm", confirm))
-			end
-		elseif type(confirm) == "function" then
-			success, confirm = safecall(confirm, info, ...)
-			if success and type(confirm) == "string" then
-				confirmText = confirm
-				confirm = true
-			elseif not success then
-				confirm = false
-			end
-		end
-
-		--confirm if needed
-		if type(confirm) == "boolean" then
-			if confirm then
-				if not confirmText then
-					local option_name, desc = option.name, option.desc
-					if type(option_name) == "function" then
-						option_name = option_name(info)
-					end
-					if type(desc) == "function" then
-						desc = desc(info)
-					end
-					confirmText = option_name
-					if desc then
-						confirmText = confirmText.." - "..desc
-					end
-				end
-
-				local iscustom = user.rootframe:GetUserData("iscustom")
-				local rootframe
-
-				if iscustom then
-					rootframe = user.rootframe
-				end
-				local basepath = user.rootframe:GetUserData("basepath")
-				if type(func) == "string" then
-					if handler and handler[func] then
-						confirmPopup(user.appName, rootframe, basepath, info, confirmText, handler[func], handler, info, ...)
-					else
-						error(format("Method %s doesn't exist in handler for type func", func))
-					end
-				elseif type(func) == "function" then
-					confirmPopup(user.appName, rootframe, basepath, info, confirmText, func, info, ...)
-				end
-				--func will be called and info deleted when the confirm dialog is responded to
-				return
-			end
-		end
-
-		--call the function
-		if type(func) == "string" then
-			if handler and handler[func] then
-				safecall(handler[func],handler, info, ...)
-			else
-				error(format("Method %s doesn't exist in handler for type func", func))
-			end
-		elseif type(func) == "function" then
-			safecall(func,info, ...)
-		end
-
-
-
-		local iscustom = user.rootframe:GetUserData("iscustom")
-		local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
-		--full refresh of the frame, some controls dont cause this on all events
-		if option.type == "color" then
-			if event == "OnValueConfirmed" then
-
-				if iscustom then
-					AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
-				else
-					AceConfigDialog:Open(user.appName, unpack(basepath))
-				end
-			end
-		elseif option.type == "range" then
-			if event == "OnMouseUp" then
-				if iscustom then
-					AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
-				else
-					AceConfigDialog:Open(user.appName, unpack(basepath))
-				end
-			end
-		--multiselects don't cause a refresh on 'OnValueChanged' only 'OnClosed'
-		elseif option.type == "multiselect" then
-			user.valuechanged = true
-		else
-			if iscustom then
-				AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
-			else
-				AceConfigDialog:Open(user.appName, unpack(basepath))
-			end
-		end
-
-	end
-	del(info)
-end
-
-local function ActivateSlider(widget, event, value)
-	local option = widget:GetUserData("option")
-	local min, max, step = option.min or (not option.softMin and 0 or nil), option.max or (not option.softMax and 100 or nil), option.step
-	if min then
-		if step then
-			value = math_floor((value - min) / step + 0.5) * step + min
-		end
-		value = math_max(value, min)
-	end
-	if max then
-		value = math_min(value, max)
-	end
-	ActivateControl(widget,event,value)
-end
-
---called from a checkbox that is part of an internally created multiselect group
---this type is safe to refresh on activation of one control
-local function ActivateMultiControl(widget, event, ...)
-	ActivateControl(widget, event, widget:GetUserData("value"), ...)
-	local user = widget:GetUserDataTable()
-	local iscustom = user.rootframe:GetUserData("iscustom")
-	local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
-	if iscustom then
-		AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
-	else
-		AceConfigDialog:Open(user.appName, unpack(basepath))
-	end
-end
-
-local function MultiControlOnClosed(widget, event, ...)
-	local user = widget:GetUserDataTable()
-	if user.valuechanged and not widget:IsReleasing() then
-		local iscustom = user.rootframe:GetUserData("iscustom")
-		local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
-		if iscustom then
-			AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
-		else
-			AceConfigDialog:Open(user.appName, unpack(basepath))
-		end
-	end
-end
-
-local function FrameOnClose(widget, event)
-	local appName = widget:GetUserData("appName")
-	AceConfigDialog.OpenFrames[appName] = nil
-	gui:Release(widget)
-end
-
-local function CheckOptionHidden(option, options, path, appName)
-	--check for a specific boolean option
-	local hidden = pickfirstset(option.dialogHidden,option.guiHidden)
-	if hidden ~= nil then
-		return hidden
-	end
-
-	return GetOptionsMemberValue("hidden", option, options, path, appName)
-end
-
-local function CheckOptionDisabled(option, options, path, appName)
-	--check for a specific boolean option
-	local disabled = pickfirstset(option.dialogDisabled,option.guiDisabled)
-	if disabled ~= nil then
-		return disabled
-	end
-
-	return GetOptionsMemberValue("disabled", option, options, path, appName)
-end
---[[
-local function BuildTabs(group, options, path, appName)
-	local tabs = new()
-	local text = new()
-	local keySort = new()
-	local opts = new()
-
-	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
-
-	for i = 1, #keySort do
-		local k = keySort[i]
-		local v = opts[k]
-		if v.type == "group" then
-			path[#path+1] = k
-			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
-			local hidden = CheckOptionHidden(v, options, path, appName)
-			if not inline and not hidden then
-				tinsert(tabs, k)
-				text[k] = GetOptionsMemberValue("name", v, options, path, appName)
-			end
-			path[#path] = nil
-		end
-	end
-
-	del(keySort)
-	del(opts)
-
-	return tabs, text
-end
-]]
-local function BuildSelect(group, options, path, appName)
-	local groups = new()
-	local order = new()
-	local keySort = new()
-	local opts = new()
-
-	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
-
-	for i = 1, #keySort do
-		local k = keySort[i]
-		local v = opts[k]
-		if v.type == "group" then
-			path[#path+1] = k
-			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
-			local hidden = CheckOptionHidden(v, options, path, appName)
-			if not inline and not hidden then
-				groups[k] = GetOptionsMemberValue("name", v, options, path, appName)
-				tinsert(order, k)
-			end
-			path[#path] = nil
-		end
-	end
-
-	del(opts)
-	del(keySort)
-
-	return groups, order
-end
-
-local function BuildSubGroups(group, tree, options, path, appName)
-	local keySort = new()
-	local opts = new()
-
-	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
-
-	for i = 1, #keySort do
-		local k = keySort[i]
-		local v = opts[k]
-		if v.type == "group" then
-			path[#path+1] = k
-			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
-			local hidden = CheckOptionHidden(v, options, path, appName)
-			if not inline and not hidden then
-				local entry = new()
-				entry.value = k
-				entry.text = GetOptionsMemberValue("name", v, options, path, appName)
-				entry.icon = GetOptionsMemberValue("icon", v, options, path, appName)
-				entry.iconCoords = GetOptionsMemberValue("iconCoords", v, options, path, appName)
-				entry.disabled = CheckOptionDisabled(v, options, path, appName)
-				if not tree.children then tree.children = new() end
-				tinsert(tree.children,entry)
-				if (v.childGroups or "tree") == "tree" then
-					BuildSubGroups(v,entry, options, path, appName)
-				end
-			end
-			path[#path] = nil
-		end
-	end
-
-	del(keySort)
-	del(opts)
-end
-
-local function BuildGroups(group, options, path, appName, recurse)
-	local tree = new()
-	local keySort = new()
-	local opts = new()
-
-	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
-
-	for i = 1, #keySort do
-		local k = keySort[i]
-		local v = opts[k]
-		if v.type == "group" then
-			path[#path+1] = k
-			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
-			local hidden = CheckOptionHidden(v, options, path, appName)
-			if not inline and not hidden then
-				local entry = new()
-				entry.value = k
-				entry.text = GetOptionsMemberValue("name", v, options, path, appName)
-				entry.icon = GetOptionsMemberValue("icon", v, options, path, appName)
-				entry.iconCoords = GetOptionsMemberValue("iconCoords", v, options, path, appName)
-				entry.disabled = CheckOptionDisabled(v, options, path, appName)
-				tinsert(tree,entry)
-				if recurse and (v.childGroups or "tree") == "tree" then
-					BuildSubGroups(v,entry, options, path, appName)
-				end
-			end
-			path[#path] = nil
-		end
-	end
-	del(keySort)
-	del(opts)
-	return tree
-end
-
-local function InjectInfo(control, options, option, path, rootframe, appName)
-	local user = control:GetUserDataTable()
-	for i = 1, #path do
-		user[i] = path[i]
-	end
-	user.rootframe = rootframe
-	user.option = option
-	user.options = options
-	user.path = copy(path)
-	user.appName = appName
-	control:SetCallback("OnRelease", CleanUserData)
-	control:SetCallback("OnLeave", OptionOnMouseLeave)
-	control:SetCallback("OnEnter", OptionOnMouseOver)
-end
-
-local function CreateControl(userControlType, fallbackControlType)
-	local control
-	if userControlType then
-		control = gui:Create(userControlType)
-		if not control then
-			geterrorhandler()(("Invalid Custom Control Type - %s"):format(tostring(userControlType)))
-		end
-	end
-	if not control then
-		control = gui:Create(fallbackControlType)
-	end
-	return control
-end
-
-local function sortTblAsStrings(x,y)
-	return tostring(x) < tostring(y) -- Support numbers as keys
-end
-
---[[
-	options - root of the options table being fed
-	container - widget that controls will be placed in
-	rootframe - Frame object the options are in
-	path - table with the keys to get to the group being fed
---]]
-
-local function FeedOptions(appName, options,container,rootframe,path,group,inline)
-	local keySort = new()
-	local opts = new()
-
-	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
-
-	for i = 1, #keySort do
-		local k = keySort[i]
-		local v = opts[k]
-		tinsert(path, k)
-		local hidden = CheckOptionHidden(v, options, path, appName)
-		local name = GetOptionsMemberValue("name", v, options, path, appName)
-		if not hidden then
-			if v.type == "group" then
-				if inline or pickfirstset(v.dialogInline,v.guiInline,v.inline, false) then
-					--Inline group
-					local GroupContainer
-					if name and name ~= "" then
-						GroupContainer = gui:Create("InlineGroup")
-						GroupContainer:SetTitle(name or "")
-					else
-						GroupContainer = gui:Create("SimpleGroup")
-					end
-
-					GroupContainer.width = "fill"
-					GroupContainer:SetLayout("flow")
-					container:AddChild(GroupContainer)
-					FeedOptions(appName,options,GroupContainer,rootframe,path,v,true)
-				end
-			else
-				--Control to feed
-				local control
-
-				if v.type == "execute" then
-
-					local imageCoords = GetOptionsMemberValue("imageCoords",v, options, path, appName)
-					local image, width, height = GetOptionsMemberValue("image",v, options, path, appName)
-
-					local iconControl = type(image) == "string" or type(image) == "number"
-					control = CreateControl(v.dialogControl or v.control, iconControl and "Icon" or "Button")
-					if iconControl then
-						if not width then
-							width = GetOptionsMemberValue("imageWidth",v, options, path, appName)
-						end
-						if not height then
-							height = GetOptionsMemberValue("imageHeight",v, options, path, appName)
-						end
-						if type(imageCoords) == "table" then
-							control:SetImage(image, unpack(imageCoords))
-						else
-							control:SetImage(image)
-						end
-						if type(width) ~= "number" then
-							width = 32
-						end
-						if type(height) ~= "number" then
-							height = 32
-						end
-						control:SetImageSize(width, height)
-						control:SetLabel(name)
-					else
-						control:SetText(name)
-					end
-					control:SetCallback("OnClick",ActivateControl)
-
-				elseif v.type == "input" then
-					control = CreateControl(v.dialogControl or v.control, v.multiline and "MultiLineEditBox" or "EditBox")
-
-					if v.multiline and control.SetNumLines then
-						control:SetNumLines(tonumber(v.multiline) or 4)
-					end
-					control:SetLabel(name)
-					control:SetCallback("OnEnterPressed",ActivateControl)
-					local text = GetOptionsMemberValue("get",v, options, path, appName)
-					if type(text) ~= "string" then
-						text = ""
-					end
-					control:SetText(text)
-
-				elseif v.type == "toggle" then
-					control = CreateControl(v.dialogControl or v.control, "CheckBox")
-					control:SetLabel(name)
-					control:SetTriState(v.tristate)
-					local value = GetOptionsMemberValue("get",v, options, path, appName)
-					control:SetValue(value)
-					control:SetCallback("OnValueChanged",ActivateControl)
-
-					if v.descStyle == "inline" then
-						local desc = GetOptionsMemberValue("desc", v, options, path, appName)
-						control:SetDescription(desc)
-					end
-
-					local image = GetOptionsMemberValue("image", v, options, path, appName)
-					local imageCoords = GetOptionsMemberValue("imageCoords", v, options, path, appName)
-
-					if type(image) == "string" or type(image) == "number" then
-						if type(imageCoords) == "table" then
-							control:SetImage(image, unpack(imageCoords))
-						else
-							control:SetImage(image)
-						end
-					end
-				elseif v.type == "range" then
-					control = CreateControl(v.dialogControl or v.control, "Slider")
-					control:SetLabel(name)
-					control:SetSliderValues(v.softMin or v.min or 0, v.softMax or v.max or 100, v.bigStep or v.step or 0)
-					control:SetIsPercent(v.isPercent)
-					local value = GetOptionsMemberValue("get",v, options, path, appName)
-					if type(value) ~= "number" then
-						value = 0
-					end
-					control:SetValue(value)
-					control:SetCallback("OnValueChanged",ActivateSlider)
-					control:SetCallback("OnMouseUp",ActivateSlider)
-
-				elseif v.type == "select" then
-					local values = GetOptionsMemberValue("values", v, options, path, appName)
-					local sorting = GetOptionsMemberValue("sorting", v, options, path, appName)
-					if v.style == "radio" then
-						local disabled = CheckOptionDisabled(v, options, path, appName)
-						local width = GetOptionsMemberValue("width",v,options,path,appName)
-						control = gui:Create("InlineGroup")
-						control:SetLayout("Flow")
-						control:SetTitle(name)
-						control.width = "fill"
-
-						control:PauseLayout()
-						local optionValue = GetOptionsMemberValue("get",v, options, path, appName)
-						if not sorting then
-							sorting = {}
-							for value, text in pairs(values) do
-								sorting[#sorting+1]=value
-							end
-							tsort(sorting, sortTblAsStrings)
-						end
-						for _, value in ipairs(sorting) do
-							local text = values[value]
-							local radio = gui:Create("CheckBox")
-							radio:SetLabel(text)
-							radio:SetUserData("value", value)
-							radio:SetUserData("text", text)
-							radio:SetDisabled(disabled)
-							radio:SetType("radio")
-							radio:SetValue(optionValue == value)
-							radio:SetCallback("OnValueChanged", ActivateMultiControl)
-							InjectInfo(radio, options, v, path, rootframe, appName)
-							control:AddChild(radio)
-							if width == "double" then
-								radio:SetWidth(width_multiplier * 2)
-							elseif width == "half" then
-								radio:SetWidth(width_multiplier / 2)
-							elseif (type(width) == "number") then
-								radio:SetWidth(width_multiplier * width)
-							elseif width == "full" then
-								radio.width = "fill"
-							else
-								radio:SetWidth(width_multiplier)
-							end
-						end
-						control:ResumeLayout()
-						control:DoLayout()
-					else
-						control = CreateControl(v.dialogControl or v.control, "Dropdown")
-						local itemType = v.itemControl
-						if itemType and not gui:GetWidgetVersion(itemType) then
-							geterrorhandler()(("Invalid Custom Item Type - %s"):format(tostring(itemType)))
-							itemType = nil
-						end
-						control:SetLabel(name)
-						control:SetList(values, sorting, itemType)
-						local value = GetOptionsMemberValue("get",v, options, path, appName)
-						if not values[value] then
-							value = nil
-						end
-						control:SetValue(value)
-						control:SetCallback("OnValueChanged", ActivateControl)
-					end
-
-				elseif v.type == "multiselect" then
-					local values = GetOptionsMemberValue("values", v, options, path, appName)
-					local disabled = CheckOptionDisabled(v, options, path, appName)
-
-					local valuesort = new()
-					if values then
-						for value, text in pairs(values) do
-							tinsert(valuesort, value)
-						end
-					end
-					tsort(valuesort)
-
-					local controlType = v.dialogControl or v.control
-					if controlType then
-						control = gui:Create(controlType)
-						if not control then
-							geterrorhandler()(("Invalid Custom Control Type - %s"):format(tostring(controlType)))
-						end
-					end
-					if control then
-						control:SetMultiselect(true)
-						control:SetLabel(name)
-						control:SetList(values)
-						control:SetDisabled(disabled)
-						control:SetCallback("OnValueChanged",ActivateControl)
-						control:SetCallback("OnClosed", MultiControlOnClosed)
-						local width = GetOptionsMemberValue("width",v,options,path,appName)
-						if width == "double" then
-							control:SetWidth(width_multiplier * 2)
-						elseif width == "half" then
-							control:SetWidth(width_multiplier / 2)
-						elseif (type(width) == "number") then
-							control:SetWidth(width_multiplier * width)
-						elseif width == "full" then
-							control.width = "fill"
-						else
-							control:SetWidth(width_multiplier)
-						end
-						--check:SetTriState(v.tristate)
-						for s = 1, #valuesort do
-							local key = valuesort[s]
-							local value = GetOptionsMemberValue("get",v, options, path, appName, key)
-							control:SetItemValue(key,value)
-						end
-					else
-						control = gui:Create("InlineGroup")
-						control:SetLayout("Flow")
-						control:SetTitle(name)
-						control.width = "fill"
-
-						control:PauseLayout()
-						local width = GetOptionsMemberValue("width",v,options,path,appName)
-						for s = 1, #valuesort do
-							local value = valuesort[s]
-							local text = values[value]
-							local check = gui:Create("CheckBox")
-							check:SetLabel(text)
-							check:SetUserData("value", value)
-							check:SetUserData("text", text)
-							check:SetDisabled(disabled)
-							check:SetTriState(v.tristate)
-							check:SetValue(GetOptionsMemberValue("get",v, options, path, appName, value))
-							check:SetCallback("OnValueChanged",ActivateMultiControl)
-							InjectInfo(check, options, v, path, rootframe, appName)
-							control:AddChild(check)
-							if width == "double" then
-								check:SetWidth(width_multiplier * 2)
-							elseif width == "half" then
-								check:SetWidth(width_multiplier / 2)
-							elseif (type(width) == "number") then
-								check:SetWidth(width_multiplier * width)
-							elseif width == "full" then
-								check.width = "fill"
-							else
-								check:SetWidth(width_multiplier)
-							end
-						end
-						control:ResumeLayout()
-						control:DoLayout()
-
-
-					end
-
-					del(valuesort)
-
-				elseif v.type == "color" then
-					control = CreateControl(v.dialogControl or v.control, "ColorPicker")
-					control:SetLabel(name)
-					control:SetHasAlpha(GetOptionsMemberValue("hasAlpha",v, options, path, appName))
-					control:SetColor(GetOptionsMemberValue("get",v, options, path, appName))
-					control:SetCallback("OnValueChanged",ActivateControl)
-					control:SetCallback("OnValueConfirmed",ActivateControl)
-
-				elseif v.type == "keybinding" then
-					control = CreateControl(v.dialogControl or v.control, "Keybinding")
-					control:SetLabel(name)
-					control:SetKey(GetOptionsMemberValue("get",v, options, path, appName))
-					control:SetCallback("OnKeyChanged",ActivateControl)
-
-				elseif v.type == "header" then
-					control = CreateControl(v.dialogControl or v.control, "Heading")
-					control:SetText(name)
-					control.width = "fill"
-
-				elseif v.type == "description" then
-					control = CreateControl(v.dialogControl or v.control, "Label")
-					control:SetText(name)
-
-					local fontSize = GetOptionsMemberValue("fontSize",v, options, path, appName)
-					if fontSize == "medium" then
-						control:SetFontObject(GameFontHighlight)
-					elseif fontSize == "large" then
-						control:SetFontObject(GameFontHighlightLarge)
-					else -- small or invalid
-						control:SetFontObject(GameFontHighlightSmall)
-					end
-
-					local imageCoords = GetOptionsMemberValue("imageCoords",v, options, path, appName)
-					local image, width, height = GetOptionsMemberValue("image",v, options, path, appName)
-
-					if type(image) == "string" or type(image) == "number" then
-						if not width then
-							width = GetOptionsMemberValue("imageWidth",v, options, path, appName)
-						end
-						if not height then
-							height = GetOptionsMemberValue("imageHeight",v, options, path, appName)
-						end
-						if type(imageCoords) == "table" then
-							control:SetImage(image, unpack(imageCoords))
-						else
-							control:SetImage(image)
-						end
-						if type(width) ~= "number" then
-							width = 32
-						end
-						if type(height) ~= "number" then
-							height = 32
-						end
-						control:SetImageSize(width, height)
-					end
-					local controlWidth = GetOptionsMemberValue("width",v,options,path,appName)
-					control.width = not controlWidth and "fill"
-				end
-
-				--Common Init
-				if control then
-					if control.width ~= "fill" then
-						local width = GetOptionsMemberValue("width",v,options,path,appName)
-						if width == "double" then
-							control:SetWidth(width_multiplier * 2)
-						elseif width == "half" then
-							control:SetWidth(width_multiplier / 2)
-						elseif (type(width) == "number") then
-							control:SetWidth(width_multiplier * width)
-						elseif width == "full" then
-							control.width = "fill"
-						else
-							control:SetWidth(width_multiplier)
-						end
-					end
-					if control.SetDisabled then
-						local disabled = CheckOptionDisabled(v, options, path, appName)
-						control:SetDisabled(disabled)
-					end
-
-					InjectInfo(control, options, v, path, rootframe, appName)
-					container:AddChild(control)
-				end
-
-			end
-		end
-		tremove(path)
-	end
-	container:ResumeLayout()
-	container:DoLayout()
-	del(keySort)
-	del(opts)
-end
-
-local function BuildPath(path, ...)
-	for i = 1, select("#",...)  do
-		tinsert(path, (select(i,...)))
-	end
-end
-
-
-local function TreeOnButtonEnter(widget, event, uniquevalue, button)
-	local user = widget:GetUserDataTable()
-	if not user then return end
-	local options = user.options
-	local option = user.option
-	local path = user.path
-	local appName = user.appName
-	local tooltip = AceConfigDialog.tooltip
-
-	local feedpath = new()
-	for i = 1, #path do
-		feedpath[i] = path[i]
-	end
-
-	BuildPath(feedpath, ("\001"):split(uniquevalue))
-	local group = options
-	for i = 1, #feedpath do
-		if not group then return end
-		group = GetSubOption(group, feedpath[i])
-	end
-
-	local name = GetOptionsMemberValue("name", group, options, feedpath, appName)
-	local desc = GetOptionsMemberValue("desc", group, options, feedpath, appName)
-
-	tooltip:SetOwner(button, "ANCHOR_NONE")
-	tooltip:ClearAllPoints()
-	if widget.type == "TabGroup" then
-		tooltip:SetPoint("BOTTOM",button,"TOP")
-	else
-		tooltip:SetPoint("LEFT",button,"RIGHT")
-	end
-
-	tooltip:SetText(name, 1, .82, 0, true)
-
-	if type(desc) == "string" then
-		tooltip:AddLine(desc, 1, 1, 1, true)
-	end
-
-	tooltip:Show()
-end
-
-local function TreeOnButtonLeave(widget, event, value, button)
-	AceConfigDialog.tooltip:Hide()
-end
-
-
-local function GroupExists(appName, options, path, uniquevalue)
-	if not uniquevalue then return false end
-
-	local feedpath = new()
-	local temppath = new()
-	for i = 1, #path do
-		feedpath[i] = path[i]
-	end
-
-	BuildPath(feedpath, ("\001"):split(uniquevalue))
-
-	local group = options
-	for i = 1, #feedpath do
-		local v = feedpath[i]
-		temppath[i] = v
-		group = GetSubOption(group, v)
-
-		if not group or group.type ~= "group" or CheckOptionHidden(group, options, temppath, appName) then
-			del(feedpath)
-			del(temppath)
-			return false
-		end
-	end
-	del(feedpath)
-	del(temppath)
-	return true
-end
-
-local function GroupSelected(widget, event, uniquevalue)
-
-	local user = widget:GetUserDataTable()
-
-	local options = user.options
-	local option = user.option
-	local path = user.path
-	local rootframe = user.rootframe
-
-	local feedpath = new()
-	for i = 1, #path do
-		feedpath[i] = path[i]
-	end
-
-	BuildPath(feedpath, ("\001"):split(uniquevalue))
-	widget:ReleaseChildren()
-	AceConfigDialog:FeedGroup(user.appName,options,widget,rootframe,feedpath)
-
-	del(feedpath)
-end
-
-
-
---[[
--- INTERNAL --
-This function will feed one group, and any inline child groups into the given container
-Select Groups will only have the selection control (tree, tabs, dropdown) fed in
-and have a group selected, this event will trigger the feeding of child groups
-
-Rules:
-	If the group is Inline, FeedOptions
-	If the group has no child groups, FeedOptions
-
-	If the group is a tab or select group, FeedOptions then add the Group Control
-	If the group is a tree group FeedOptions then
-		its parent isnt a tree group:  then add the tree control containing this and all child tree groups
-		if its parent is a tree group, its already a node on a tree
---]]
-
-function AceConfigDialog:FeedGroup(appName,options,container,rootframe,path, isRoot)
-	local group = options
-	--follow the path to get to the curent group
-	local inline
-	local grouptype, parenttype = options.childGroups, "none"
-
-
-	for i = 1, #path do
-		local v = path[i]
-		group = GetSubOption(group, v)
-		inline = inline or pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
-		parenttype = grouptype
-		grouptype = group.childGroups
-	end
-
-	if not parenttype then
-		parenttype = "tree"
-	end
-
-	--check if the group has child groups
-	local hasChildGroups
-	for k, v in pairs(group.args) do
-		if v.type == "group" and not pickfirstset(v.dialogInline,v.guiInline,v.inline, false) and not CheckOptionHidden(v, options, path, appName) then
-			hasChildGroups = true
-		end
-	end
-	if group.plugins then
-		for plugin, t in pairs(group.plugins) do
-			for k, v in pairs(t) do
-				if v.type == "group" and not pickfirstset(v.dialogInline,v.guiInline,v.inline, false) and not CheckOptionHidden(v, options, path, appName) then
-					hasChildGroups = true
-				end
-			end
-		end
-	end
-
-	container:SetLayout("flow")
-	local scroll
-
-	--Add a scrollframe if we are not going to add a group control, this is the inverse of the conditions for that later on
-	if (not (hasChildGroups and not inline)) or (grouptype ~= "tab" and grouptype ~= "select" and (parenttype == "tree" and not isRoot)) then
-		if container.type ~= "InlineGroup" and container.type ~= "SimpleGroup" then
-			scroll = gui:Create("ScrollFrame")
-			scroll:SetLayout("flow")
-			scroll.width = "fill"
-			scroll.height = "fill"
-			container:SetLayout("fill")
-			container:AddChild(scroll)
-			container = scroll
-		end
-	end
-
-	FeedOptions(appName,options,container,rootframe,path,group,nil)
-
-	if scroll then
-		container:PerformLayout()
-		local status = self:GetStatusTable(appName, path)
-		if not status.scroll then
-			status.scroll = {}
-		end
-		scroll:SetStatusTable(status.scroll)
-	end
-
-	if hasChildGroups and not inline then
-		local name = GetOptionsMemberValue("name", group, options, path, appName)
-		if grouptype == "tab" then
-
-			local tab = gui:Create("TabGroup")
-			InjectInfo(tab, options, group, path, rootframe, appName)
-			tab:SetCallback("OnGroupSelected", GroupSelected)
-			tab:SetCallback("OnTabEnter", TreeOnButtonEnter)
-			tab:SetCallback("OnTabLeave", TreeOnButtonLeave)
-
-			local status = AceConfigDialog:GetStatusTable(appName, path)
-			if not status.groups then
-				status.groups = {}
-			end
-			tab:SetStatusTable(status.groups)
-			tab.width = "fill"
-			tab.height = "fill"
-
-			local tabs = BuildGroups(group, options, path, appName)
-			tab:SetTabs(tabs)
-			tab:SetUserData("tablist", tabs)
-
-			for i = 1, #tabs do
-				local entry = tabs[i]
-				if not entry.disabled then
-					tab:SelectTab((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or entry.value)
-					break
-				end
-			end
-
-			container:AddChild(tab)
-
-		elseif grouptype == "select" then
-
-			local selectGroup = gui:Create("DropdownGroup")
-			selectGroup:SetTitle(name)
-			InjectInfo(selectGroup, options, group, path, rootframe, appName)
-			selectGroup:SetCallback("OnGroupSelected", GroupSelected)
-			local status = AceConfigDialog:GetStatusTable(appName, path)
-			if not status.groups then
-				status.groups = {}
-			end
-			selectGroup:SetStatusTable(status.groups)
-			local grouplist, orderlist = BuildSelect(group, options, path, appName)
-			selectGroup:SetGroupList(grouplist, orderlist)
-			selectGroup:SetUserData("grouplist", grouplist)
-			selectGroup:SetUserData("orderlist", orderlist)
-
-			local firstgroup = orderlist[1]
-			if firstgroup then
-				selectGroup:SetGroup((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or firstgroup)
-			end
-
-			selectGroup.width = "fill"
-			selectGroup.height = "fill"
-
-			container:AddChild(selectGroup)
-
-		--assume tree group by default
-		--if parenttype is tree then this group is already a node on that tree
-		elseif (parenttype ~= "tree") or isRoot then
-			local tree = gui:Create("TreeGroup")
-			InjectInfo(tree, options, group, path, rootframe, appName)
-			tree:EnableButtonTooltips(false)
-
-			tree.width = "fill"
-			tree.height = "fill"
-
-			tree:SetCallback("OnGroupSelected", GroupSelected)
-			tree:SetCallback("OnButtonEnter", TreeOnButtonEnter)
-			tree:SetCallback("OnButtonLeave", TreeOnButtonLeave)
-
-			local status = AceConfigDialog:GetStatusTable(appName, path)
-			if not status.groups then
-				status.groups = {}
-			end
-			local treedefinition = BuildGroups(group, options, path, appName, true)
-			tree:SetStatusTable(status.groups)
-
-			tree:SetTree(treedefinition)
-			tree:SetUserData("tree",treedefinition)
-
-			for i = 1, #treedefinition do
-				local entry = treedefinition[i]
-				if not entry.disabled then
-					tree:SelectByValue((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or entry.value)
-					break
-				end
-			end
-
-			container:AddChild(tree)
-		end
-	end
-end
-
-local old_CloseSpecialWindows
-
-
-local function RefreshOnUpdate(this)
-	for appName in pairs(this.closing) do
-		if AceConfigDialog.OpenFrames[appName] then
-			AceConfigDialog.OpenFrames[appName]:Hide()
-		end
-		if AceConfigDialog.BlizOptions and AceConfigDialog.BlizOptions[appName] then
-			for key, widget in pairs(AceConfigDialog.BlizOptions[appName]) do
-				if not widget:IsVisible() then
-					widget:ReleaseChildren()
-				end
-			end
-		end
-		this.closing[appName] = nil
-	end
-
-	if this.closeAll then
-		for k, v in pairs(AceConfigDialog.OpenFrames) do
-			if not this.closeAllOverride[k] then
-				v:Hide()
-			end
-		end
-		this.closeAll = nil
-		wipe(this.closeAllOverride)
-	end
-
-	for appName in pairs(this.apps) do
-		if AceConfigDialog.OpenFrames[appName] then
-			local user = AceConfigDialog.OpenFrames[appName]:GetUserDataTable()
-			AceConfigDialog:Open(appName, unpack(user.basepath or emptyTbl))
-		end
-		if AceConfigDialog.BlizOptions and AceConfigDialog.BlizOptions[appName] then
-			for key, widget in pairs(AceConfigDialog.BlizOptions[appName]) do
-				local user = widget:GetUserDataTable()
-				if widget:IsVisible() then
-					AceConfigDialog:Open(widget:GetUserData("appName"), widget, unpack(user.basepath or emptyTbl))
-				end
-			end
-		end
-		this.apps[appName] = nil
-	end
-	this:SetScript("OnUpdate", nil)
-end
-
--- Upgrade the OnUpdate script as well, if needed.
-if AceConfigDialog.frame:GetScript("OnUpdate") then
-	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
-end
-
---- Close all open options windows
-function AceConfigDialog:CloseAll()
-	AceConfigDialog.frame.closeAll = true
-	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
-	if next(self.OpenFrames) then
-		return true
-	end
-end
-
---- Close a specific options window.
--- @param appName The application name as given to `:RegisterOptionsTable()`
-function AceConfigDialog:Close(appName)
-	if self.OpenFrames[appName] then
-		AceConfigDialog.frame.closing[appName] = true
-		AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
-		return true
-	end
-end
-
--- Internal -- Called by AceConfigRegistry
-function AceConfigDialog:ConfigTableChanged(event, appName)
-	AceConfigDialog.frame.apps[appName] = true
-	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
-end
-
-reg.RegisterCallback(AceConfigDialog, "ConfigTableChange", "ConfigTableChanged")
-
---- Sets the default size of the options window for a specific application.
--- @param appName The application name as given to `:RegisterOptionsTable()`
--- @param width The default width
--- @param height The default height
-function AceConfigDialog:SetDefaultSize(appName, width, height)
-	local status = AceConfigDialog:GetStatusTable(appName)
-	if type(width) == "number" and type(height) == "number" then
-		status.width = width
-		status.height = height
-	end
-end
-
---- Open an option window at the specified path (if any).
--- This function can optionally feed the group into a pre-created container
--- instead of creating a new container frame.
--- @paramsig appName [, container][, ...]
--- @param appName The application name as given to `:RegisterOptionsTable()`
--- @param container An optional container frame to feed the options into
--- @param ... The path to open after creating the options window (see `:SelectGroup` for details)
-function AceConfigDialog:Open(appName, container, ...)
-	if not old_CloseSpecialWindows then
-		old_CloseSpecialWindows = CloseSpecialWindows
-		CloseSpecialWindows = function()
-			local found = old_CloseSpecialWindows()
-			return self:CloseAll() or found
-		end
-	end
-	local app = reg:GetOptionsTable(appName)
-	if not app then
-		error(("%s isn't registed with AceConfigRegistry, unable to open config"):format(appName), 2)
-	end
-	local options = app("dialog", MAJOR)
-
-	local f
-
-	local path = new()
-	local name = GetOptionsMemberValue("name", options, options, path, appName)
-
-	--If an optional path is specified add it to the path table before feeding the options
-	--as container is optional as well it may contain the first element of the path
-	if type(container) == "string" then
-		tinsert(path, container)
-		container = nil
-	end
-	for n = 1, select("#",...) do
-		tinsert(path, (select(n, ...)))
-	end
-
-	local option = options
-	if type(container) == "table" and container.type == "BlizOptionsGroup" and #path > 0 then
-		for i = 1, #path do
-			option = options.args[path[i]]
-		end
-		name = format("%s - %s", name, GetOptionsMemberValue("name", option, options, path, appName))
-	end
-
-	--if a container is given feed into that
-	if container then
-		f = container
-		f:ReleaseChildren()
-		f:SetUserData("appName", appName)
-		f:SetUserData("iscustom", true)
-		if #path > 0 then
-			f:SetUserData("basepath", copy(path))
-		end
-		local status = AceConfigDialog:GetStatusTable(appName)
-		if not status.width then
-			status.width =  700
-		end
-		if not status.height then
-			status.height = 500
-		end
-		if f.SetStatusTable then
-			f:SetStatusTable(status)
-		end
-		if f.SetTitle then
-			f:SetTitle(name or "")
-		end
-	else
-		if not self.OpenFrames[appName] then
-			f = gui:Create("Frame")
-			self.OpenFrames[appName] = f
-		else
-			f = self.OpenFrames[appName]
-		end
-		f:ReleaseChildren()
-		f:SetCallback("OnClose", FrameOnClose)
-		f:SetUserData("appName", appName)
-		if #path > 0 then
-			f:SetUserData("basepath", copy(path))
-		end
-		f:SetTitle(name or "")
-		local status = AceConfigDialog:GetStatusTable(appName)
-		f:SetStatusTable(status)
-	end
-
-	self:FeedGroup(appName,options,f,f,path,true)
-	if f.Show then
-		f:Show()
-	end
-	del(path)
-
-	if AceConfigDialog.frame.closeAll then
-		-- close all is set, but thats not good, since we're just opening here, so force it
-		AceConfigDialog.frame.closeAllOverride[appName] = true
-	end
-end
-
--- convert pre-39 BlizOptions structure to the new format
-if oldminor and oldminor < 39 and AceConfigDialog.BlizOptions then
-	local old = AceConfigDialog.BlizOptions
-	local newOpt = {}
-	for key, widget in pairs(old) do
-		local appName = widget:GetUserData("appName")
-		if not newOpt[appName] then newOpt[appName] = {} end
-		newOpt[appName][key] = widget
-	end
-	AceConfigDialog.BlizOptions = newOpt
-else
-	AceConfigDialog.BlizOptions = AceConfigDialog.BlizOptions or {}
-end
-
-local function FeedToBlizPanel(widget, event)
-	local path = widget:GetUserData("path")
-	AceConfigDialog:Open(widget:GetUserData("appName"), widget, unpack(path or emptyTbl))
-end
-
-local function ClearBlizPanel(widget, event)
-	local appName = widget:GetUserData("appName")
-	AceConfigDialog.frame.closing[appName] = true
-	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
-end
-
---- Add an option table into the Blizzard Interface Options panel.
--- You can optionally supply a descriptive name to use and a parent frame to use,
--- as well as a path in the options table.\\
--- If no name is specified, the appName will be used instead.
---
--- If you specify a proper `parent` (by name), the interface options will generate a
--- tree layout. Note that only one level of children is supported, so the parent always
--- has to be a head-level note.
---
--- This function returns a reference to the container frame registered with the Interface
--- Options. You can use this reference to open the options with the API function
--- `InterfaceOptionsFrame_OpenToCategory`.
--- @param appName The application name as given to `:RegisterOptionsTable()`
--- @param name A descriptive name to display in the options tree (defaults to appName)
--- @param parent The parent to use in the interface options tree.
--- @param ... The path in the options table to feed into the interface options panel.
--- @return The reference to the frame registered into the Interface Options.
--- @return The category ID to pass to Settings.OpenToCategory (or InterfaceOptionsFrame_OpenToCategory)
-function AceConfigDialog:AddToBlizOptions(appName, name, parent, ...)
-	local BlizOptions = AceConfigDialog.BlizOptions
-
-	local key = appName
-	for n = 1, select("#", ...) do
-		key = key.."\001"..select(n, ...)
-	end
-
-	if not BlizOptions[appName] then
-		BlizOptions[appName] = {}
-	end
-
-	if not BlizOptions[appName][key] then
-		local group = gui:Create("BlizOptionsGroup")
-		BlizOptions[appName][key] = group
-
-		group:SetTitle(name or appName)
-		group:SetUserData("appName", appName)
-		if select("#", ...) > 0 then
-			local path = {}
-			for n = 1, select("#",...) do
-				tinsert(path, (select(n, ...)))
-			end
-			group:SetUserData("path", path)
-		end
-		group:SetCallback("OnShow", FeedToBlizPanel)
-		group:SetCallback("OnHide", ClearBlizPanel)
-		if Settings and Settings.RegisterCanvasLayoutCategory then
-			local categoryName = name or appName
-			if parent then
-				local category = Settings.GetCategory(parent)
-				if not category then
-					error(("The parent category '%s' was not found"):format(parent), 2)
-				end
-				local subcategory = Settings.RegisterCanvasLayoutSubcategory(category, group.frame, categoryName)
-
-				-- force the generated ID to be used for subcategories, as these can have very simple names like "Profiles"
-				group:SetName(subcategory.ID, parent)
-			else
-				local category = Settings.RegisterCanvasLayoutCategory(group.frame, categoryName)
-				-- using appName here would be cleaner, but would not be 100% compatible
-				-- but for top-level categories it should be fine, as these are typically addon names
-				category.ID = categoryName
-				group:SetName(categoryName, parent)
-				Settings.RegisterAddOnCategory(category)
-			end
-		else
-			group:SetName(name or appName, parent)
-			InterfaceOptions_AddCategory(group.frame)
-		end
-		return group.frame, group.frame.name
-	else
-		error(("%s has already been added to the Blizzard Options Window with the given path"):format(appName), 2)
-	end
-end
+--- AceConfigDialog-3.0 generates AceGUI-3.0 based windows based on option tables.
+-- @class file
+-- @name AceConfigDialog-3.0
+-- @release $Id: AceConfigDialog-3.0.lua 1296 2022-11-04 18:50:10Z nevcairiel $
+
+local LibStub = LibStub
+local gui = LibStub("AceGUI-3.0")
+local reg = LibStub("AceConfigRegistry-3.0")
+
+local MAJOR, MINOR = "AceConfigDialog-3.0", 86
+local AceConfigDialog, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceConfigDialog then return end
+
+AceConfigDialog.OpenFrames = AceConfigDialog.OpenFrames or {}
+AceConfigDialog.Status = AceConfigDialog.Status or {}
+AceConfigDialog.frame = AceConfigDialog.frame or CreateFrame("Frame")
+AceConfigDialog.tooltip = AceConfigDialog.tooltip or CreateFrame("GameTooltip", "AceConfigDialogTooltip", UIParent, "GameTooltipTemplate")
+
+AceConfigDialog.frame.apps = AceConfigDialog.frame.apps or {}
+AceConfigDialog.frame.closing = AceConfigDialog.frame.closing or {}
+AceConfigDialog.frame.closeAllOverride = AceConfigDialog.frame.closeAllOverride or {}
+
+-- Lua APIs
+local tinsert, tsort, tremove, wipe = table.insert, table.sort, table.remove, table.wipe
+local strmatch, format = string.match, string.format
+local error = error
+local pairs, next, select, type, unpack, ipairs = pairs, next, select, type, unpack, ipairs
+local tostring, tonumber = tostring, tonumber
+local math_min, math_max, math_floor = math.min, math.max, math.floor
+
+local emptyTbl = {}
+
+--[[
+	 xpcall safecall implementation
+]]
+local xpcall = xpcall
+
+local function errorhandler(err)
+	return geterrorhandler()(err)
+end
+
+local function safecall(func, ...)
+	if func then
+		return xpcall(func, errorhandler, ...)
+	end
+end
+
+local width_multiplier = 170
+
+--[[
+Group Types
+  Tree 	- All Descendant Groups will all become nodes on the tree, direct child options will appear above the tree
+        - Descendant Groups with inline=true and thier children will not become nodes
+
+  Tab	- Direct Child Groups will become tabs, direct child options will appear above the tab control
+        - Grandchild groups will default to inline unless specified otherwise
+
+  Select- Same as Tab but with entries in a dropdown rather than tabs
+
+
+  Inline Groups
+    - Will not become nodes of a select group, they will be effectivly part of thier parent group seperated by a border
+    - If declared on a direct child of a root node of a select group, they will appear above the group container control
+    - When a group is displayed inline, all descendants will also be inline members of the group
+
+]]
+
+-- Recycling functions
+local new, del, copy
+--newcount, delcount,createdcount,cached = 0,0,0
+do
+	local pool = setmetatable({},{__mode="k"})
+	function new()
+		--newcount = newcount + 1
+		local t = next(pool)
+		if t then
+			pool[t] = nil
+			return t
+		else
+			--createdcount = createdcount + 1
+			return {}
+		end
+	end
+	function copy(t)
+		local c = new()
+		for k, v in pairs(t) do
+			c[k] = v
+		end
+		return c
+	end
+	function del(t)
+		--delcount = delcount + 1
+		wipe(t)
+		pool[t] = true
+	end
+--	function cached()
+--		local n = 0
+--		for k in pairs(pool) do
+--			n = n + 1
+--		end
+--		return n
+--	end
+end
+
+-- picks the first non-nil value and returns it
+local function pickfirstset(...)
+  for i=1,select("#",...) do
+    if select(i,...)~=nil then
+      return select(i,...)
+    end
+  end
+end
+
+--gets an option from a given group, checking plugins
+local function GetSubOption(group, key)
+	if group.plugins then
+		for plugin, t in pairs(group.plugins) do
+			if t[key] then
+				return t[key]
+			end
+		end
+	end
+
+	return group.args[key]
+end
+
+--Option member type definitions, used to decide how to access it
+
+--Is the member Inherited from parent options
+local isInherited = {
+	set = true,
+	get = true,
+	func = true,
+	confirm = true,
+	validate = true,
+	disabled = true,
+	hidden = true
+}
+
+--Does a string type mean a literal value, instead of the default of a method of the handler
+local stringIsLiteral = {
+	name = true,
+	desc = true,
+	icon = true,
+	usage = true,
+	width = true,
+	image = true,
+	fontSize = true,
+	tooltipHyperlink = true
+}
+
+--Is Never a function or method
+local allIsLiteral = {
+	type = true,
+	descStyle = true,
+	imageWidth = true,
+	imageHeight = true,
+}
+
+--gets the value for a member that could be a function
+--function refs are called with an info arg
+--every other type is returned
+local function GetOptionsMemberValue(membername, option, options, path, appName, ...)
+	--get definition for the member
+	local inherits = isInherited[membername]
+
+
+	--get the member of the option, traversing the tree if it can be inherited
+	local member
+
+	if inherits then
+		local group = options
+		if group[membername] ~= nil then
+			member = group[membername]
+		end
+		for i = 1, #path do
+			group = GetSubOption(group, path[i])
+			if group[membername] ~= nil then
+				member = group[membername]
+			end
+		end
+	else
+		member = option[membername]
+	end
+
+	--check if we need to call a functon, or if we have a literal value
+	if ( not allIsLiteral[membername] ) and ( type(member) == "function" or ((not stringIsLiteral[membername]) and type(member) == "string") ) then
+		--We have a function to call
+		local info = new()
+		--traverse the options table, picking up the handler and filling the info with the path
+		local group = options
+		local handler = group.handler
+
+		for i = 1, #path do
+			group = GetSubOption(group, path[i])
+			info[i] = path[i]
+			handler = group.handler or handler
+		end
+
+		info.options = options
+		info.appName = appName
+		info[0] = appName
+		info.arg = option.arg
+		info.handler = handler
+		info.option = option
+		info.type = option.type
+		info.uiType = "dialog"
+		info.uiName = MAJOR
+
+		local a, b, c ,d
+		--using 4 returns for the get of a color type, increase if a type needs more
+		if type(member) == "function" then
+			--Call the function
+			a,b,c,d = member(info, ...)
+		else
+			--Call the method
+			if handler and handler[member] then
+				a,b,c,d = handler[member](handler, info, ...)
+			else
+				error(format("Method %s doesn't exist in handler for type %s", member, membername))
+			end
+		end
+		del(info)
+		return a,b,c,d
+	else
+		--The value isnt a function to call, return it
+		return member
+	end
+end
+
+--[[calls an options function that could be inherited, method name or function ref
+local function CallOptionsFunction(funcname ,option, options, path, appName, ...)
+	local info = new()
+
+	local func
+	local group = options
+	local handler
+
+	--build the info table containing the path
+	-- pick up functions while traversing the tree
+	if group[funcname] ~= nil then
+		func = group[funcname]
+	end
+	handler = group.handler or handler
+
+	for i, v in ipairs(path) do
+		group = GetSubOption(group, v)
+		info[i] = v
+		if group[funcname] ~= nil then
+			func =  group[funcname]
+		end
+		handler = group.handler or handler
+	end
+
+	info.options = options
+	info[0] = appName
+	info.arg = option.arg
+
+	local a, b, c ,d
+	if type(func) == "string" then
+		if handler and handler[func] then
+			a,b,c,d = handler[func](handler, info, ...)
+		else
+			error(string.format("Method %s doesn't exist in handler for type func", func))
+		end
+	elseif type(func) == "function" then
+		a,b,c,d = func(info, ...)
+	end
+	del(info)
+	return a,b,c,d
+end
+--]]
+
+--tables to hold orders and names for options being sorted, will be created with new()
+--prevents needing to call functions repeatedly while sorting
+local tempOrders
+local tempNames
+
+local function compareOptions(a,b)
+	if not a then
+		return true
+	end
+	if not b then
+		return false
+	end
+	local OrderA, OrderB = tempOrders[a] or 100, tempOrders[b] or 100
+	if OrderA == OrderB then
+		local NameA = (type(tempNames[a]) == "string") and tempNames[a] or ""
+		local NameB = (type(tempNames[b]) == "string") and tempNames[b] or ""
+		return NameA:upper() < NameB:upper()
+	end
+	if OrderA < 0 then
+		if OrderB >= 0 then
+			return false
+		end
+	else
+		if OrderB < 0 then
+			return true
+		end
+	end
+	return OrderA < OrderB
+end
+
+
+
+--builds 2 tables out of an options group
+-- keySort, sorted keys
+-- opts, combined options from .plugins and args
+local function BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
+	tempOrders = new()
+	tempNames = new()
+
+	if group.plugins then
+		for plugin, t in pairs(group.plugins) do
+			for k, v in pairs(t) do
+				if not opts[k] then
+					tinsert(keySort, k)
+					opts[k] = v
+
+					path[#path+1] = k
+					tempOrders[k] = GetOptionsMemberValue("order", v, options, path, appName)
+					tempNames[k] = GetOptionsMemberValue("name", v, options, path, appName)
+					path[#path] = nil
+				end
+			end
+		end
+	end
+
+	for k, v in pairs(group.args) do
+		if not opts[k] then
+			tinsert(keySort, k)
+			opts[k] = v
+
+			path[#path+1] = k
+			tempOrders[k] = GetOptionsMemberValue("order", v, options, path, appName)
+			tempNames[k] = GetOptionsMemberValue("name", v, options, path, appName)
+			path[#path] = nil
+		end
+	end
+
+	tsort(keySort, compareOptions)
+
+	del(tempOrders)
+	del(tempNames)
+end
+
+local function DelTree(tree)
+	if tree.children then
+		local childs = tree.children
+		for i = 1, #childs do
+			DelTree(childs[i])
+			del(childs[i])
+		end
+		del(childs)
+	end
+end
+
+local function CleanUserData(widget, event)
+
+	local user = widget:GetUserDataTable()
+
+	if user.path then
+		del(user.path)
+	end
+
+	if widget.type == "TreeGroup" then
+		local tree = user.tree
+		widget:SetTree(nil)
+		if tree then
+			for i = 1, #tree do
+				DelTree(tree[i])
+				del(tree[i])
+			end
+			del(tree)
+		end
+	end
+
+	if widget.type == "TabGroup" then
+		widget:SetTabs(nil)
+		if user.tablist then
+			del(user.tablist)
+		end
+	end
+
+	if widget.type == "DropdownGroup" then
+		widget:SetGroupList(nil)
+		if user.grouplist then
+			del(user.grouplist)
+		end
+		if user.orderlist then
+			del(user.orderlist)
+		end
+	end
+end
+
+-- - Gets a status table for the given appname and options path.
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+-- @param path The path to the options (a table with all group keys)
+-- @return
+function AceConfigDialog:GetStatusTable(appName, path)
+	local status = self.Status
+
+	if not status[appName] then
+		status[appName] = {}
+		status[appName].status = {}
+		status[appName].children = {}
+	end
+
+	status = status[appName]
+
+	if path then
+		for i = 1, #path do
+			local v = path[i]
+			if not status.children[v] then
+				status.children[v] = {}
+				status.children[v].status = {}
+				status.children[v].children = {}
+			end
+			status = status.children[v]
+		end
+	end
+
+	return status.status
+end
+
+--- Selects the specified path in the options window.
+-- The path specified has to match the keys of the groups in the table.
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+-- @param ... The path to the key that should be selected
+function AceConfigDialog:SelectGroup(appName, ...)
+	local path = new()
+
+
+	local app = reg:GetOptionsTable(appName)
+	if not app then
+		error(("%s isn't registed with AceConfigRegistry, unable to open config"):format(appName), 2)
+	end
+	local options = app("dialog", MAJOR)
+	local group = options
+	local status = self:GetStatusTable(appName, path)
+	if not status.groups then
+		status.groups = {}
+	end
+	status = status.groups
+	local treevalue
+	local treestatus
+
+	for n = 1, select("#",...) do
+		local key = select(n, ...)
+
+		if group.childGroups == "tab" or group.childGroups == "select" then
+			--if this is a tab or select group, select the group
+			status.selected = key
+			--children of this group are no longer extra levels of a tree
+			treevalue = nil
+		else
+			--tree group by default
+			if treevalue then
+				--this is an extra level of a tree group, build a uniquevalue for it
+				treevalue = treevalue.."\001"..key
+			else
+				--this is the top level of a tree group, the uniquevalue is the same as the key
+				treevalue = key
+				if not status.groups then
+					status.groups = {}
+				end
+				--save this trees status table for any extra levels or groups
+				treestatus = status
+			end
+			--make sure that the tree entry is open, and select it.
+			--the selected group will be overwritten if a child is the final target but still needs to be open
+			treestatus.selected = treevalue
+			treestatus.groups[treevalue] = true
+
+		end
+
+		--move to the next group in the path
+		group = GetSubOption(group, key)
+		if not group then
+			break
+		end
+		tinsert(path, key)
+		status = self:GetStatusTable(appName, path)
+		if not status.groups then
+			status.groups = {}
+		end
+		status = status.groups
+	end
+
+	del(path)
+	reg:NotifyChange(appName)
+end
+
+local function OptionOnMouseOver(widget, event)
+	--show a tooltip/set the status bar to the desc text
+	local user = widget:GetUserDataTable()
+	local opt = user.option
+	local options = user.options
+	local path = user.path
+	local appName = user.appName
+	local tooltip = AceConfigDialog.tooltip
+
+	tooltip:SetOwner(widget.frame, "ANCHOR_TOPRIGHT")
+
+	local tooltipHyperlink = GetOptionsMemberValue("tooltipHyperlink", opt, options, path, appName)
+	if tooltipHyperlink then
+		tooltip:SetHyperlink(tooltipHyperlink)
+		tooltip:Show()
+		return
+	end
+
+	local name = GetOptionsMemberValue("name", opt, options, path, appName)
+	local desc = GetOptionsMemberValue("desc", opt, options, path, appName)
+	local usage = GetOptionsMemberValue("usage", opt, options, path, appName)
+	local descStyle = opt.descStyle
+
+	if descStyle and descStyle ~= "tooltip" then return end
+
+	tooltip:SetText(name, 1, .82, 0, true)
+
+	if opt.type == "multiselect" then
+		tooltip:AddLine(user.text, 0.5, 0.5, 0.8, true)
+	end
+	if type(desc) == "string" then
+		tooltip:AddLine(desc, 1, 1, 1, true)
+	end
+	if type(usage) == "string" then
+		tooltip:AddLine("Usage: "..usage, NORMAL_FONT_COLOR.r, NORMAL_FONT_COLOR.g, NORMAL_FONT_COLOR.b, true)
+	end
+
+	tooltip:Show()
+end
+
+local function OptionOnMouseLeave(widget, event)
+	AceConfigDialog.tooltip:Hide()
+end
+
+local function GetFuncName(option)
+	if option.type == "execute" then
+		return "func"
+	else
+		return "set"
+	end
+end
+do
+	local frame = AceConfigDialog.popup
+	if not frame or oldminor < 81 then
+		frame = CreateFrame("Frame", nil, UIParent)
+		AceConfigDialog.popup = frame
+		frame:Hide()
+		frame:SetPoint("CENTER", UIParent, "CENTER")
+		frame:SetSize(320, 72)
+		frame:EnableMouse(true) -- Do not allow click-through on the frame
+		frame:SetFrameStrata("TOOLTIP")
+		frame:SetFrameLevel(100) -- Lots of room to draw under it
+		frame:SetScript("OnKeyDown", function(self, key)
+			if key == "ESCAPE" then
+				self:SetPropagateKeyboardInput(false)
+				if self.cancel:IsShown() then
+					self.cancel:Click()
+				else -- Showing a validation error
+					self:Hide()
+				end
+			else
+				self:SetPropagateKeyboardInput(true)
+			end
+		end)
+
+		local border = CreateFrame("Frame", nil, frame, "DialogBorderOpaqueTemplate")
+		border:SetAllPoints(frame)
+		frame:SetFixedFrameStrata(true)
+		frame:SetFixedFrameLevel(true)
+
+		local text = frame:CreateFontString(nil, "ARTWORK", "GameFontHighlight")
+		text:SetSize(290, 0)
+		text:SetPoint("TOP", 0, -16)
+		frame.text = text
+
+		local function newButton(newText)
+			local button = CreateFrame("Button", nil, frame)
+			button:SetSize(128, 21)
+			button:SetNormalFontObject(GameFontNormal)
+			button:SetHighlightFontObject(GameFontHighlight)
+			button:SetNormalTexture(130763) -- "Interface\\Buttons\\UI-DialogBox-Button-Up"
+			button:GetNormalTexture():SetTexCoord(0.0, 1.0, 0.0, 0.71875)
+			button:SetPushedTexture(130761) -- "Interface\\Buttons\\UI-DialogBox-Button-Down"
+			button:GetPushedTexture():SetTexCoord(0.0, 1.0, 0.0, 0.71875)
+			button:SetHighlightTexture(130762) -- "Interface\\Buttons\\UI-DialogBox-Button-Highlight"
+			button:GetHighlightTexture():SetTexCoord(0.0, 1.0, 0.0, 0.71875)
+			button:SetText(newText)
+			return button
+		end
+
+		local accept = newButton(ACCEPT)
+		accept:SetPoint("BOTTOMRIGHT", frame, "BOTTOM", -6, 16)
+		frame.accept = accept
+
+		local cancel = newButton(CANCEL)
+		cancel:SetPoint("LEFT", accept, "RIGHT", 13, 0)
+		frame.cancel = cancel
+	end
+end
+local function confirmPopup(appName, rootframe, basepath, info, message, func, ...)
+	local frame = AceConfigDialog.popup
+	frame:Show()
+	frame.text:SetText(message)
+	-- From StaticPopup.lua
+	-- local height = 32 + text:GetHeight() + 2;
+	-- height = height + 6 + accept:GetHeight()
+	-- We add 32 + 2 + 6 + 21 (button height) == 61
+	local height = 61 + frame.text:GetHeight()
+	frame:SetHeight(height)
+
+	frame.accept:ClearAllPoints()
+	frame.accept:SetPoint("BOTTOMRIGHT", frame, "BOTTOM", -6, 16)
+	frame.cancel:Show()
+
+	local t = {...}
+	local tCount = select("#", ...)
+	frame.accept:SetScript("OnClick", function(self)
+		safecall(func, unpack(t, 1, tCount)) -- Manually set count as unpack() stops on nil (bug with #table)
+		AceConfigDialog:Open(appName, rootframe, unpack(basepath or emptyTbl))
+		frame:Hide()
+		self:SetScript("OnClick", nil)
+		frame.cancel:SetScript("OnClick", nil)
+		del(info)
+	end)
+	frame.cancel:SetScript("OnClick", function(self)
+		AceConfigDialog:Open(appName, rootframe, unpack(basepath or emptyTbl))
+		frame:Hide()
+		self:SetScript("OnClick", nil)
+		frame.accept:SetScript("OnClick", nil)
+		del(info)
+	end)
+end
+
+local function validationErrorPopup(message)
+	local frame = AceConfigDialog.popup
+	frame:Show()
+	frame.text:SetText(message)
+	-- From StaticPopup.lua
+	-- local height = 32 + text:GetHeight() + 2;
+	-- height = height + 6 + accept:GetHeight()
+	-- We add 32 + 2 + 6 + 21 (button height) == 61
+	local height = 61 + frame.text:GetHeight()
+	frame:SetHeight(height)
+
+	frame.accept:ClearAllPoints()
+	frame.accept:SetPoint("BOTTOM", frame, "BOTTOM", 0, 16)
+	frame.cancel:Hide()
+
+	frame.accept:SetScript("OnClick", function()
+		frame:Hide()
+	end)
+end
+
+local function ActivateControl(widget, event, ...)
+	--This function will call the set / execute handler for the widget
+	--widget:GetUserDataTable() contains the needed info
+	local user = widget:GetUserDataTable()
+	local option = user.option
+	local options = user.options
+	local path = user.path
+	local info = new()
+
+	local func
+	local group = options
+	local funcname = GetFuncName(option)
+	local handler
+	local confirm
+	local validate
+	--build the info table containing the path
+	-- pick up functions while traversing the tree
+	if group[funcname] ~= nil then
+		func =  group[funcname]
+	end
+	handler = group.handler
+	confirm = group.confirm
+	validate = group.validate
+	for i = 1, #path do
+		local v = path[i]
+		group = GetSubOption(group, v)
+		info[i] = v
+		if group[funcname] ~= nil then
+			func =  group[funcname]
+		end
+		handler = group.handler or handler
+		if group.confirm ~= nil then
+			confirm = group.confirm
+		end
+		if group.validate ~= nil then
+			validate = group.validate
+		end
+	end
+
+	info.options = options
+	info.appName = user.appName
+	info.arg = option.arg
+	info.handler = handler
+	info.option = option
+	info.type = option.type
+	info.uiType = "dialog"
+	info.uiName = MAJOR
+
+	local name
+	if type(option.name) == "function" then
+		name = option.name(info)
+	elseif type(option.name) == "string" then
+		name = option.name
+	else
+		name = ""
+	end
+	local usage = option.usage
+	local pattern = option.pattern
+
+	local validated = true
+
+	if option.type == "input" then
+		if type(pattern)=="string" then
+			if not strmatch(..., pattern) then
+				validated = false
+			end
+		end
+	end
+
+	local success
+	if validated and option.type ~= "execute" then
+		if type(validate) == "string" then
+			if handler and handler[validate] then
+				success, validated = safecall(handler[validate], handler, info, ...)
+				if not success then validated = false end
+			else
+				error(format("Method %s doesn't exist in handler for type execute", validate))
+			end
+		elseif type(validate) == "function" then
+			success, validated = safecall(validate, info, ...)
+			if not success then validated = false end
+		end
+	end
+
+	if not validated or type(validated) == "string" then
+		if not validated then
+			if usage then
+				validated = name..": "..usage
+			else
+				if pattern then
+					validated = name..": Expected "..pattern
+				else
+					validated = name..": Invalid Value"
+				end
+			end
+		end
+
+		-- show validate message
+		if user.rootframe.SetStatusText then
+			user.rootframe:SetStatusText(validated)
+		else
+			validationErrorPopup(validated)
+		end
+		PlaySound(882) -- SOUNDKIT.IG_PLAYER_INVITE_DECLINE || _DECLINE is actually missing from the table
+		del(info)
+		return true
+	else
+
+		local confirmText = option.confirmText
+		--call confirm func/method
+		if type(confirm) == "string" then
+			if handler and handler[confirm] then
+				success, confirm = safecall(handler[confirm], handler, info, ...)
+				if success and type(confirm) == "string" then
+					confirmText = confirm
+					confirm = true
+				elseif not success then
+					confirm = false
+				end
+			else
+				error(format("Method %s doesn't exist in handler for type confirm", confirm))
+			end
+		elseif type(confirm) == "function" then
+			success, confirm = safecall(confirm, info, ...)
+			if success and type(confirm) == "string" then
+				confirmText = confirm
+				confirm = true
+			elseif not success then
+				confirm = false
+			end
+		end
+
+		--confirm if needed
+		if type(confirm) == "boolean" then
+			if confirm then
+				if not confirmText then
+					local option_name, desc = option.name, option.desc
+					if type(option_name) == "function" then
+						option_name = option_name(info)
+					end
+					if type(desc) == "function" then
+						desc = desc(info)
+					end
+					confirmText = option_name
+					if desc then
+						confirmText = confirmText.." - "..desc
+					end
+				end
+
+				local iscustom = user.rootframe:GetUserData("iscustom")
+				local rootframe
+
+				if iscustom then
+					rootframe = user.rootframe
+				end
+				local basepath = user.rootframe:GetUserData("basepath")
+				if type(func) == "string" then
+					if handler and handler[func] then
+						confirmPopup(user.appName, rootframe, basepath, info, confirmText, handler[func], handler, info, ...)
+					else
+						error(format("Method %s doesn't exist in handler for type func", func))
+					end
+				elseif type(func) == "function" then
+					confirmPopup(user.appName, rootframe, basepath, info, confirmText, func, info, ...)
+				end
+				--func will be called and info deleted when the confirm dialog is responded to
+				return
+			end
+		end
+
+		--call the function
+		if type(func) == "string" then
+			if handler and handler[func] then
+				safecall(handler[func],handler, info, ...)
+			else
+				error(format("Method %s doesn't exist in handler for type func", func))
+			end
+		elseif type(func) == "function" then
+			safecall(func,info, ...)
+		end
+
+
+
+		local iscustom = user.rootframe:GetUserData("iscustom")
+		local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
+		--full refresh of the frame, some controls dont cause this on all events
+		if option.type == "color" then
+			if event == "OnValueConfirmed" then
+
+				if iscustom then
+					AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
+				else
+					AceConfigDialog:Open(user.appName, unpack(basepath))
+				end
+			end
+		elseif option.type == "range" then
+			if event == "OnMouseUp" then
+				if iscustom then
+					AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
+				else
+					AceConfigDialog:Open(user.appName, unpack(basepath))
+				end
+			end
+		--multiselects don't cause a refresh on 'OnValueChanged' only 'OnClosed'
+		elseif option.type == "multiselect" then
+			user.valuechanged = true
+		else
+			if iscustom then
+				AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
+			else
+				AceConfigDialog:Open(user.appName, unpack(basepath))
+			end
+		end
+
+	end
+	del(info)
+end
+
+local function ActivateSlider(widget, event, value)
+	local option = widget:GetUserData("option")
+	local min, max, step = option.min or (not option.softMin and 0 or nil), option.max or (not option.softMax and 100 or nil), option.step
+	if min then
+		if step then
+			value = math_floor((value - min) / step + 0.5) * step + min
+		end
+		value = math_max(value, min)
+	end
+	if max then
+		value = math_min(value, max)
+	end
+	ActivateControl(widget,event,value)
+end
+
+--called from a checkbox that is part of an internally created multiselect group
+--this type is safe to refresh on activation of one control
+local function ActivateMultiControl(widget, event, ...)
+	ActivateControl(widget, event, widget:GetUserData("value"), ...)
+	local user = widget:GetUserDataTable()
+	local iscustom = user.rootframe:GetUserData("iscustom")
+	local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
+	if iscustom then
+		AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
+	else
+		AceConfigDialog:Open(user.appName, unpack(basepath))
+	end
+end
+
+local function MultiControlOnClosed(widget, event, ...)
+	local user = widget:GetUserDataTable()
+	if user.valuechanged and not widget:IsReleasing() then
+		local iscustom = user.rootframe:GetUserData("iscustom")
+		local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
+		if iscustom then
+			AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
+		else
+			AceConfigDialog:Open(user.appName, unpack(basepath))
+		end
+	end
+end
+
+local function FrameOnClose(widget, event)
+	local appName = widget:GetUserData("appName")
+	AceConfigDialog.OpenFrames[appName] = nil
+	gui:Release(widget)
+end
+
+local function CheckOptionHidden(option, options, path, appName)
+	--check for a specific boolean option
+	local hidden = pickfirstset(option.dialogHidden,option.guiHidden)
+	if hidden ~= nil then
+		return hidden
+	end
+
+	return GetOptionsMemberValue("hidden", option, options, path, appName)
+end
+
+local function CheckOptionDisabled(option, options, path, appName)
+	--check for a specific boolean option
+	local disabled = pickfirstset(option.dialogDisabled,option.guiDisabled)
+	if disabled ~= nil then
+		return disabled
+	end
+
+	return GetOptionsMemberValue("disabled", option, options, path, appName)
+end
+--[[
+local function BuildTabs(group, options, path, appName)
+	local tabs = new()
+	local text = new()
+	local keySort = new()
+	local opts = new()
+
+	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
+
+	for i = 1, #keySort do
+		local k = keySort[i]
+		local v = opts[k]
+		if v.type == "group" then
+			path[#path+1] = k
+			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
+			local hidden = CheckOptionHidden(v, options, path, appName)
+			if not inline and not hidden then
+				tinsert(tabs, k)
+				text[k] = GetOptionsMemberValue("name", v, options, path, appName)
+			end
+			path[#path] = nil
+		end
+	end
+
+	del(keySort)
+	del(opts)
+
+	return tabs, text
+end
+]]
+local function BuildSelect(group, options, path, appName)
+	local groups = new()
+	local order = new()
+	local keySort = new()
+	local opts = new()
+
+	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
+
+	for i = 1, #keySort do
+		local k = keySort[i]
+		local v = opts[k]
+		if v.type == "group" then
+			path[#path+1] = k
+			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
+			local hidden = CheckOptionHidden(v, options, path, appName)
+			if not inline and not hidden then
+				groups[k] = GetOptionsMemberValue("name", v, options, path, appName)
+				tinsert(order, k)
+			end
+			path[#path] = nil
+		end
+	end
+
+	del(opts)
+	del(keySort)
+
+	return groups, order
+end
+
+local function BuildSubGroups(group, tree, options, path, appName)
+	local keySort = new()
+	local opts = new()
+
+	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
+
+	for i = 1, #keySort do
+		local k = keySort[i]
+		local v = opts[k]
+		if v.type == "group" then
+			path[#path+1] = k
+			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
+			local hidden = CheckOptionHidden(v, options, path, appName)
+			if not inline and not hidden then
+				local entry = new()
+				entry.value = k
+				entry.text = GetOptionsMemberValue("name", v, options, path, appName)
+				entry.icon = GetOptionsMemberValue("icon", v, options, path, appName)
+				entry.iconCoords = GetOptionsMemberValue("iconCoords", v, options, path, appName)
+				entry.disabled = CheckOptionDisabled(v, options, path, appName)
+				if not tree.children then tree.children = new() end
+				tinsert(tree.children,entry)
+				if (v.childGroups or "tree") == "tree" then
+					BuildSubGroups(v,entry, options, path, appName)
+				end
+			end
+			path[#path] = nil
+		end
+	end
+
+	del(keySort)
+	del(opts)
+end
+
+local function BuildGroups(group, options, path, appName, recurse)
+	local tree = new()
+	local keySort = new()
+	local opts = new()
+
+	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
+
+	for i = 1, #keySort do
+		local k = keySort[i]
+		local v = opts[k]
+		if v.type == "group" then
+			path[#path+1] = k
+			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
+			local hidden = CheckOptionHidden(v, options, path, appName)
+			if not inline and not hidden then
+				local entry = new()
+				entry.value = k
+				entry.text = GetOptionsMemberValue("name", v, options, path, appName)
+				entry.icon = GetOptionsMemberValue("icon", v, options, path, appName)
+				entry.iconCoords = GetOptionsMemberValue("iconCoords", v, options, path, appName)
+				entry.disabled = CheckOptionDisabled(v, options, path, appName)
+				tinsert(tree,entry)
+				if recurse and (v.childGroups or "tree") == "tree" then
+					BuildSubGroups(v,entry, options, path, appName)
+				end
+			end
+			path[#path] = nil
+		end
+	end
+	del(keySort)
+	del(opts)
+	return tree
+end
+
+local function InjectInfo(control, options, option, path, rootframe, appName)
+	local user = control:GetUserDataTable()
+	for i = 1, #path do
+		user[i] = path[i]
+	end
+	user.rootframe = rootframe
+	user.option = option
+	user.options = options
+	user.path = copy(path)
+	user.appName = appName
+	control:SetCallback("OnRelease", CleanUserData)
+	control:SetCallback("OnLeave", OptionOnMouseLeave)
+	control:SetCallback("OnEnter", OptionOnMouseOver)
+end
+
+local function CreateControl(userControlType, fallbackControlType)
+	local control
+	if userControlType then
+		control = gui:Create(userControlType)
+		if not control then
+			geterrorhandler()(("Invalid Custom Control Type - %s"):format(tostring(userControlType)))
+		end
+	end
+	if not control then
+		control = gui:Create(fallbackControlType)
+	end
+	return control
+end
+
+local function sortTblAsStrings(x,y)
+	return tostring(x) < tostring(y) -- Support numbers as keys
+end
+
+--[[
+	options - root of the options table being fed
+	container - widget that controls will be placed in
+	rootframe - Frame object the options are in
+	path - table with the keys to get to the group being fed
+--]]
+
+local function FeedOptions(appName, options,container,rootframe,path,group,inline)
+	local keySort = new()
+	local opts = new()
+
+	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
+
+	for i = 1, #keySort do
+		local k = keySort[i]
+		local v = opts[k]
+		tinsert(path, k)
+		local hidden = CheckOptionHidden(v, options, path, appName)
+		local name = GetOptionsMemberValue("name", v, options, path, appName)
+		if not hidden then
+			if v.type == "group" then
+				if inline or pickfirstset(v.dialogInline,v.guiInline,v.inline, false) then
+					--Inline group
+					local GroupContainer
+					if name and name ~= "" then
+						GroupContainer = gui:Create("InlineGroup")
+						GroupContainer:SetTitle(name or "")
+					else
+						GroupContainer = gui:Create("SimpleGroup")
+					end
+
+					GroupContainer.width = "fill"
+					GroupContainer:SetLayout("flow")
+					container:AddChild(GroupContainer)
+					FeedOptions(appName,options,GroupContainer,rootframe,path,v,true)
+				end
+			else
+				--Control to feed
+				local control
+
+				if v.type == "execute" then
+
+					local imageCoords = GetOptionsMemberValue("imageCoords",v, options, path, appName)
+					local image, width, height = GetOptionsMemberValue("image",v, options, path, appName)
+
+					local iconControl = type(image) == "string" or type(image) == "number"
+					control = CreateControl(v.dialogControl or v.control, iconControl and "Icon" or "Button")
+					if iconControl then
+						if not width then
+							width = GetOptionsMemberValue("imageWidth",v, options, path, appName)
+						end
+						if not height then
+							height = GetOptionsMemberValue("imageHeight",v, options, path, appName)
+						end
+						if type(imageCoords) == "table" then
+							control:SetImage(image, unpack(imageCoords))
+						else
+							control:SetImage(image)
+						end
+						if type(width) ~= "number" then
+							width = 32
+						end
+						if type(height) ~= "number" then
+							height = 32
+						end
+						control:SetImageSize(width, height)
+						control:SetLabel(name)
+					else
+						control:SetText(name)
+					end
+					control:SetCallback("OnClick",ActivateControl)
+
+				elseif v.type == "input" then
+					control = CreateControl(v.dialogControl or v.control, v.multiline and "MultiLineEditBox" or "EditBox")
+
+					if v.multiline and control.SetNumLines then
+						control:SetNumLines(tonumber(v.multiline) or 4)
+					end
+					control:SetLabel(name)
+					control:SetCallback("OnEnterPressed",ActivateControl)
+					local text = GetOptionsMemberValue("get",v, options, path, appName)
+					if type(text) ~= "string" then
+						text = ""
+					end
+					control:SetText(text)
+
+				elseif v.type == "toggle" then
+					control = CreateControl(v.dialogControl or v.control, "CheckBox")
+					control:SetLabel(name)
+					control:SetTriState(v.tristate)
+					local value = GetOptionsMemberValue("get",v, options, path, appName)
+					control:SetValue(value)
+					control:SetCallback("OnValueChanged",ActivateControl)
+
+					if v.descStyle == "inline" then
+						local desc = GetOptionsMemberValue("desc", v, options, path, appName)
+						control:SetDescription(desc)
+					end
+
+					local image = GetOptionsMemberValue("image", v, options, path, appName)
+					local imageCoords = GetOptionsMemberValue("imageCoords", v, options, path, appName)
+
+					if type(image) == "string" or type(image) == "number" then
+						if type(imageCoords) == "table" then
+							control:SetImage(image, unpack(imageCoords))
+						else
+							control:SetImage(image)
+						end
+					end
+				elseif v.type == "range" then
+					control = CreateControl(v.dialogControl or v.control, "Slider")
+					control:SetLabel(name)
+					control:SetSliderValues(v.softMin or v.min or 0, v.softMax or v.max or 100, v.bigStep or v.step or 0)
+					control:SetIsPercent(v.isPercent)
+					local value = GetOptionsMemberValue("get",v, options, path, appName)
+					if type(value) ~= "number" then
+						value = 0
+					end
+					control:SetValue(value)
+					control:SetCallback("OnValueChanged",ActivateSlider)
+					control:SetCallback("OnMouseUp",ActivateSlider)
+
+				elseif v.type == "select" then
+					local values = GetOptionsMemberValue("values", v, options, path, appName)
+					local sorting = GetOptionsMemberValue("sorting", v, options, path, appName)
+					if v.style == "radio" then
+						local disabled = CheckOptionDisabled(v, options, path, appName)
+						local width = GetOptionsMemberValue("width",v,options,path,appName)
+						control = gui:Create("InlineGroup")
+						control:SetLayout("Flow")
+						control:SetTitle(name)
+						control.width = "fill"
+
+						control:PauseLayout()
+						local optionValue = GetOptionsMemberValue("get",v, options, path, appName)
+						if not sorting then
+							sorting = {}
+							for value, text in pairs(values) do
+								sorting[#sorting+1]=value
+							end
+							tsort(sorting, sortTblAsStrings)
+						end
+						for _, value in ipairs(sorting) do
+							local text = values[value]
+							local radio = gui:Create("CheckBox")
+							radio:SetLabel(text)
+							radio:SetUserData("value", value)
+							radio:SetUserData("text", text)
+							radio:SetDisabled(disabled)
+							radio:SetType("radio")
+							radio:SetValue(optionValue == value)
+							radio:SetCallback("OnValueChanged", ActivateMultiControl)
+							InjectInfo(radio, options, v, path, rootframe, appName)
+							control:AddChild(radio)
+							if width == "double" then
+								radio:SetWidth(width_multiplier * 2)
+							elseif width == "half" then
+								radio:SetWidth(width_multiplier / 2)
+							elseif (type(width) == "number") then
+								radio:SetWidth(width_multiplier * width)
+							elseif width == "full" then
+								radio.width = "fill"
+							else
+								radio:SetWidth(width_multiplier)
+							end
+						end
+						control:ResumeLayout()
+						control:DoLayout()
+					else
+						control = CreateControl(v.dialogControl or v.control, "Dropdown")
+						local itemType = v.itemControl
+						if itemType and not gui:GetWidgetVersion(itemType) then
+							geterrorhandler()(("Invalid Custom Item Type - %s"):format(tostring(itemType)))
+							itemType = nil
+						end
+						control:SetLabel(name)
+						control:SetList(values, sorting, itemType)
+						local value = GetOptionsMemberValue("get",v, options, path, appName)
+						if not values[value] then
+							value = nil
+						end
+						control:SetValue(value)
+						control:SetCallback("OnValueChanged", ActivateControl)
+					end
+
+				elseif v.type == "multiselect" then
+					local values = GetOptionsMemberValue("values", v, options, path, appName)
+					local disabled = CheckOptionDisabled(v, options, path, appName)
+
+					local valuesort = new()
+					if values then
+						for value, text in pairs(values) do
+							tinsert(valuesort, value)
+						end
+					end
+					tsort(valuesort)
+
+					local controlType = v.dialogControl or v.control
+					if controlType then
+						control = gui:Create(controlType)
+						if not control then
+							geterrorhandler()(("Invalid Custom Control Type - %s"):format(tostring(controlType)))
+						end
+					end
+					if control then
+						control:SetMultiselect(true)
+						control:SetLabel(name)
+						control:SetList(values)
+						control:SetDisabled(disabled)
+						control:SetCallback("OnValueChanged",ActivateControl)
+						control:SetCallback("OnClosed", MultiControlOnClosed)
+						local width = GetOptionsMemberValue("width",v,options,path,appName)
+						if width == "double" then
+							control:SetWidth(width_multiplier * 2)
+						elseif width == "half" then
+							control:SetWidth(width_multiplier / 2)
+						elseif (type(width) == "number") then
+							control:SetWidth(width_multiplier * width)
+						elseif width == "full" then
+							control.width = "fill"
+						else
+							control:SetWidth(width_multiplier)
+						end
+						--check:SetTriState(v.tristate)
+						for s = 1, #valuesort do
+							local key = valuesort[s]
+							local value = GetOptionsMemberValue("get",v, options, path, appName, key)
+							control:SetItemValue(key,value)
+						end
+					else
+						control = gui:Create("InlineGroup")
+						control:SetLayout("Flow")
+						control:SetTitle(name)
+						control.width = "fill"
+
+						control:PauseLayout()
+						local width = GetOptionsMemberValue("width",v,options,path,appName)
+						for s = 1, #valuesort do
+							local value = valuesort[s]
+							local text = values[value]
+							local check = gui:Create("CheckBox")
+							check:SetLabel(text)
+							check:SetUserData("value", value)
+							check:SetUserData("text", text)
+							check:SetDisabled(disabled)
+							check:SetTriState(v.tristate)
+							check:SetValue(GetOptionsMemberValue("get",v, options, path, appName, value))
+							check:SetCallback("OnValueChanged",ActivateMultiControl)
+							InjectInfo(check, options, v, path, rootframe, appName)
+							control:AddChild(check)
+							if width == "double" then
+								check:SetWidth(width_multiplier * 2)
+							elseif width == "half" then
+								check:SetWidth(width_multiplier / 2)
+							elseif (type(width) == "number") then
+								check:SetWidth(width_multiplier * width)
+							elseif width == "full" then
+								check.width = "fill"
+							else
+								check:SetWidth(width_multiplier)
+							end
+						end
+						control:ResumeLayout()
+						control:DoLayout()
+
+
+					end
+
+					del(valuesort)
+
+				elseif v.type == "color" then
+					control = CreateControl(v.dialogControl or v.control, "ColorPicker")
+					control:SetLabel(name)
+					control:SetHasAlpha(GetOptionsMemberValue("hasAlpha",v, options, path, appName))
+					control:SetColor(GetOptionsMemberValue("get",v, options, path, appName))
+					control:SetCallback("OnValueChanged",ActivateControl)
+					control:SetCallback("OnValueConfirmed",ActivateControl)
+
+				elseif v.type == "keybinding" then
+					control = CreateControl(v.dialogControl or v.control, "Keybinding")
+					control:SetLabel(name)
+					control:SetKey(GetOptionsMemberValue("get",v, options, path, appName))
+					control:SetCallback("OnKeyChanged",ActivateControl)
+
+				elseif v.type == "header" then
+					control = CreateControl(v.dialogControl or v.control, "Heading")
+					control:SetText(name)
+					control.width = "fill"
+
+				elseif v.type == "description" then
+					control = CreateControl(v.dialogControl or v.control, "Label")
+					control:SetText(name)
+
+					local fontSize = GetOptionsMemberValue("fontSize",v, options, path, appName)
+					if fontSize == "medium" then
+						control:SetFontObject(GameFontHighlight)
+					elseif fontSize == "large" then
+						control:SetFontObject(GameFontHighlightLarge)
+					else -- small or invalid
+						control:SetFontObject(GameFontHighlightSmall)
+					end
+
+					local imageCoords = GetOptionsMemberValue("imageCoords",v, options, path, appName)
+					local image, width, height = GetOptionsMemberValue("image",v, options, path, appName)
+
+					if type(image) == "string" or type(image) == "number" then
+						if not width then
+							width = GetOptionsMemberValue("imageWidth",v, options, path, appName)
+						end
+						if not height then
+							height = GetOptionsMemberValue("imageHeight",v, options, path, appName)
+						end
+						if type(imageCoords) == "table" then
+							control:SetImage(image, unpack(imageCoords))
+						else
+							control:SetImage(image)
+						end
+						if type(width) ~= "number" then
+							width = 32
+						end
+						if type(height) ~= "number" then
+							height = 32
+						end
+						control:SetImageSize(width, height)
+					end
+					local controlWidth = GetOptionsMemberValue("width",v,options,path,appName)
+					control.width = not controlWidth and "fill"
+				end
+
+				--Common Init
+				if control then
+					if control.width ~= "fill" then
+						local width = GetOptionsMemberValue("width",v,options,path,appName)
+						if width == "double" then
+							control:SetWidth(width_multiplier * 2)
+						elseif width == "half" then
+							control:SetWidth(width_multiplier / 2)
+						elseif (type(width) == "number") then
+							control:SetWidth(width_multiplier * width)
+						elseif width == "full" then
+							control.width = "fill"
+						else
+							control:SetWidth(width_multiplier)
+						end
+					end
+					if control.SetDisabled then
+						local disabled = CheckOptionDisabled(v, options, path, appName)
+						control:SetDisabled(disabled)
+					end
+
+					InjectInfo(control, options, v, path, rootframe, appName)
+					container:AddChild(control)
+				end
+
+			end
+		end
+		tremove(path)
+	end
+	container:ResumeLayout()
+	container:DoLayout()
+	del(keySort)
+	del(opts)
+end
+
+local function BuildPath(path, ...)
+	for i = 1, select("#",...)  do
+		tinsert(path, (select(i,...)))
+	end
+end
+
+
+local function TreeOnButtonEnter(widget, event, uniquevalue, button)
+	local user = widget:GetUserDataTable()
+	if not user then return end
+	local options = user.options
+	local option = user.option
+	local path = user.path
+	local appName = user.appName
+	local tooltip = AceConfigDialog.tooltip
+
+	local feedpath = new()
+	for i = 1, #path do
+		feedpath[i] = path[i]
+	end
+
+	BuildPath(feedpath, ("\001"):split(uniquevalue))
+	local group = options
+	for i = 1, #feedpath do
+		if not group then return end
+		group = GetSubOption(group, feedpath[i])
+	end
+
+	local name = GetOptionsMemberValue("name", group, options, feedpath, appName)
+	local desc = GetOptionsMemberValue("desc", group, options, feedpath, appName)
+
+	tooltip:SetOwner(button, "ANCHOR_NONE")
+	tooltip:ClearAllPoints()
+	if widget.type == "TabGroup" then
+		tooltip:SetPoint("BOTTOM",button,"TOP")
+	else
+		tooltip:SetPoint("LEFT",button,"RIGHT")
+	end
+
+	tooltip:SetText(name, 1, .82, 0, true)
+
+	if type(desc) == "string" then
+		tooltip:AddLine(desc, 1, 1, 1, true)
+	end
+
+	tooltip:Show()
+end
+
+local function TreeOnButtonLeave(widget, event, value, button)
+	AceConfigDialog.tooltip:Hide()
+end
+
+
+local function GroupExists(appName, options, path, uniquevalue)
+	if not uniquevalue then return false end
+
+	local feedpath = new()
+	local temppath = new()
+	for i = 1, #path do
+		feedpath[i] = path[i]
+	end
+
+	BuildPath(feedpath, ("\001"):split(uniquevalue))
+
+	local group = options
+	for i = 1, #feedpath do
+		local v = feedpath[i]
+		temppath[i] = v
+		group = GetSubOption(group, v)
+
+		if not group or group.type ~= "group" or CheckOptionHidden(group, options, temppath, appName) then
+			del(feedpath)
+			del(temppath)
+			return false
+		end
+	end
+	del(feedpath)
+	del(temppath)
+	return true
+end
+
+local function GroupSelected(widget, event, uniquevalue)
+
+	local user = widget:GetUserDataTable()
+
+	local options = user.options
+	local option = user.option
+	local path = user.path
+	local rootframe = user.rootframe
+
+	local feedpath = new()
+	for i = 1, #path do
+		feedpath[i] = path[i]
+	end
+
+	BuildPath(feedpath, ("\001"):split(uniquevalue))
+	widget:ReleaseChildren()
+	AceConfigDialog:FeedGroup(user.appName,options,widget,rootframe,feedpath)
+
+	del(feedpath)
+end
+
+
+
+--[[
+-- INTERNAL --
+This function will feed one group, and any inline child groups into the given container
+Select Groups will only have the selection control (tree, tabs, dropdown) fed in
+and have a group selected, this event will trigger the feeding of child groups
+
+Rules:
+	If the group is Inline, FeedOptions
+	If the group has no child groups, FeedOptions
+
+	If the group is a tab or select group, FeedOptions then add the Group Control
+	If the group is a tree group FeedOptions then
+		its parent isnt a tree group:  then add the tree control containing this and all child tree groups
+		if its parent is a tree group, its already a node on a tree
+--]]
+
+function AceConfigDialog:FeedGroup(appName,options,container,rootframe,path, isRoot)
+	local group = options
+	--follow the path to get to the curent group
+	local inline
+	local grouptype, parenttype = options.childGroups, "none"
+
+
+	for i = 1, #path do
+		local v = path[i]
+		group = GetSubOption(group, v)
+		inline = inline or pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
+		parenttype = grouptype
+		grouptype = group.childGroups
+	end
+
+	if not parenttype then
+		parenttype = "tree"
+	end
+
+	--check if the group has child groups
+	local hasChildGroups
+	for k, v in pairs(group.args) do
+		if v.type == "group" and not pickfirstset(v.dialogInline,v.guiInline,v.inline, false) and not CheckOptionHidden(v, options, path, appName) then
+			hasChildGroups = true
+		end
+	end
+	if group.plugins then
+		for plugin, t in pairs(group.plugins) do
+			for k, v in pairs(t) do
+				if v.type == "group" and not pickfirstset(v.dialogInline,v.guiInline,v.inline, false) and not CheckOptionHidden(v, options, path, appName) then
+					hasChildGroups = true
+				end
+			end
+		end
+	end
+
+	container:SetLayout("flow")
+	local scroll
+
+	--Add a scrollframe if we are not going to add a group control, this is the inverse of the conditions for that later on
+	if (not (hasChildGroups and not inline)) or (grouptype ~= "tab" and grouptype ~= "select" and (parenttype == "tree" and not isRoot)) then
+		if container.type ~= "InlineGroup" and container.type ~= "SimpleGroup" then
+			scroll = gui:Create("ScrollFrame")
+			scroll:SetLayout("flow")
+			scroll.width = "fill"
+			scroll.height = "fill"
+			container:SetLayout("fill")
+			container:AddChild(scroll)
+			container = scroll
+		end
+	end
+
+	FeedOptions(appName,options,container,rootframe,path,group,nil)
+
+	if scroll then
+		container:PerformLayout()
+		local status = self:GetStatusTable(appName, path)
+		if not status.scroll then
+			status.scroll = {}
+		end
+		scroll:SetStatusTable(status.scroll)
+	end
+
+	if hasChildGroups and not inline then
+		local name = GetOptionsMemberValue("name", group, options, path, appName)
+		if grouptype == "tab" then
+
+			local tab = gui:Create("TabGroup")
+			InjectInfo(tab, options, group, path, rootframe, appName)
+			tab:SetCallback("OnGroupSelected", GroupSelected)
+			tab:SetCallback("OnTabEnter", TreeOnButtonEnter)
+			tab:SetCallback("OnTabLeave", TreeOnButtonLeave)
+
+			local status = AceConfigDialog:GetStatusTable(appName, path)
+			if not status.groups then
+				status.groups = {}
+			end
+			tab:SetStatusTable(status.groups)
+			tab.width = "fill"
+			tab.height = "fill"
+
+			local tabs = BuildGroups(group, options, path, appName)
+			tab:SetTabs(tabs)
+			tab:SetUserData("tablist", tabs)
+
+			for i = 1, #tabs do
+				local entry = tabs[i]
+				if not entry.disabled then
+					tab:SelectTab((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or entry.value)
+					break
+				end
+			end
+
+			container:AddChild(tab)
+
+		elseif grouptype == "select" then
+
+			local selectGroup = gui:Create("DropdownGroup")
+			selectGroup:SetTitle(name)
+			InjectInfo(selectGroup, options, group, path, rootframe, appName)
+			selectGroup:SetCallback("OnGroupSelected", GroupSelected)
+			local status = AceConfigDialog:GetStatusTable(appName, path)
+			if not status.groups then
+				status.groups = {}
+			end
+			selectGroup:SetStatusTable(status.groups)
+			local grouplist, orderlist = BuildSelect(group, options, path, appName)
+			selectGroup:SetGroupList(grouplist, orderlist)
+			selectGroup:SetUserData("grouplist", grouplist)
+			selectGroup:SetUserData("orderlist", orderlist)
+
+			local firstgroup = orderlist[1]
+			if firstgroup then
+				selectGroup:SetGroup((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or firstgroup)
+			end
+
+			selectGroup.width = "fill"
+			selectGroup.height = "fill"
+
+			container:AddChild(selectGroup)
+
+		--assume tree group by default
+		--if parenttype is tree then this group is already a node on that tree
+		elseif (parenttype ~= "tree") or isRoot then
+			local tree = gui:Create("TreeGroup")
+			InjectInfo(tree, options, group, path, rootframe, appName)
+			tree:EnableButtonTooltips(false)
+
+			tree.width = "fill"
+			tree.height = "fill"
+
+			tree:SetCallback("OnGroupSelected", GroupSelected)
+			tree:SetCallback("OnButtonEnter", TreeOnButtonEnter)
+			tree:SetCallback("OnButtonLeave", TreeOnButtonLeave)
+
+			local status = AceConfigDialog:GetStatusTable(appName, path)
+			if not status.groups then
+				status.groups = {}
+			end
+			local treedefinition = BuildGroups(group, options, path, appName, true)
+			tree:SetStatusTable(status.groups)
+
+			tree:SetTree(treedefinition)
+			tree:SetUserData("tree",treedefinition)
+
+			for i = 1, #treedefinition do
+				local entry = treedefinition[i]
+				if not entry.disabled then
+					tree:SelectByValue((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or entry.value)
+					break
+				end
+			end
+
+			container:AddChild(tree)
+		end
+	end
+end
+
+local old_CloseSpecialWindows
+
+
+local function RefreshOnUpdate(this)
+	for appName in pairs(this.closing) do
+		if AceConfigDialog.OpenFrames[appName] then
+			AceConfigDialog.OpenFrames[appName]:Hide()
+		end
+		if AceConfigDialog.BlizOptions and AceConfigDialog.BlizOptions[appName] then
+			for key, widget in pairs(AceConfigDialog.BlizOptions[appName]) do
+				if not widget:IsVisible() then
+					widget:ReleaseChildren()
+				end
+			end
+		end
+		this.closing[appName] = nil
+	end
+
+	if this.closeAll then
+		for k, v in pairs(AceConfigDialog.OpenFrames) do
+			if not this.closeAllOverride[k] then
+				v:Hide()
+			end
+		end
+		this.closeAll = nil
+		wipe(this.closeAllOverride)
+	end
+
+	for appName in pairs(this.apps) do
+		if AceConfigDialog.OpenFrames[appName] then
+			local user = AceConfigDialog.OpenFrames[appName]:GetUserDataTable()
+			AceConfigDialog:Open(appName, unpack(user.basepath or emptyTbl))
+		end
+		if AceConfigDialog.BlizOptions and AceConfigDialog.BlizOptions[appName] then
+			for key, widget in pairs(AceConfigDialog.BlizOptions[appName]) do
+				local user = widget:GetUserDataTable()
+				if widget:IsVisible() then
+					AceConfigDialog:Open(widget:GetUserData("appName"), widget, unpack(user.basepath or emptyTbl))
+				end
+			end
+		end
+		this.apps[appName] = nil
+	end
+	this:SetScript("OnUpdate", nil)
+end
+
+-- Upgrade the OnUpdate script as well, if needed.
+if AceConfigDialog.frame:GetScript("OnUpdate") then
+	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
+end
+
+--- Close all open options windows
+function AceConfigDialog:CloseAll()
+	AceConfigDialog.frame.closeAll = true
+	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
+	if next(self.OpenFrames) then
+		return true
+	end
+end
+
+--- Close a specific options window.
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+function AceConfigDialog:Close(appName)
+	if self.OpenFrames[appName] then
+		AceConfigDialog.frame.closing[appName] = true
+		AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
+		return true
+	end
+end
+
+-- Internal -- Called by AceConfigRegistry
+function AceConfigDialog:ConfigTableChanged(event, appName)
+	AceConfigDialog.frame.apps[appName] = true
+	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
+end
+
+reg.RegisterCallback(AceConfigDialog, "ConfigTableChange", "ConfigTableChanged")
+
+--- Sets the default size of the options window for a specific application.
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+-- @param width The default width
+-- @param height The default height
+function AceConfigDialog:SetDefaultSize(appName, width, height)
+	local status = AceConfigDialog:GetStatusTable(appName)
+	if type(width) == "number" and type(height) == "number" then
+		status.width = width
+		status.height = height
+	end
+end
+
+--- Open an option window at the specified path (if any).
+-- This function can optionally feed the group into a pre-created container
+-- instead of creating a new container frame.
+-- @paramsig appName [, container][, ...]
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+-- @param container An optional container frame to feed the options into
+-- @param ... The path to open after creating the options window (see `:SelectGroup` for details)
+function AceConfigDialog:Open(appName, container, ...)
+	if not old_CloseSpecialWindows then
+		old_CloseSpecialWindows = CloseSpecialWindows
+		CloseSpecialWindows = function()
+			local found = old_CloseSpecialWindows()
+			return self:CloseAll() or found
+		end
+	end
+	local app = reg:GetOptionsTable(appName)
+	if not app then
+		error(("%s isn't registed with AceConfigRegistry, unable to open config"):format(appName), 2)
+	end
+	local options = app("dialog", MAJOR)
+
+	local f
+
+	local path = new()
+	local name = GetOptionsMemberValue("name", options, options, path, appName)
+
+	--If an optional path is specified add it to the path table before feeding the options
+	--as container is optional as well it may contain the first element of the path
+	if type(container) == "string" then
+		tinsert(path, container)
+		container = nil
+	end
+	for n = 1, select("#",...) do
+		tinsert(path, (select(n, ...)))
+	end
+
+	local option = options
+	if type(container) == "table" and container.type == "BlizOptionsGroup" and #path > 0 then
+		for i = 1, #path do
+			option = options.args[path[i]]
+		end
+		name = format("%s - %s", name, GetOptionsMemberValue("name", option, options, path, appName))
+	end
+
+	--if a container is given feed into that
+	if container then
+		f = container
+		f:ReleaseChildren()
+		f:SetUserData("appName", appName)
+		f:SetUserData("iscustom", true)
+		if #path > 0 then
+			f:SetUserData("basepath", copy(path))
+		end
+		local status = AceConfigDialog:GetStatusTable(appName)
+		if not status.width then
+			status.width =  700
+		end
+		if not status.height then
+			status.height = 500
+		end
+		if f.SetStatusTable then
+			f:SetStatusTable(status)
+		end
+		if f.SetTitle then
+			f:SetTitle(name or "")
+		end
+	else
+		if not self.OpenFrames[appName] then
+			f = gui:Create("Frame")
+			self.OpenFrames[appName] = f
+		else
+			f = self.OpenFrames[appName]
+		end
+		f:ReleaseChildren()
+		f:SetCallback("OnClose", FrameOnClose)
+		f:SetUserData("appName", appName)
+		if #path > 0 then
+			f:SetUserData("basepath", copy(path))
+		end
+		f:SetTitle(name or "")
+		local status = AceConfigDialog:GetStatusTable(appName)
+		f:SetStatusTable(status)
+	end
+
+	self:FeedGroup(appName,options,f,f,path,true)
+	if f.Show then
+		f:Show()
+	end
+	del(path)
+
+	if AceConfigDialog.frame.closeAll then
+		-- close all is set, but thats not good, since we're just opening here, so force it
+		AceConfigDialog.frame.closeAllOverride[appName] = true
+	end
+end
+
+-- convert pre-39 BlizOptions structure to the new format
+if oldminor and oldminor < 39 and AceConfigDialog.BlizOptions then
+	local old = AceConfigDialog.BlizOptions
+	local newOpt = {}
+	for key, widget in pairs(old) do
+		local appName = widget:GetUserData("appName")
+		if not newOpt[appName] then newOpt[appName] = {} end
+		newOpt[appName][key] = widget
+	end
+	AceConfigDialog.BlizOptions = newOpt
+else
+	AceConfigDialog.BlizOptions = AceConfigDialog.BlizOptions or {}
+end
+
+local function FeedToBlizPanel(widget, event)
+	local path = widget:GetUserData("path")
+	AceConfigDialog:Open(widget:GetUserData("appName"), widget, unpack(path or emptyTbl))
+end
+
+local function ClearBlizPanel(widget, event)
+	local appName = widget:GetUserData("appName")
+	AceConfigDialog.frame.closing[appName] = true
+	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
+end
+
+--- Add an option table into the Blizzard Interface Options panel.
+-- You can optionally supply a descriptive name to use and a parent frame to use,
+-- as well as a path in the options table.\\
+-- If no name is specified, the appName will be used instead.
+--
+-- If you specify a proper `parent` (by name), the interface options will generate a
+-- tree layout. Note that only one level of children is supported, so the parent always
+-- has to be a head-level note.
+--
+-- This function returns a reference to the container frame registered with the Interface
+-- Options. You can use this reference to open the options with the API function
+-- `InterfaceOptionsFrame_OpenToCategory`.
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+-- @param name A descriptive name to display in the options tree (defaults to appName)
+-- @param parent The parent to use in the interface options tree.
+-- @param ... The path in the options table to feed into the interface options panel.
+-- @return The reference to the frame registered into the Interface Options.
+-- @return The category ID to pass to Settings.OpenToCategory (or InterfaceOptionsFrame_OpenToCategory)
+function AceConfigDialog:AddToBlizOptions(appName, name, parent, ...)
+	local BlizOptions = AceConfigDialog.BlizOptions
+
+	local key = appName
+	for n = 1, select("#", ...) do
+		key = key.."\001"..select(n, ...)
+	end
+
+	if not BlizOptions[appName] then
+		BlizOptions[appName] = {}
+	end
+
+	if not BlizOptions[appName][key] then
+		local group = gui:Create("BlizOptionsGroup")
+		BlizOptions[appName][key] = group
+
+		group:SetTitle(name or appName)
+		group:SetUserData("appName", appName)
+		if select("#", ...) > 0 then
+			local path = {}
+			for n = 1, select("#",...) do
+				tinsert(path, (select(n, ...)))
+			end
+			group:SetUserData("path", path)
+		end
+		group:SetCallback("OnShow", FeedToBlizPanel)
+		group:SetCallback("OnHide", ClearBlizPanel)
+		if Settings and Settings.RegisterCanvasLayoutCategory then
+			local categoryName = name or appName
+			if parent then
+				local category = Settings.GetCategory(parent)
+				if not category then
+					error(("The parent category '%s' was not found"):format(parent), 2)
+				end
+				local subcategory = Settings.RegisterCanvasLayoutSubcategory(category, group.frame, categoryName)
+
+				-- force the generated ID to be used for subcategories, as these can have very simple names like "Profiles"
+				group:SetName(subcategory.ID, parent)
+			else
+				local category = Settings.RegisterCanvasLayoutCategory(group.frame, categoryName)
+				-- using appName here would be cleaner, but would not be 100% compatible
+				-- but for top-level categories it should be fine, as these are typically addon names
+				category.ID = categoryName
+				group:SetName(categoryName, parent)
+				Settings.RegisterAddOnCategory(category)
+			end
+		else
+			group:SetName(name or appName, parent)
+			InterfaceOptions_AddCategory(group.frame)
+		end
+		return group.frame, group.frame.name
+	else
+		error(("%s has already been added to the Blizzard Options Window with the given path"):format(appName), 2)
+	end
+end
diff --git a/Carbonite/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.xml b/Carbonite/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.xml
index 068be6f..8e1e606 100644
--- a/Carbonite/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.xml
+++ b/Carbonite/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceConfigDialog-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceConfigDialog-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.lua b/Carbonite/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.lua
index 175224d..e0f5962 100644
--- a/Carbonite/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.lua
+++ b/Carbonite/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.lua
@@ -1,372 +1,372 @@
---- AceConfigRegistry-3.0 handles central registration of options tables in use by addons and modules.\\
--- Options tables can be registered as raw tables, OR as function refs that return a table.\\
--- Such functions receive three arguments: "uiType", "uiName", "appName". \\
--- * Valid **uiTypes**: "cmd", "dropdown", "dialog". This is verified by the library at call time. \\
--- * The **uiName** field is expected to contain the full name of the calling addon, including version, e.g. "FooBar-1.0". This is verified by the library at call time.\\
--- * The **appName** field is the options table name as given at registration time \\
---
--- :IterateOptionsTables() (and :GetOptionsTable() if only given one argument) return a function reference that the requesting config handling addon must call with valid "uiType", "uiName".
--- @class file
--- @name AceConfigRegistry-3.0
--- @release $Id: AceConfigRegistry-3.0.lua 1296 2022-11-04 18:50:10Z nevcairiel $
-local CallbackHandler = LibStub("CallbackHandler-1.0")
-
-local MAJOR, MINOR = "AceConfigRegistry-3.0", 21
-local AceConfigRegistry = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceConfigRegistry then return end
-
-AceConfigRegistry.tables = AceConfigRegistry.tables or {}
-
-if not AceConfigRegistry.callbacks then
-	AceConfigRegistry.callbacks = CallbackHandler:New(AceConfigRegistry)
-end
-
--- Lua APIs
-local tinsert, tconcat = table.insert, table.concat
-local strfind, strmatch = string.find, string.match
-local type, tostring, select, pairs = type, tostring, select, pairs
-local error, assert = error, assert
-
------------------------------------------------------------------------
--- Validating options table consistency:
-
-
-AceConfigRegistry.validated = {
-	-- list of options table names ran through :ValidateOptionsTable automatically.
-	-- CLEARED ON PURPOSE, since newer versions may have newer validators
-	cmd = {},
-	dropdown = {},
-	dialog = {},
-}
-
-
-
-local function err(msg, errlvl, ...)
-	local t = {}
-	for i=select("#",...),1,-1 do
-		tinsert(t, (select(i, ...)))
-	end
-	error(MAJOR..":ValidateOptionsTable(): "..tconcat(t,".")..msg, errlvl+2)
-end
-
-
-local isstring={["string"]=true, _="string"}
-local isstringfunc={["string"]=true,["function"]=true, _="string or funcref"}
-local istable={["table"]=true,   _="table"}
-local ismethodtable={["table"]=true,["string"]=true,["function"]=true,   _="methodname, funcref or table"}
-local optstring={["nil"]=true,["string"]=true, _="string"}
-local optstringfunc={["nil"]=true,["string"]=true,["function"]=true, _="string or funcref"}
-local optstringnumberfunc={["nil"]=true,["string"]=true,["number"]=true,["function"]=true, _="string, number or funcref"}
-local optnumber={["nil"]=true,["number"]=true, _="number"}
-local optmethodfalse={["nil"]=true,["string"]=true,["function"]=true,["boolean"]={[false]=true},  _="methodname, funcref or false"}
-local optmethodnumber={["nil"]=true,["string"]=true,["function"]=true,["number"]=true,  _="methodname, funcref or number"}
-local optmethodtable={["nil"]=true,["string"]=true,["function"]=true,["table"]=true,  _="methodname, funcref or table"}
-local optmethodbool={["nil"]=true,["string"]=true,["function"]=true,["boolean"]=true,  _="methodname, funcref or boolean"}
-local opttable={["nil"]=true,["table"]=true,  _="table"}
-local optbool={["nil"]=true,["boolean"]=true,  _="boolean"}
-local optboolnumber={["nil"]=true,["boolean"]=true,["number"]=true,  _="boolean or number"}
-local optstringnumber={["nil"]=true,["string"]=true,["number"]=true, _="string or number"}
-
-local basekeys={
-	type=isstring,
-	name=isstringfunc,
-	desc=optstringfunc,
-	descStyle=optstring,
-	order=optmethodnumber,
-	validate=optmethodfalse,
-	confirm=optmethodbool,
-	confirmText=optstring,
-	disabled=optmethodbool,
-	hidden=optmethodbool,
-		guiHidden=optmethodbool,
-		dialogHidden=optmethodbool,
-		dropdownHidden=optmethodbool,
-	cmdHidden=optmethodbool,
-	tooltipHyperlink=optstringfunc,
-	icon=optstringnumberfunc,
-	iconCoords=optmethodtable,
-	handler=opttable,
-	get=optmethodfalse,
-	set=optmethodfalse,
-	func=optmethodfalse,
-	arg={["*"]=true},
-	width=optstringnumber,
-}
-
-local typedkeys={
-	header={
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-	},
-	description={
-		image=optstringnumberfunc,
-		imageCoords=optmethodtable,
-		imageHeight=optnumber,
-		imageWidth=optnumber,
-		fontSize=optstringfunc,
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-	},
-	group={
-		args=istable,
-		plugins=opttable,
-		inline=optbool,
-			cmdInline=optbool,
-			guiInline=optbool,
-			dropdownInline=optbool,
-			dialogInline=optbool,
-		childGroups=optstring,
-	},
-	execute={
-		image=optstringnumberfunc,
-		imageCoords=optmethodtable,
-		imageHeight=optnumber,
-		imageWidth=optnumber,
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-	},
-	input={
-		pattern=optstring,
-		usage=optstring,
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-		multiline=optboolnumber,
-	},
-	toggle={
-		tristate=optbool,
-		image=optstringnumberfunc,
-		imageCoords=optmethodtable,
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-	},
-	tristate={
-	},
-	range={
-		min=optnumber,
-		softMin=optnumber,
-		max=optnumber,
-		softMax=optnumber,
-		step=optnumber,
-		bigStep=optnumber,
-		isPercent=optbool,
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-	},
-	select={
-		values=ismethodtable,
-		sorting=optmethodtable,
-		style={
-			["nil"]=true,
-			["string"]={dropdown=true,radio=true},
-			_="string: 'dropdown' or 'radio'"
-		},
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-		itemControl=optstring,
-	},
-	multiselect={
-		values=ismethodtable,
-		style=optstring,
-		tristate=optbool,
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-	},
-	color={
-		hasAlpha=optmethodbool,
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-	},
-	keybinding={
-		control=optstring,
-		dialogControl=optstring,
-		dropdownControl=optstring,
-	},
-}
-
-local function validateKey(k,errlvl,...)
-	errlvl=(errlvl or 0)+1
-	if type(k)~="string" then
-		err("["..tostring(k).."] - key is not a string", errlvl,...)
-	end
-	if strfind(k, "[%c\127]") then
-		err("["..tostring(k).."] - key name contained control characters", errlvl,...)
-	end
-end
-
-local function validateVal(v, oktypes, errlvl,...)
-	errlvl=(errlvl or 0)+1
-	local isok=oktypes[type(v)] or oktypes["*"]
-
-	if not isok then
-		err(": expected a "..oktypes._..", got '"..tostring(v).."'", errlvl,...)
-	end
-	if type(isok)=="table" then		-- isok was a table containing specific values to be tested for!
-		if not isok[v] then
-			err(": did not expect "..type(v).." value '"..tostring(v).."'", errlvl,...)
-		end
-	end
-end
-
-local function validate(options,errlvl,...)
-	errlvl=(errlvl or 0)+1
-	-- basic consistency
-	if type(options)~="table" then
-		err(": expected a table, got a "..type(options), errlvl,...)
-	end
-	if type(options.type)~="string" then
-		err(".type: expected a string, got a "..type(options.type), errlvl,...)
-	end
-
-	-- get type and 'typedkeys' member
-	local tk = typedkeys[options.type]
-	if not tk then
-		err(".type: unknown type '"..options.type.."'", errlvl,...)
-	end
-
-	-- make sure that all options[] are known parameters
-	for k,v in pairs(options) do
-		if not (tk[k] or basekeys[k]) then
-			err(": unknown parameter", errlvl,tostring(k),...)
-		end
-	end
-
-	-- verify that required params are there, and that everything is the right type
-	for k,oktypes in pairs(basekeys) do
-		validateVal(options[k], oktypes, errlvl,k,...)
-	end
-	for k,oktypes in pairs(tk) do
-		validateVal(options[k], oktypes, errlvl,k,...)
-	end
-
-	-- extra logic for groups
-	if options.type=="group" then
-		for k,v in pairs(options.args) do
-			validateKey(k,errlvl,"args",...)
-			validate(v, errlvl,k,"args",...)
-		end
-		if options.plugins then
-			for plugname,plugin in pairs(options.plugins) do
-				if type(plugin)~="table" then
-					err(": expected a table, got '"..tostring(plugin).."'", errlvl,tostring(plugname),"plugins",...)
-				end
-				for k,v in pairs(plugin) do
-					validateKey(k,errlvl,tostring(plugname),"plugins",...)
-					validate(v, errlvl,k,tostring(plugname),"plugins",...)
-				end
-			end
-		end
-	end
-end
-
-
---- Validates basic structure and integrity of an options table \\
--- Does NOT verify that get/set etc actually exist, since they can be defined at any depth
--- @param options The table to be validated
--- @param name The name of the table to be validated (shown in any error message)
--- @param errlvl (optional number) error level offset, default 0 (=errors point to the function calling :ValidateOptionsTable)
-function AceConfigRegistry:ValidateOptionsTable(options,name,errlvl)
-	errlvl=(errlvl or 0)+1
-	name = name or "Optionstable"
-	if not options.name then
-		options.name=name	-- bit of a hack, the root level doesn't really need a .name :-/
-	end
-	validate(options,errlvl,name)
-end
-
---- Fires a "ConfigTableChange" callback for those listening in on it, allowing config GUIs to refresh.
--- You should call this function if your options table changed from any outside event, like a game event
--- or a timer.
--- @param appName The application name as given to `:RegisterOptionsTable()`
-function AceConfigRegistry:NotifyChange(appName)
-	if not AceConfigRegistry.tables[appName] then return end
-	AceConfigRegistry.callbacks:Fire("ConfigTableChange", appName)
-end
-
--- -------------------------------------------------------------------
--- Registering and retreiving options tables:
-
-
--- validateGetterArgs: helper function for :GetOptionsTable (or, rather, the getter functions returned by it)
-
-local function validateGetterArgs(uiType, uiName, errlvl)
-	errlvl=(errlvl or 0)+2
-	if uiType~="cmd" and uiType~="dropdown" and uiType~="dialog" then
-		error(MAJOR..": Requesting options table: 'uiType' - invalid configuration UI type, expected 'cmd', 'dropdown' or 'dialog'", errlvl)
-	end
-	if not strmatch(uiName, "[A-Za-z]%-[0-9]") then	-- Expecting e.g. "MyLib-1.2"
-		error(MAJOR..": Requesting options table: 'uiName' - badly formatted or missing version number. Expected e.g. 'MyLib-1.2'", errlvl)
-	end
-end
-
---- Register an options table with the config registry.
--- @param appName The application name as given to `:RegisterOptionsTable()`
--- @param options The options table, OR a function reference that generates it on demand. \\
--- See the top of the page for info on arguments passed to such functions.
--- @param skipValidation Skip options table validation (primarily useful for extremely huge options, with a noticeable slowdown)
-function AceConfigRegistry:RegisterOptionsTable(appName, options, skipValidation)
-	if type(options)=="table" then
-		if options.type~="group" then	-- quick sanity checker
-			error(MAJOR..": RegisterOptionsTable(appName, options): 'options' - missing type='group' member in root group", 2)
-		end
-		AceConfigRegistry.tables[appName] = function(uiType, uiName, errlvl)
-			errlvl=(errlvl or 0)+1
-			validateGetterArgs(uiType, uiName, errlvl)
-			if not AceConfigRegistry.validated[uiType][appName] and not skipValidation then
-				AceConfigRegistry:ValidateOptionsTable(options, appName, errlvl)	-- upgradable
-				AceConfigRegistry.validated[uiType][appName] = true
-			end
-			return options
-		end
-	elseif type(options)=="function" then
-		AceConfigRegistry.tables[appName] = function(uiType, uiName, errlvl)
-			errlvl=(errlvl or 0)+1
-			validateGetterArgs(uiType, uiName, errlvl)
-			local tab = assert(options(uiType, uiName, appName))
-			if not AceConfigRegistry.validated[uiType][appName] and not skipValidation then
-				AceConfigRegistry:ValidateOptionsTable(tab, appName, errlvl)	-- upgradable
-				AceConfigRegistry.validated[uiType][appName] = true
-			end
-			return tab
-		end
-	else
-		error(MAJOR..": RegisterOptionsTable(appName, options): 'options' - expected table or function reference", 2)
-	end
-end
-
---- Returns an iterator of ["appName"]=funcref pairs
-function AceConfigRegistry:IterateOptionsTables()
-	return pairs(AceConfigRegistry.tables)
-end
-
-
-
-
---- Query the registry for a specific options table.
--- If only appName is given, a function is returned which you
--- can call with (uiType,uiName) to get the table.\\
--- If uiType&uiName are given, the table is returned.
--- @param appName The application name as given to `:RegisterOptionsTable()`
--- @param uiType The type of UI to get the table for, one of "cmd", "dropdown", "dialog"
--- @param uiName The name of the library/addon querying for the table, e.g. "MyLib-1.0"
-function AceConfigRegistry:GetOptionsTable(appName, uiType, uiName)
-	local f = AceConfigRegistry.tables[appName]
-	if not f then
-		return nil
-	end
-
-	if uiType then
-		return f(uiType,uiName,1)	-- get the table for us
-	else
-		return f	-- return the function
-	end
-end
+--- AceConfigRegistry-3.0 handles central registration of options tables in use by addons and modules.\\
+-- Options tables can be registered as raw tables, OR as function refs that return a table.\\
+-- Such functions receive three arguments: "uiType", "uiName", "appName". \\
+-- * Valid **uiTypes**: "cmd", "dropdown", "dialog". This is verified by the library at call time. \\
+-- * The **uiName** field is expected to contain the full name of the calling addon, including version, e.g. "FooBar-1.0". This is verified by the library at call time.\\
+-- * The **appName** field is the options table name as given at registration time \\
+--
+-- :IterateOptionsTables() (and :GetOptionsTable() if only given one argument) return a function reference that the requesting config handling addon must call with valid "uiType", "uiName".
+-- @class file
+-- @name AceConfigRegistry-3.0
+-- @release $Id: AceConfigRegistry-3.0.lua 1296 2022-11-04 18:50:10Z nevcairiel $
+local CallbackHandler = LibStub("CallbackHandler-1.0")
+
+local MAJOR, MINOR = "AceConfigRegistry-3.0", 21
+local AceConfigRegistry = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceConfigRegistry then return end
+
+AceConfigRegistry.tables = AceConfigRegistry.tables or {}
+
+if not AceConfigRegistry.callbacks then
+	AceConfigRegistry.callbacks = CallbackHandler:New(AceConfigRegistry)
+end
+
+-- Lua APIs
+local tinsert, tconcat = table.insert, table.concat
+local strfind, strmatch = string.find, string.match
+local type, tostring, select, pairs = type, tostring, select, pairs
+local error, assert = error, assert
+
+-----------------------------------------------------------------------
+-- Validating options table consistency:
+
+
+AceConfigRegistry.validated = {
+	-- list of options table names ran through :ValidateOptionsTable automatically.
+	-- CLEARED ON PURPOSE, since newer versions may have newer validators
+	cmd = {},
+	dropdown = {},
+	dialog = {},
+}
+
+
+
+local function err(msg, errlvl, ...)
+	local t = {}
+	for i=select("#",...),1,-1 do
+		tinsert(t, (select(i, ...)))
+	end
+	error(MAJOR..":ValidateOptionsTable(): "..tconcat(t,".")..msg, errlvl+2)
+end
+
+
+local isstring={["string"]=true, _="string"}
+local isstringfunc={["string"]=true,["function"]=true, _="string or funcref"}
+local istable={["table"]=true,   _="table"}
+local ismethodtable={["table"]=true,["string"]=true,["function"]=true,   _="methodname, funcref or table"}
+local optstring={["nil"]=true,["string"]=true, _="string"}
+local optstringfunc={["nil"]=true,["string"]=true,["function"]=true, _="string or funcref"}
+local optstringnumberfunc={["nil"]=true,["string"]=true,["number"]=true,["function"]=true, _="string, number or funcref"}
+local optnumber={["nil"]=true,["number"]=true, _="number"}
+local optmethodfalse={["nil"]=true,["string"]=true,["function"]=true,["boolean"]={[false]=true},  _="methodname, funcref or false"}
+local optmethodnumber={["nil"]=true,["string"]=true,["function"]=true,["number"]=true,  _="methodname, funcref or number"}
+local optmethodtable={["nil"]=true,["string"]=true,["function"]=true,["table"]=true,  _="methodname, funcref or table"}
+local optmethodbool={["nil"]=true,["string"]=true,["function"]=true,["boolean"]=true,  _="methodname, funcref or boolean"}
+local opttable={["nil"]=true,["table"]=true,  _="table"}
+local optbool={["nil"]=true,["boolean"]=true,  _="boolean"}
+local optboolnumber={["nil"]=true,["boolean"]=true,["number"]=true,  _="boolean or number"}
+local optstringnumber={["nil"]=true,["string"]=true,["number"]=true, _="string or number"}
+
+local basekeys={
+	type=isstring,
+	name=isstringfunc,
+	desc=optstringfunc,
+	descStyle=optstring,
+	order=optmethodnumber,
+	validate=optmethodfalse,
+	confirm=optmethodbool,
+	confirmText=optstring,
+	disabled=optmethodbool,
+	hidden=optmethodbool,
+		guiHidden=optmethodbool,
+		dialogHidden=optmethodbool,
+		dropdownHidden=optmethodbool,
+	cmdHidden=optmethodbool,
+	tooltipHyperlink=optstringfunc,
+	icon=optstringnumberfunc,
+	iconCoords=optmethodtable,
+	handler=opttable,
+	get=optmethodfalse,
+	set=optmethodfalse,
+	func=optmethodfalse,
+	arg={["*"]=true},
+	width=optstringnumber,
+}
+
+local typedkeys={
+	header={
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+	},
+	description={
+		image=optstringnumberfunc,
+		imageCoords=optmethodtable,
+		imageHeight=optnumber,
+		imageWidth=optnumber,
+		fontSize=optstringfunc,
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+	},
+	group={
+		args=istable,
+		plugins=opttable,
+		inline=optbool,
+			cmdInline=optbool,
+			guiInline=optbool,
+			dropdownInline=optbool,
+			dialogInline=optbool,
+		childGroups=optstring,
+	},
+	execute={
+		image=optstringnumberfunc,
+		imageCoords=optmethodtable,
+		imageHeight=optnumber,
+		imageWidth=optnumber,
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+	},
+	input={
+		pattern=optstring,
+		usage=optstring,
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+		multiline=optboolnumber,
+	},
+	toggle={
+		tristate=optbool,
+		image=optstringnumberfunc,
+		imageCoords=optmethodtable,
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+	},
+	tristate={
+	},
+	range={
+		min=optnumber,
+		softMin=optnumber,
+		max=optnumber,
+		softMax=optnumber,
+		step=optnumber,
+		bigStep=optnumber,
+		isPercent=optbool,
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+	},
+	select={
+		values=ismethodtable,
+		sorting=optmethodtable,
+		style={
+			["nil"]=true,
+			["string"]={dropdown=true,radio=true},
+			_="string: 'dropdown' or 'radio'"
+		},
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+		itemControl=optstring,
+	},
+	multiselect={
+		values=ismethodtable,
+		style=optstring,
+		tristate=optbool,
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+	},
+	color={
+		hasAlpha=optmethodbool,
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+	},
+	keybinding={
+		control=optstring,
+		dialogControl=optstring,
+		dropdownControl=optstring,
+	},
+}
+
+local function validateKey(k,errlvl,...)
+	errlvl=(errlvl or 0)+1
+	if type(k)~="string" then
+		err("["..tostring(k).."] - key is not a string", errlvl,...)
+	end
+	if strfind(k, "[%c\127]") then
+		err("["..tostring(k).."] - key name contained control characters", errlvl,...)
+	end
+end
+
+local function validateVal(v, oktypes, errlvl,...)
+	errlvl=(errlvl or 0)+1
+	local isok=oktypes[type(v)] or oktypes["*"]
+
+	if not isok then
+		err(": expected a "..oktypes._..", got '"..tostring(v).."'", errlvl,...)
+	end
+	if type(isok)=="table" then		-- isok was a table containing specific values to be tested for!
+		if not isok[v] then
+			err(": did not expect "..type(v).." value '"..tostring(v).."'", errlvl,...)
+		end
+	end
+end
+
+local function validate(options,errlvl,...)
+	errlvl=(errlvl or 0)+1
+	-- basic consistency
+	if type(options)~="table" then
+		err(": expected a table, got a "..type(options), errlvl,...)
+	end
+	if type(options.type)~="string" then
+		err(".type: expected a string, got a "..type(options.type), errlvl,...)
+	end
+
+	-- get type and 'typedkeys' member
+	local tk = typedkeys[options.type]
+	if not tk then
+		err(".type: unknown type '"..options.type.."'", errlvl,...)
+	end
+
+	-- make sure that all options[] are known parameters
+	for k,v in pairs(options) do
+		if not (tk[k] or basekeys[k]) then
+			err(": unknown parameter", errlvl,tostring(k),...)
+		end
+	end
+
+	-- verify that required params are there, and that everything is the right type
+	for k,oktypes in pairs(basekeys) do
+		validateVal(options[k], oktypes, errlvl,k,...)
+	end
+	for k,oktypes in pairs(tk) do
+		validateVal(options[k], oktypes, errlvl,k,...)
+	end
+
+	-- extra logic for groups
+	if options.type=="group" then
+		for k,v in pairs(options.args) do
+			validateKey(k,errlvl,"args",...)
+			validate(v, errlvl,k,"args",...)
+		end
+		if options.plugins then
+			for plugname,plugin in pairs(options.plugins) do
+				if type(plugin)~="table" then
+					err(": expected a table, got '"..tostring(plugin).."'", errlvl,tostring(plugname),"plugins",...)
+				end
+				for k,v in pairs(plugin) do
+					validateKey(k,errlvl,tostring(plugname),"plugins",...)
+					validate(v, errlvl,k,tostring(plugname),"plugins",...)
+				end
+			end
+		end
+	end
+end
+
+
+--- Validates basic structure and integrity of an options table \\
+-- Does NOT verify that get/set etc actually exist, since they can be defined at any depth
+-- @param options The table to be validated
+-- @param name The name of the table to be validated (shown in any error message)
+-- @param errlvl (optional number) error level offset, default 0 (=errors point to the function calling :ValidateOptionsTable)
+function AceConfigRegistry:ValidateOptionsTable(options,name,errlvl)
+	errlvl=(errlvl or 0)+1
+	name = name or "Optionstable"
+	if not options.name then
+		options.name=name	-- bit of a hack, the root level doesn't really need a .name :-/
+	end
+	validate(options,errlvl,name)
+end
+
+--- Fires a "ConfigTableChange" callback for those listening in on it, allowing config GUIs to refresh.
+-- You should call this function if your options table changed from any outside event, like a game event
+-- or a timer.
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+function AceConfigRegistry:NotifyChange(appName)
+	if not AceConfigRegistry.tables[appName] then return end
+	AceConfigRegistry.callbacks:Fire("ConfigTableChange", appName)
+end
+
+-- -------------------------------------------------------------------
+-- Registering and retreiving options tables:
+
+
+-- validateGetterArgs: helper function for :GetOptionsTable (or, rather, the getter functions returned by it)
+
+local function validateGetterArgs(uiType, uiName, errlvl)
+	errlvl=(errlvl or 0)+2
+	if uiType~="cmd" and uiType~="dropdown" and uiType~="dialog" then
+		error(MAJOR..": Requesting options table: 'uiType' - invalid configuration UI type, expected 'cmd', 'dropdown' or 'dialog'", errlvl)
+	end
+	if not strmatch(uiName, "[A-Za-z]%-[0-9]") then	-- Expecting e.g. "MyLib-1.2"
+		error(MAJOR..": Requesting options table: 'uiName' - badly formatted or missing version number. Expected e.g. 'MyLib-1.2'", errlvl)
+	end
+end
+
+--- Register an options table with the config registry.
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+-- @param options The options table, OR a function reference that generates it on demand. \\
+-- See the top of the page for info on arguments passed to such functions.
+-- @param skipValidation Skip options table validation (primarily useful for extremely huge options, with a noticeable slowdown)
+function AceConfigRegistry:RegisterOptionsTable(appName, options, skipValidation)
+	if type(options)=="table" then
+		if options.type~="group" then	-- quick sanity checker
+			error(MAJOR..": RegisterOptionsTable(appName, options): 'options' - missing type='group' member in root group", 2)
+		end
+		AceConfigRegistry.tables[appName] = function(uiType, uiName, errlvl)
+			errlvl=(errlvl or 0)+1
+			validateGetterArgs(uiType, uiName, errlvl)
+			if not AceConfigRegistry.validated[uiType][appName] and not skipValidation then
+				AceConfigRegistry:ValidateOptionsTable(options, appName, errlvl)	-- upgradable
+				AceConfigRegistry.validated[uiType][appName] = true
+			end
+			return options
+		end
+	elseif type(options)=="function" then
+		AceConfigRegistry.tables[appName] = function(uiType, uiName, errlvl)
+			errlvl=(errlvl or 0)+1
+			validateGetterArgs(uiType, uiName, errlvl)
+			local tab = assert(options(uiType, uiName, appName))
+			if not AceConfigRegistry.validated[uiType][appName] and not skipValidation then
+				AceConfigRegistry:ValidateOptionsTable(tab, appName, errlvl)	-- upgradable
+				AceConfigRegistry.validated[uiType][appName] = true
+			end
+			return tab
+		end
+	else
+		error(MAJOR..": RegisterOptionsTable(appName, options): 'options' - expected table or function reference", 2)
+	end
+end
+
+--- Returns an iterator of ["appName"]=funcref pairs
+function AceConfigRegistry:IterateOptionsTables()
+	return pairs(AceConfigRegistry.tables)
+end
+
+
+
+
+--- Query the registry for a specific options table.
+-- If only appName is given, a function is returned which you
+-- can call with (uiType,uiName) to get the table.\\
+-- If uiType&uiName are given, the table is returned.
+-- @param appName The application name as given to `:RegisterOptionsTable()`
+-- @param uiType The type of UI to get the table for, one of "cmd", "dropdown", "dialog"
+-- @param uiName The name of the library/addon querying for the table, e.g. "MyLib-1.0"
+function AceConfigRegistry:GetOptionsTable(appName, uiType, uiName)
+	local f = AceConfigRegistry.tables[appName]
+	if not f then
+		return nil
+	end
+
+	if uiType then
+		return f(uiType,uiName,1)	-- get the table for us
+	else
+		return f	-- return the function
+	end
+end
diff --git a/Carbonite/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.xml b/Carbonite/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.xml
index 5989072..4ea69ca 100644
--- a/Carbonite/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.xml
+++ b/Carbonite/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceConfigRegistry-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceConfigRegistry-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceConsole-3.0/AceConsole-3.0.lua b/Carbonite/Libs/AceConsole-3.0/AceConsole-3.0.lua
index 8ce5f8b..2361a3b 100644
--- a/Carbonite/Libs/AceConsole-3.0/AceConsole-3.0.lua
+++ b/Carbonite/Libs/AceConsole-3.0/AceConsole-3.0.lua
@@ -1,246 +1,246 @@
---- **AceConsole-3.0** provides registration facilities for slash commands.
--- You can register slash commands to your custom functions and use the `GetArgs` function to parse them
--- to your addons individual needs.
---
--- **AceConsole-3.0** can be embeded into your addon, either explicitly by calling AceConsole:Embed(MyAddon) or by
--- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
--- and can be accessed directly, without having to explicitly call AceConsole itself.\\
--- It is recommended to embed AceConsole, otherwise you'll have to specify a custom `self` on all calls you
--- make into AceConsole.
--- @class file
--- @name AceConsole-3.0
--- @release $Id: AceConsole-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
-local MAJOR,MINOR = "AceConsole-3.0", 7
-
-local AceConsole, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceConsole then return end -- No upgrade needed
-
-AceConsole.embeds = AceConsole.embeds or {} -- table containing objects AceConsole is embedded in.
-AceConsole.commands = AceConsole.commands or {} -- table containing commands registered
-AceConsole.weakcommands = AceConsole.weakcommands or {} -- table containing self, command => func references for weak commands that don't persist through enable/disable
-
--- Lua APIs
-local tconcat, tostring, select = table.concat, tostring, select
-local type, pairs, error = type, pairs, error
-local format, strfind, strsub = string.format, string.find, string.sub
-local max = math.max
-
--- WoW APIs
-local _G = _G
-
-local tmp={}
-local function Print(self,frame,...)
-	local n=0
-	if self ~= AceConsole then
-		n=n+1
-		tmp[n] = "|cff33ff99"..tostring( self ).."|r:"
-	end
-	for i=1, select("#", ...) do
-		n=n+1
-		tmp[n] = tostring(select(i, ...))
-	end
-	frame:AddMessage( tconcat(tmp," ",1,n) )
-end
-
---- Print to DEFAULT_CHAT_FRAME or given ChatFrame (anything with an .AddMessage function)
--- @paramsig [chatframe ,] ...
--- @param chatframe Custom ChatFrame to print to (or any frame with an .AddMessage function)
--- @param ... List of any values to be printed
-function AceConsole:Print(...)
-	local frame = ...
-	if type(frame) == "table" and frame.AddMessage then	-- Is first argument something with an .AddMessage member?
-		return Print(self, frame, select(2,...))
-	else
-		return Print(self, DEFAULT_CHAT_FRAME, ...)
-	end
-end
-
-
---- Formatted (using format()) print to DEFAULT_CHAT_FRAME or given ChatFrame (anything with an .AddMessage function)
--- @paramsig [chatframe ,] "format"[, ...]
--- @param chatframe Custom ChatFrame to print to (or any frame with an .AddMessage function)
--- @param format Format string - same syntax as standard Lua format()
--- @param ... Arguments to the format string
-function AceConsole:Printf(...)
-	local frame = ...
-	if type(frame) == "table" and frame.AddMessage then	-- Is first argument something with an .AddMessage member?
-		return Print(self, frame, format(select(2,...)))
-	else
-		return Print(self, DEFAULT_CHAT_FRAME, format(...))
-	end
-end
-
-
-
-
---- Register a simple chat command
--- @param command Chat command to be registered WITHOUT leading "/"
--- @param func Function to call when the slash command is being used (funcref or methodname)
--- @param persist if false, the command will be soft disabled/enabled when aceconsole is used as a mixin (default: true)
-function AceConsole:RegisterChatCommand( command, func, persist )
-	if type(command)~="string" then error([[Usage: AceConsole:RegisterChatCommand( "command", func[, persist ]): 'command' - expected a string]], 2) end
-
-	if persist==nil then persist=true end	-- I'd rather have my addon's "/addon enable" around if the author screws up. Having some extra slash regged when it shouldnt be isn't as destructive. True is a better default. /Mikk
-
-	local name = "ACECONSOLE_"..command:upper()
-
-	if type( func ) == "string" then
-		SlashCmdList[name] = function(input, editBox)
-			self[func](self, input, editBox)
-		end
-	else
-		SlashCmdList[name] = func
-	end
-	_G["SLASH_"..name.."1"] = "/"..command:lower()
-	AceConsole.commands[command] = name
-	-- non-persisting commands are registered for enabling disabling
-	if not persist then
-		if not AceConsole.weakcommands[self] then AceConsole.weakcommands[self] = {} end
-		AceConsole.weakcommands[self][command] = func
-	end
-	return true
-end
-
---- Unregister a chatcommand
--- @param command Chat command to be unregistered WITHOUT leading "/"
-function AceConsole:UnregisterChatCommand( command )
-	local name = AceConsole.commands[command]
-	if name then
-		SlashCmdList[name] = nil
-		_G["SLASH_" .. name .. "1"] = nil
-		hash_SlashCmdList["/" .. command:upper()] = nil
-		AceConsole.commands[command] = nil
-	end
-end
-
---- Get an iterator over all Chat Commands registered with AceConsole
--- @return Iterator (pairs) over all commands
-function AceConsole:IterateChatCommands() return pairs(AceConsole.commands) end
-
-
-local function nils(n, ...)
-	if n>1 then
-		return nil, nils(n-1, ...)
-	elseif n==1 then
-		return nil, ...
-	else
-		return ...
-	end
-end
-
-
---- Retreive one or more space-separated arguments from a string.
--- Treats quoted strings and itemlinks as non-spaced.
--- @param str The raw argument string
--- @param numargs How many arguments to get (default 1)
--- @param startpos Where in the string to start scanning (default  1)
--- @return Returns arg1, arg2, ..., nextposition\\
--- Missing arguments will be returned as nils. 'nextposition' is returned as 1e9 at the end of the string.
-function AceConsole:GetArgs(str, numargs, startpos)
-	numargs = numargs or 1
-	startpos = max(startpos or 1, 1)
-
-	local pos=startpos
-
-	-- find start of new arg
-	pos = strfind(str, "[^ ]", pos)
-	if not pos then	-- whoops, end of string
-		return nils(numargs, 1e9)
-	end
-
-	if numargs<1 then
-		return pos
-	end
-
-	-- quoted or space separated? find out which pattern to use
-	local delim_or_pipe
-	local ch = strsub(str, pos, pos)
-	if ch=='"' then
-		pos = pos + 1
-		delim_or_pipe='([|"])'
-	elseif ch=="'" then
-		pos = pos + 1
-		delim_or_pipe="([|'])"
-	else
-		delim_or_pipe="([| ])"
-	end
-
-	startpos = pos
-
-	while true do
-		-- find delimiter or hyperlink
-		local _
-		pos,_,ch = strfind(str, delim_or_pipe, pos)
-
-		if not pos then break end
-
-		if ch=="|" then
-			-- some kind of escape
-
-			if strsub(str,pos,pos+1)=="|H" then
-				-- It's a |H....|hhyper link!|h
-				pos=strfind(str, "|h", pos+2)	-- first |h
-				if not pos then break end
-
-				pos=strfind(str, "|h", pos+2)	-- second |h
-				if not pos then break end
-			elseif strsub(str,pos, pos+1) == "|T" then
-				-- It's a |T....|t  texture
-				pos=strfind(str, "|t", pos+2)
-				if not pos then break end
-			end
-
-			pos=pos+2 -- skip past this escape (last |h if it was a hyperlink)
-
-		else
-			-- found delimiter, done with this arg
-			return strsub(str, startpos, pos-1), AceConsole:GetArgs(str, numargs-1, pos+1)
-		end
-
-	end
-
-	-- search aborted, we hit end of string. return it all as one argument. (yes, even if it's an unterminated quote or hyperlink)
-	return strsub(str, startpos), nils(numargs-1, 1e9)
-end
-
-
---- embedding and embed handling
-
-local mixins = {
-	"Print",
-	"Printf",
-	"RegisterChatCommand",
-	"UnregisterChatCommand",
-	"GetArgs",
-}
-
--- Embeds AceConsole into the target object making the functions from the mixins list available on target:..
--- @param target target object to embed AceBucket in
-function AceConsole:Embed( target )
-	for k, v in pairs( mixins ) do
-		target[v] = self[v]
-	end
-	self.embeds[target] = true
-	return target
-end
-
-function AceConsole:OnEmbedEnable( target )
-	if AceConsole.weakcommands[target] then
-		for command, func in pairs( AceConsole.weakcommands[target] ) do
-			target:RegisterChatCommand( command, func, false, true ) -- nonpersisting and silent registry
-		end
-	end
-end
-
-function AceConsole:OnEmbedDisable( target )
-	if AceConsole.weakcommands[target] then
-		for command, func in pairs( AceConsole.weakcommands[target] ) do
-			target:UnregisterChatCommand( command ) -- TODO: this could potentially unregister a command from another application in case of command conflicts. Do we care?
-		end
-	end
-end
-
-for addon in pairs(AceConsole.embeds) do
-	AceConsole:Embed(addon)
-end
+--- **AceConsole-3.0** provides registration facilities for slash commands.
+-- You can register slash commands to your custom functions and use the `GetArgs` function to parse them
+-- to your addons individual needs.
+--
+-- **AceConsole-3.0** can be embeded into your addon, either explicitly by calling AceConsole:Embed(MyAddon) or by
+-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
+-- and can be accessed directly, without having to explicitly call AceConsole itself.\\
+-- It is recommended to embed AceConsole, otherwise you'll have to specify a custom `self` on all calls you
+-- make into AceConsole.
+-- @class file
+-- @name AceConsole-3.0
+-- @release $Id: AceConsole-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
+local MAJOR,MINOR = "AceConsole-3.0", 7
+
+local AceConsole, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceConsole then return end -- No upgrade needed
+
+AceConsole.embeds = AceConsole.embeds or {} -- table containing objects AceConsole is embedded in.
+AceConsole.commands = AceConsole.commands or {} -- table containing commands registered
+AceConsole.weakcommands = AceConsole.weakcommands or {} -- table containing self, command => func references for weak commands that don't persist through enable/disable
+
+-- Lua APIs
+local tconcat, tostring, select = table.concat, tostring, select
+local type, pairs, error = type, pairs, error
+local format, strfind, strsub = string.format, string.find, string.sub
+local max = math.max
+
+-- WoW APIs
+local _G = _G
+
+local tmp={}
+local function Print(self,frame,...)
+	local n=0
+	if self ~= AceConsole then
+		n=n+1
+		tmp[n] = "|cff33ff99"..tostring( self ).."|r:"
+	end
+	for i=1, select("#", ...) do
+		n=n+1
+		tmp[n] = tostring(select(i, ...))
+	end
+	frame:AddMessage( tconcat(tmp," ",1,n) )
+end
+
+--- Print to DEFAULT_CHAT_FRAME or given ChatFrame (anything with an .AddMessage function)
+-- @paramsig [chatframe ,] ...
+-- @param chatframe Custom ChatFrame to print to (or any frame with an .AddMessage function)
+-- @param ... List of any values to be printed
+function AceConsole:Print(...)
+	local frame = ...
+	if type(frame) == "table" and frame.AddMessage then	-- Is first argument something with an .AddMessage member?
+		return Print(self, frame, select(2,...))
+	else
+		return Print(self, DEFAULT_CHAT_FRAME, ...)
+	end
+end
+
+
+--- Formatted (using format()) print to DEFAULT_CHAT_FRAME or given ChatFrame (anything with an .AddMessage function)
+-- @paramsig [chatframe ,] "format"[, ...]
+-- @param chatframe Custom ChatFrame to print to (or any frame with an .AddMessage function)
+-- @param format Format string - same syntax as standard Lua format()
+-- @param ... Arguments to the format string
+function AceConsole:Printf(...)
+	local frame = ...
+	if type(frame) == "table" and frame.AddMessage then	-- Is first argument something with an .AddMessage member?
+		return Print(self, frame, format(select(2,...)))
+	else
+		return Print(self, DEFAULT_CHAT_FRAME, format(...))
+	end
+end
+
+
+
+
+--- Register a simple chat command
+-- @param command Chat command to be registered WITHOUT leading "/"
+-- @param func Function to call when the slash command is being used (funcref or methodname)
+-- @param persist if false, the command will be soft disabled/enabled when aceconsole is used as a mixin (default: true)
+function AceConsole:RegisterChatCommand( command, func, persist )
+	if type(command)~="string" then error([[Usage: AceConsole:RegisterChatCommand( "command", func[, persist ]): 'command' - expected a string]], 2) end
+
+	if persist==nil then persist=true end	-- I'd rather have my addon's "/addon enable" around if the author screws up. Having some extra slash regged when it shouldnt be isn't as destructive. True is a better default. /Mikk
+
+	local name = "ACECONSOLE_"..command:upper()
+
+	if type( func ) == "string" then
+		SlashCmdList[name] = function(input, editBox)
+			self[func](self, input, editBox)
+		end
+	else
+		SlashCmdList[name] = func
+	end
+	_G["SLASH_"..name.."1"] = "/"..command:lower()
+	AceConsole.commands[command] = name
+	-- non-persisting commands are registered for enabling disabling
+	if not persist then
+		if not AceConsole.weakcommands[self] then AceConsole.weakcommands[self] = {} end
+		AceConsole.weakcommands[self][command] = func
+	end
+	return true
+end
+
+--- Unregister a chatcommand
+-- @param command Chat command to be unregistered WITHOUT leading "/"
+function AceConsole:UnregisterChatCommand( command )
+	local name = AceConsole.commands[command]
+	if name then
+		SlashCmdList[name] = nil
+		_G["SLASH_" .. name .. "1"] = nil
+		hash_SlashCmdList["/" .. command:upper()] = nil
+		AceConsole.commands[command] = nil
+	end
+end
+
+--- Get an iterator over all Chat Commands registered with AceConsole
+-- @return Iterator (pairs) over all commands
+function AceConsole:IterateChatCommands() return pairs(AceConsole.commands) end
+
+
+local function nils(n, ...)
+	if n>1 then
+		return nil, nils(n-1, ...)
+	elseif n==1 then
+		return nil, ...
+	else
+		return ...
+	end
+end
+
+
+--- Retreive one or more space-separated arguments from a string.
+-- Treats quoted strings and itemlinks as non-spaced.
+-- @param str The raw argument string
+-- @param numargs How many arguments to get (default 1)
+-- @param startpos Where in the string to start scanning (default  1)
+-- @return Returns arg1, arg2, ..., nextposition\\
+-- Missing arguments will be returned as nils. 'nextposition' is returned as 1e9 at the end of the string.
+function AceConsole:GetArgs(str, numargs, startpos)
+	numargs = numargs or 1
+	startpos = max(startpos or 1, 1)
+
+	local pos=startpos
+
+	-- find start of new arg
+	pos = strfind(str, "[^ ]", pos)
+	if not pos then	-- whoops, end of string
+		return nils(numargs, 1e9)
+	end
+
+	if numargs<1 then
+		return pos
+	end
+
+	-- quoted or space separated? find out which pattern to use
+	local delim_or_pipe
+	local ch = strsub(str, pos, pos)
+	if ch=='"' then
+		pos = pos + 1
+		delim_or_pipe='([|"])'
+	elseif ch=="'" then
+		pos = pos + 1
+		delim_or_pipe="([|'])"
+	else
+		delim_or_pipe="([| ])"
+	end
+
+	startpos = pos
+
+	while true do
+		-- find delimiter or hyperlink
+		local _
+		pos,_,ch = strfind(str, delim_or_pipe, pos)
+
+		if not pos then break end
+
+		if ch=="|" then
+			-- some kind of escape
+
+			if strsub(str,pos,pos+1)=="|H" then
+				-- It's a |H....|hhyper link!|h
+				pos=strfind(str, "|h", pos+2)	-- first |h
+				if not pos then break end
+
+				pos=strfind(str, "|h", pos+2)	-- second |h
+				if not pos then break end
+			elseif strsub(str,pos, pos+1) == "|T" then
+				-- It's a |T....|t  texture
+				pos=strfind(str, "|t", pos+2)
+				if not pos then break end
+			end
+
+			pos=pos+2 -- skip past this escape (last |h if it was a hyperlink)
+
+		else
+			-- found delimiter, done with this arg
+			return strsub(str, startpos, pos-1), AceConsole:GetArgs(str, numargs-1, pos+1)
+		end
+
+	end
+
+	-- search aborted, we hit end of string. return it all as one argument. (yes, even if it's an unterminated quote or hyperlink)
+	return strsub(str, startpos), nils(numargs-1, 1e9)
+end
+
+
+--- embedding and embed handling
+
+local mixins = {
+	"Print",
+	"Printf",
+	"RegisterChatCommand",
+	"UnregisterChatCommand",
+	"GetArgs",
+}
+
+-- Embeds AceConsole into the target object making the functions from the mixins list available on target:..
+-- @param target target object to embed AceBucket in
+function AceConsole:Embed( target )
+	for k, v in pairs( mixins ) do
+		target[v] = self[v]
+	end
+	self.embeds[target] = true
+	return target
+end
+
+function AceConsole:OnEmbedEnable( target )
+	if AceConsole.weakcommands[target] then
+		for command, func in pairs( AceConsole.weakcommands[target] ) do
+			target:RegisterChatCommand( command, func, false, true ) -- nonpersisting and silent registry
+		end
+	end
+end
+
+function AceConsole:OnEmbedDisable( target )
+	if AceConsole.weakcommands[target] then
+		for command, func in pairs( AceConsole.weakcommands[target] ) do
+			target:UnregisterChatCommand( command ) -- TODO: this could potentially unregister a command from another application in case of command conflicts. Do we care?
+		end
+	end
+end
+
+for addon in pairs(AceConsole.embeds) do
+	AceConsole:Embed(addon)
+end
diff --git a/Carbonite/Libs/AceConsole-3.0/AceConsole-3.0.xml b/Carbonite/Libs/AceConsole-3.0/AceConsole-3.0.xml
index f6ae8a6..4f4699a 100644
--- a/Carbonite/Libs/AceConsole-3.0/AceConsole-3.0.xml
+++ b/Carbonite/Libs/AceConsole-3.0/AceConsole-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceConsole-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceConsole-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceDB-3.0/AceDB-3.0.lua b/Carbonite/Libs/AceDB-3.0/AceDB-3.0.lua
index 90b81be..1e25429 100644
--- a/Carbonite/Libs/AceDB-3.0/AceDB-3.0.lua
+++ b/Carbonite/Libs/AceDB-3.0/AceDB-3.0.lua
@@ -1,740 +1,740 @@
---- **AceDB-3.0** manages the SavedVariables of your addon.
--- It offers profile management, smart defaults and namespaces for modules.\\
--- Data can be saved in different data-types, depending on its intended usage.
--- The most common data-type is the `profile` type, which allows the user to choose
--- the active profile, and manage the profiles of all of his characters.\\
--- The following data types are available:
--- * **char** Character-specific data. Every character has its own database.
--- * **realm** Realm-specific data. All of the players characters on the same realm share this database.
--- * **class** Class-specific data. All of the players characters of the same class share this database.
--- * **race** Race-specific data. All of the players characters of the same race share this database.
--- * **faction** Faction-specific data. All of the players characters of the same faction share this database.
--- * **factionrealm** Faction and realm specific data. All of the players characters on the same realm and of the same faction share this database.
--- * **locale** Locale specific data, based on the locale of the players game client.
--- * **global** Global Data. All characters on the same account share this database.
--- * **profile** Profile-specific data. All characters using the same profile share this database. The user can control which profile should be used.
---
--- Creating a new Database using the `:New` function will return a new DBObject. A database will inherit all functions
--- of the DBObjectLib listed here. \\
--- If you create a new namespaced child-database (`:RegisterNamespace`), you'll get a DBObject as well, but note
--- that the child-databases cannot individually change their profile, and are linked to their parents profile - and because of that,
--- the profile related APIs are not available. Only `:RegisterDefaults` and `:ResetProfile` are available on child-databases.
---
--- For more details on how to use AceDB-3.0, see the [[AceDB-3.0 Tutorial]].
---
--- You may also be interested in [[libdualspec-1-0|LibDualSpec-1.0]] to do profile switching automatically when switching specs.
---
--- @usage
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("DBExample")
---
--- -- declare defaults to be used in the DB
--- local defaults = {
---   profile = {
---     setting = true,
---   }
--- }
---
--- function MyAddon:OnInitialize()
---   -- Assuming the .toc says ## SavedVariables: MyAddonDB
---   self.db = LibStub("AceDB-3.0"):New("MyAddonDB", defaults, true)
--- end
--- @class file
--- @name AceDB-3.0.lua
--- @release $Id: AceDB-3.0.lua 1328 2024-03-20 22:36:27Z nevcairiel $
-local ACEDB_MAJOR, ACEDB_MINOR = "AceDB-3.0", 29
-local AceDB = LibStub:NewLibrary(ACEDB_MAJOR, ACEDB_MINOR)
-
-if not AceDB then return end -- No upgrade needed
-
--- Lua APIs
-local type, pairs, next, error = type, pairs, next, error
-local setmetatable, rawset, rawget = setmetatable, rawset, rawget
-
--- WoW APIs
-local _G = _G
-
-AceDB.db_registry = AceDB.db_registry or {}
-AceDB.frame = AceDB.frame or CreateFrame("Frame")
-
-local CallbackHandler
-local CallbackDummy = { Fire = function() end }
-
-local DBObjectLib = {}
-
---[[-------------------------------------------------------------------------
-	AceDB Utility Functions
----------------------------------------------------------------------------]]
-
--- Simple shallow copy for copying defaults
-local function copyTable(src, dest)
-	if type(dest) ~= "table" then dest = {} end
-	if type(src) == "table" then
-		for k,v in pairs(src) do
-			if type(v) == "table" then
-				-- try to index the key first so that the metatable creates the defaults, if set, and use that table
-				v = copyTable(v, dest[k])
-			end
-			dest[k] = v
-		end
-	end
-	return dest
-end
-
--- Called to add defaults to a section of the database
---
--- When a ["*"] default section is indexed with a new key, a table is returned
--- and set in the host table.  These tables must be cleaned up by removeDefaults
--- in order to ensure we don't write empty default tables.
-local function copyDefaults(dest, src)
-	-- this happens if some value in the SV overwrites our default value with a non-table
-	--if type(dest) ~= "table" then return end
-	for k, v in pairs(src) do
-		if k == "*" or k == "**" then
-			if type(v) == "table" then
-				-- This is a metatable used for table defaults
-				local mt = {
-					-- This handles the lookup and creation of new subtables
-					__index = function(t,k2)
-							if k2 == nil then return nil end
-							local tbl = {}
-							copyDefaults(tbl, v)
-							rawset(t, k2, tbl)
-							return tbl
-						end,
-				}
-				setmetatable(dest, mt)
-				-- handle already existing tables in the SV
-				for dk, dv in pairs(dest) do
-					if not rawget(src, dk) and type(dv) == "table" then
-						copyDefaults(dv, v)
-					end
-				end
-			else
-				-- Values are not tables, so this is just a simple return
-				local mt = {__index = function(t,k2) return k2~=nil and v or nil end}
-				setmetatable(dest, mt)
-			end
-		elseif type(v) == "table" then
-			if not rawget(dest, k) then rawset(dest, k, {}) end
-			if type(dest[k]) == "table" then
-				copyDefaults(dest[k], v)
-				if src['**'] then
-					copyDefaults(dest[k], src['**'])
-				end
-			end
-		else
-			if rawget(dest, k) == nil then
-				rawset(dest, k, v)
-			end
-		end
-	end
-end
-
--- Called to remove all defaults in the default table from the database
-local function removeDefaults(db, defaults, blocker)
-	-- remove all metatables from the db, so we don't accidentally create new sub-tables through them
-	setmetatable(db, nil)
-	-- loop through the defaults and remove their content
-	for k,v in pairs(defaults) do
-		if k == "*" or k == "**" then
-			if type(v) == "table" then
-				-- Loop through all the actual k,v pairs and remove
-				for key, value in pairs(db) do
-					if type(value) == "table" then
-						-- if the key was not explicitly specified in the defaults table, just strip everything from * and ** tables
-						if defaults[key] == nil and (not blocker or blocker[key] == nil) then
-							removeDefaults(value, v)
-							-- if the table is empty afterwards, remove it
-							if next(value) == nil then
-								db[key] = nil
-							end
-						-- if it was specified, only strip ** content, but block values which were set in the key table
-						elseif k == "**" then
-							removeDefaults(value, v, defaults[key])
-						end
-					end
-				end
-			elseif k == "*" then
-				-- check for non-table default
-				for key, value in pairs(db) do
-					if defaults[key] == nil and v == value then
-						db[key] = nil
-					end
-				end
-			end
-		elseif type(v) == "table" and type(db[k]) == "table" then
-			-- if a blocker was set, dive into it, to allow multi-level defaults
-			removeDefaults(db[k], v, blocker and blocker[k])
-			if next(db[k]) == nil then
-				db[k] = nil
-			end
-		else
-			-- check if the current value matches the default, and that its not blocked by another defaults table
-			if db[k] == defaults[k] and (not blocker or blocker[k] == nil) then
-				db[k] = nil
-			end
-		end
-	end
-end
-
--- This is called when a table section is first accessed, to set up the defaults
-local function initSection(db, section, svstore, key, defaults)
-	local sv = rawget(db, "sv")
-
-	local tableCreated
-	if not sv[svstore] then sv[svstore] = {} end
-	if not sv[svstore][key] then
-		sv[svstore][key] = {}
-		tableCreated = true
-	end
-
-	local tbl = sv[svstore][key]
-
-	if defaults then
-		copyDefaults(tbl, defaults)
-	end
-	rawset(db, section, tbl)
-
-	return tableCreated, tbl
-end
-
--- Metatable to handle the dynamic creation of sections and copying of sections.
-local dbmt = {
-	__index = function(t, section)
-			local keys = rawget(t, "keys")
-			local key = keys[section]
-			if key then
-				local defaultTbl = rawget(t, "defaults")
-				local defaults = defaultTbl and defaultTbl[section]
-
-				if section == "profile" then
-					local new = initSection(t, section, "profiles", key, defaults)
-					if new then
-						-- Callback: OnNewProfile, database, newProfileKey
-						t.callbacks:Fire("OnNewProfile", t, key)
-					end
-				elseif section == "profiles" then
-					local sv = rawget(t, "sv")
-					if not sv.profiles then sv.profiles = {} end
-					rawset(t, "profiles", sv.profiles)
-				elseif section == "global" then
-					local sv = rawget(t, "sv")
-					if not sv.global then sv.global = {} end
-					if defaults then
-						copyDefaults(sv.global, defaults)
-					end
-					rawset(t, section, sv.global)
-				else
-					initSection(t, section, section, key, defaults)
-				end
-			end
-
-			return rawget(t, section)
-		end
-}
-
-local function validateDefaults(defaults, keyTbl, offset)
-	if not defaults then return end
-	offset = offset or 0
-	for k in pairs(defaults) do
-		if not keyTbl[k] or k == "profiles" then
-			error(("Usage: AceDBObject:RegisterDefaults(defaults): '%s' is not a valid datatype."):format(k), 3 + offset)
-		end
-	end
-end
-
-local preserve_keys = {
-	["callbacks"] = true,
-	["RegisterCallback"] = true,
-	["UnregisterCallback"] = true,
-	["UnregisterAllCallbacks"] = true,
-	["children"] = true,
-}
-
-local realmKey = GetRealmName()
-local charKey = UnitName("player") .. " - " .. realmKey
-local _, classKey = UnitClass("player")
-local _, raceKey = UnitRace("player")
-local factionKey = UnitFactionGroup("player")
-local factionrealmKey = factionKey .. " - " .. realmKey
-local localeKey = GetLocale():lower()
-
-local regionTable = { "US", "KR", "EU", "TW", "CN" }
-local regionKey = regionTable[GetCurrentRegion()] or GetCurrentRegionName() or "TR"
-local factionrealmregionKey = factionrealmKey .. " - " .. regionKey
-
--- Actual database initialization function
-local function initdb(sv, defaults, defaultProfile, olddb, parent)
-	-- Generate the database keys for each section
-
-	-- map "true" to our "Default" profile
-	if defaultProfile == true then defaultProfile = "Default" end
-
-	local profileKey
-	if not parent then
-		-- Make a container for profile keys
-		if not sv.profileKeys then sv.profileKeys = {} end
-
-		-- Try to get the profile selected from the char db
-		profileKey = sv.profileKeys[charKey] or defaultProfile or charKey
-
-		-- save the selected profile for later
-		sv.profileKeys[charKey] = profileKey
-	else
-		-- Use the profile of the parents DB
-		profileKey = parent.keys.profile or defaultProfile or charKey
-
-		-- clear the profileKeys in the DB, namespaces don't need to store them
-		sv.profileKeys = nil
-	end
-
-	-- This table contains keys that enable the dynamic creation
-	-- of each section of the table.  The 'global' and 'profiles'
-	-- have a key of true, since they are handled in a special case
-	local keyTbl= {
-		["char"] = charKey,
-		["realm"] = realmKey,
-		["class"] = classKey,
-		["race"] = raceKey,
-		["faction"] = factionKey,
-		["factionrealm"] = factionrealmKey,
-		["factionrealmregion"] = factionrealmregionKey,
-		["profile"] = profileKey,
-		["locale"] = localeKey,
-		["global"] = true,
-		["profiles"] = true,
-	}
-
-	validateDefaults(defaults, keyTbl, 1)
-
-	-- This allows us to use this function to reset an entire database
-	-- Clear out the old database
-	if olddb then
-		for k,v in pairs(olddb) do if not preserve_keys[k] then olddb[k] = nil end end
-	end
-
-	-- Give this database the metatable so it initializes dynamically
-	local db = setmetatable(olddb or {}, dbmt)
-
-	if not rawget(db, "callbacks") then
-		-- try to load CallbackHandler-1.0 if it loaded after our library
-		if not CallbackHandler then CallbackHandler = LibStub:GetLibrary("CallbackHandler-1.0", true) end
-		db.callbacks = CallbackHandler and CallbackHandler:New(db) or CallbackDummy
-	end
-
-	-- Copy methods locally into the database object, to avoid hitting
-	-- the metatable when calling methods
-
-	if not parent then
-		for name, func in pairs(DBObjectLib) do
-			db[name] = func
-		end
-	else
-		-- hack this one in
-		db.RegisterDefaults = DBObjectLib.RegisterDefaults
-		db.ResetProfile = DBObjectLib.ResetProfile
-	end
-
-	-- Set some properties in the database object
-	db.profiles = sv.profiles
-	db.keys = keyTbl
-	db.sv = sv
-	--db.sv_name = name
-	db.defaults = defaults
-	db.parent = parent
-
-	-- store the DB in the registry
-	AceDB.db_registry[db] = true
-
-	return db
-end
-
--- handle PLAYER_LOGOUT
--- strip all defaults from all databases
--- and cleans up empty sections
-local function logoutHandler(frame, event)
-	if event == "PLAYER_LOGOUT" then
-		for db in pairs(AceDB.db_registry) do
-			db.callbacks:Fire("OnDatabaseShutdown", db)
-			db:RegisterDefaults(nil)
-
-			-- cleanup sections that are empty without defaults
-			local sv = rawget(db, "sv")
-			for section in pairs(db.keys) do
-				if rawget(sv, section) then
-					-- global is special, all other sections have sub-entrys
-					-- also don't delete empty profiles on main dbs, only on namespaces
-					if section ~= "global" and (section ~= "profiles" or rawget(db, "parent")) then
-						for key in pairs(sv[section]) do
-							if not next(sv[section][key]) then
-								sv[section][key] = nil
-							end
-						end
-					end
-					if not next(sv[section]) then
-						sv[section] = nil
-					end
-				end
-			end
-		end
-	end
-end
-
-AceDB.frame:RegisterEvent("PLAYER_LOGOUT")
-AceDB.frame:SetScript("OnEvent", logoutHandler)
-
-
---[[-------------------------------------------------------------------------
-	AceDB Object Method Definitions
----------------------------------------------------------------------------]]
-
---- Sets the defaults table for the given database object by clearing any
--- that are currently set, and then setting the new defaults.
--- @param defaults A table of defaults for this database
-function DBObjectLib:RegisterDefaults(defaults)
-	if defaults and type(defaults) ~= "table" then
-		error(("Usage: AceDBObject:RegisterDefaults(defaults): 'defaults' - table or nil expected, got %q."):format(type(defaults)), 2)
-	end
-
-	validateDefaults(defaults, self.keys)
-
-	-- Remove any currently set defaults
-	if self.defaults then
-		for section,key in pairs(self.keys) do
-			if self.defaults[section] and rawget(self, section) then
-				removeDefaults(self[section], self.defaults[section])
-			end
-		end
-	end
-
-	-- Set the DBObject.defaults table
-	self.defaults = defaults
-
-	-- Copy in any defaults, only touching those sections already created
-	if defaults then
-		for section,key in pairs(self.keys) do
-			if defaults[section] and rawget(self, section) then
-				copyDefaults(self[section], defaults[section])
-			end
-		end
-	end
-end
-
---- Changes the profile of the database and all of it's namespaces to the
--- supplied named profile
--- @param name The name of the profile to set as the current profile
-function DBObjectLib:SetProfile(name)
-	if type(name) ~= "string" then
-		error(("Usage: AceDBObject:SetProfile(name): 'name' - string expected, got %q."):format(type(name)), 2)
-	end
-
-	-- changing to the same profile, dont do anything
-	if name == self.keys.profile then return end
-
-	local oldProfile = self.profile
-	local defaults = self.defaults and self.defaults.profile
-
-	-- Callback: OnProfileShutdown, database
-	self.callbacks:Fire("OnProfileShutdown", self)
-
-	if oldProfile and defaults then
-		-- Remove the defaults from the old profile
-		removeDefaults(oldProfile, defaults)
-	end
-
-	self.profile = nil
-	self.keys["profile"] = name
-
-	-- if the storage exists, save the new profile
-	-- this won't exist on namespaces.
-	if self.sv.profileKeys then
-		self.sv.profileKeys[charKey] = name
-	end
-
-	-- populate to child namespaces
-	if self.children then
-		for _, db in pairs(self.children) do
-			DBObjectLib.SetProfile(db, name)
-		end
-	end
-
-	-- Callback: OnProfileChanged, database, newProfileKey
-	self.callbacks:Fire("OnProfileChanged", self, name)
-end
-
---- Returns a table with the names of the existing profiles in the database.
--- You can optionally supply a table to re-use for this purpose.
--- @param tbl A table to store the profile names in (optional)
-function DBObjectLib:GetProfiles(tbl)
-	if tbl and type(tbl) ~= "table" then
-		error(("Usage: AceDBObject:GetProfiles(tbl): 'tbl' - table or nil expected, got %q."):format(type(tbl)), 2)
-	end
-
-	-- Clear the container table
-	if tbl then
-		for k,v in pairs(tbl) do tbl[k] = nil end
-	else
-		tbl = {}
-	end
-
-	local curProfile = self.keys.profile
-
-	local i = 0
-	for profileKey in pairs(self.profiles) do
-		i = i + 1
-		tbl[i] = profileKey
-		if curProfile and profileKey == curProfile then curProfile = nil end
-	end
-
-	-- Add the current profile, if it hasn't been created yet
-	if curProfile then
-		i = i + 1
-		tbl[i] = curProfile
-	end
-
-	return tbl, i
-end
-
---- Returns the current profile name used by the database
-function DBObjectLib:GetCurrentProfile()
-	return self.keys.profile
-end
-
---- Deletes a named profile.  This profile must not be the active profile.
--- @param name The name of the profile to be deleted
--- @param silent If true, do not raise an error when the profile does not exist
-function DBObjectLib:DeleteProfile(name, silent)
-	if type(name) ~= "string" then
-		error(("Usage: AceDBObject:DeleteProfile(name): 'name' - string expected, got %q."):format(type(name)), 2)
-	end
-
-	if self.keys.profile == name then
-		error(("Cannot delete the active profile (%q) in an AceDBObject."):format(name), 2)
-	end
-
-	if not rawget(self.profiles, name) and not silent then
-		error(("Cannot delete profile %q as it does not exist."):format(name), 2)
-	end
-
-	self.profiles[name] = nil
-
-	-- populate to child namespaces
-	if self.children then
-		for _, db in pairs(self.children) do
-			DBObjectLib.DeleteProfile(db, name, true)
-		end
-	end
-
-	-- switch all characters that use this profile back to the default
-	if self.sv.profileKeys then
-		for key, profile in pairs(self.sv.profileKeys) do
-			if profile == name then
-				self.sv.profileKeys[key] = nil
-			end
-		end
-	end
-
-	-- Callback: OnProfileDeleted, database, profileKey
-	self.callbacks:Fire("OnProfileDeleted", self, name)
-end
-
---- Copies a named profile into the current profile, overwriting any conflicting
--- settings.
--- @param name The name of the profile to be copied into the current profile
--- @param silent If true, do not raise an error when the profile does not exist
-function DBObjectLib:CopyProfile(name, silent)
-	if type(name) ~= "string" then
-		error(("Usage: AceDBObject:CopyProfile(name): 'name' - string expected, got %q."):format(type(name)), 2)
-	end
-
-	if name == self.keys.profile then
-		error(("Cannot have the same source and destination profiles (%q)."):format(name), 2)
-	end
-
-	if not rawget(self.profiles, name) and not silent then
-		error(("Cannot copy profile %q as it does not exist."):format(name), 2)
-	end
-
-	-- Reset the profile before copying
-	DBObjectLib.ResetProfile(self, nil, true)
-
-	local profile = self.profile
-	local source = self.profiles[name]
-
-	copyTable(source, profile)
-
-	-- populate to child namespaces
-	if self.children then
-		for _, db in pairs(self.children) do
-			DBObjectLib.CopyProfile(db, name, true)
-		end
-	end
-
-	-- Callback: OnProfileCopied, database, sourceProfileKey
-	self.callbacks:Fire("OnProfileCopied", self, name)
-end
-
---- Resets the current profile to the default values (if specified).
--- @param noChildren if set to true, the reset will not be populated to the child namespaces of this DB object
--- @param noCallbacks if set to true, won't fire the OnProfileReset callback
-function DBObjectLib:ResetProfile(noChildren, noCallbacks)
-	local profile = self.profile
-
-	for k,v in pairs(profile) do
-		profile[k] = nil
-	end
-
-	local defaults = self.defaults and self.defaults.profile
-	if defaults then
-		copyDefaults(profile, defaults)
-	end
-
-	-- populate to child namespaces
-	if self.children and not noChildren then
-		for _, db in pairs(self.children) do
-			DBObjectLib.ResetProfile(db, nil, noCallbacks)
-		end
-	end
-
-	-- Callback: OnProfileReset, database
-	if not noCallbacks then
-		self.callbacks:Fire("OnProfileReset", self)
-	end
-end
-
---- Resets the entire database, using the string defaultProfile as the new default
--- profile.
--- @param defaultProfile The profile name to use as the default
-function DBObjectLib:ResetDB(defaultProfile)
-	if defaultProfile and type(defaultProfile) ~= "string" and defaultProfile ~= true then
-		error(("Usage: AceDBObject:ResetDB(defaultProfile): 'defaultProfile' - string or true expected, got %q."):format(type(defaultProfile)), 2)
-	end
-
-	local sv = self.sv
-	for k,v in pairs(sv) do
-		sv[k] = nil
-	end
-
-	initdb(sv, self.defaults, defaultProfile, self)
-
-	-- fix the child namespaces
-	if self.children then
-		if not sv.namespaces then sv.namespaces = {} end
-		for name, db in pairs(self.children) do
-			if not sv.namespaces[name] then sv.namespaces[name] = {} end
-			initdb(sv.namespaces[name], db.defaults, self.keys.profile, db, self)
-		end
-	end
-
-	-- Callback: OnDatabaseReset, database
-	self.callbacks:Fire("OnDatabaseReset", self)
-	-- Callback: OnProfileChanged, database, profileKey
-	self.callbacks:Fire("OnProfileChanged", self, self.keys["profile"])
-
-	return self
-end
-
---- Creates a new database namespace, directly tied to the database.  This
--- is a full scale database in it's own rights other than the fact that
--- it cannot control its profile individually
--- @param name The name of the new namespace
--- @param defaults A table of values to use as defaults
-function DBObjectLib:RegisterNamespace(name, defaults)
-	if type(name) ~= "string" then
-		error(("Usage: AceDBObject:RegisterNamespace(name, defaults): 'name' - string expected, got %q."):format(type(name)), 2)
-	end
-	if defaults and type(defaults) ~= "table" then
-		error(("Usage: AceDBObject:RegisterNamespace(name, defaults): 'defaults' - table or nil expected, got %q."):format(type(defaults)), 2)
-	end
-	if self.children and self.children[name] then
-		error(("Usage: AceDBObject:RegisterNamespace(name, defaults): 'name' - a namespace called %q already exists."):format(name), 2)
-	end
-
-	local sv = self.sv
-	if not sv.namespaces then sv.namespaces = {} end
-	if not sv.namespaces[name] then
-		sv.namespaces[name] = {}
-	end
-
-	local newDB = initdb(sv.namespaces[name], defaults, self.keys.profile, nil, self)
-
-	if not self.children then self.children = {} end
-	self.children[name] = newDB
-	return newDB
-end
-
---- Returns an already existing namespace from the database object.
--- @param name The name of the new namespace
--- @param silent if true, the addon is optional, silently return nil if its not found
--- @usage
--- local namespace = self.db:GetNamespace('namespace')
--- @return the namespace object if found
-function DBObjectLib:GetNamespace(name, silent)
-	if type(name) ~= "string" then
-		error(("Usage: AceDBObject:GetNamespace(name): 'name' - string expected, got %q."):format(type(name)), 2)
-	end
-	if not silent and not (self.children and self.children[name]) then
-		error(("Usage: AceDBObject:GetNamespace(name): 'name' - namespace %q does not exist."):format(name), 2)
-	end
-	if not self.children then self.children = {} end
-	return self.children[name]
-end
-
---[[-------------------------------------------------------------------------
-	AceDB Exposed Methods
----------------------------------------------------------------------------]]
-
---- Creates a new database object that can be used to handle database settings and profiles.
--- By default, an empty DB is created, using a character specific profile.
---
--- You can override the default profile used by passing any profile name as the third argument,
--- or by passing //true// as the third argument to use a globally shared profile called "Default".
---
--- Note that there is no token replacement in the default profile name, passing a defaultProfile as "char"
--- will use a profile named "char", and not a character-specific profile.
--- @param tbl The name of variable, or table to use for the database
--- @param defaults A table of database defaults
--- @param defaultProfile The name of the default profile. If not set, a character specific profile will be used as the default.
--- You can also pass //true// to use a shared global profile called "Default".
--- @usage
--- -- Create an empty DB using a character-specific default profile.
--- self.db = LibStub("AceDB-3.0"):New("MyAddonDB")
--- @usage
--- -- Create a DB using defaults and using a shared default profile
--- self.db = LibStub("AceDB-3.0"):New("MyAddonDB", defaults, true)
-function AceDB:New(tbl, defaults, defaultProfile)
-	if type(tbl) == "string" then
-		local name = tbl
-		tbl = _G[name]
-		if not tbl then
-			tbl = {}
-			_G[name] = tbl
-		end
-	end
-
-	if type(tbl) ~= "table" then
-		error(("Usage: AceDB:New(tbl, defaults, defaultProfile): 'tbl' - table expected, got %q."):format(type(tbl)), 2)
-	end
-
-	if defaults and type(defaults) ~= "table" then
-		error(("Usage: AceDB:New(tbl, defaults, defaultProfile): 'defaults' - table expected, got %q."):format(type(defaults)), 2)
-	end
-
-	if defaultProfile and type(defaultProfile) ~= "string" and defaultProfile ~= true then
-		error(("Usage: AceDB:New(tbl, defaults, defaultProfile): 'defaultProfile' - string or true expected, got %q."):format(type(defaultProfile)), 2)
-	end
-
-	return initdb(tbl, defaults, defaultProfile)
-end
-
--- upgrade existing databases
-for db in pairs(AceDB.db_registry) do
-	if not db.parent then
-		for name,func in pairs(DBObjectLib) do
-			db[name] = func
-		end
-	else
-		db.RegisterDefaults = DBObjectLib.RegisterDefaults
-		db.ResetProfile = DBObjectLib.ResetProfile
-	end
-end
+--- **AceDB-3.0** manages the SavedVariables of your addon.
+-- It offers profile management, smart defaults and namespaces for modules.\\
+-- Data can be saved in different data-types, depending on its intended usage.
+-- The most common data-type is the `profile` type, which allows the user to choose
+-- the active profile, and manage the profiles of all of his characters.\\
+-- The following data types are available:
+-- * **char** Character-specific data. Every character has its own database.
+-- * **realm** Realm-specific data. All of the players characters on the same realm share this database.
+-- * **class** Class-specific data. All of the players characters of the same class share this database.
+-- * **race** Race-specific data. All of the players characters of the same race share this database.
+-- * **faction** Faction-specific data. All of the players characters of the same faction share this database.
+-- * **factionrealm** Faction and realm specific data. All of the players characters on the same realm and of the same faction share this database.
+-- * **locale** Locale specific data, based on the locale of the players game client.
+-- * **global** Global Data. All characters on the same account share this database.
+-- * **profile** Profile-specific data. All characters using the same profile share this database. The user can control which profile should be used.
+--
+-- Creating a new Database using the `:New` function will return a new DBObject. A database will inherit all functions
+-- of the DBObjectLib listed here. \\
+-- If you create a new namespaced child-database (`:RegisterNamespace`), you'll get a DBObject as well, but note
+-- that the child-databases cannot individually change their profile, and are linked to their parents profile - and because of that,
+-- the profile related APIs are not available. Only `:RegisterDefaults` and `:ResetProfile` are available on child-databases.
+--
+-- For more details on how to use AceDB-3.0, see the [[AceDB-3.0 Tutorial]].
+--
+-- You may also be interested in [[libdualspec-1-0|LibDualSpec-1.0]] to do profile switching automatically when switching specs.
+--
+-- @usage
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("DBExample")
+--
+-- -- declare defaults to be used in the DB
+-- local defaults = {
+--   profile = {
+--     setting = true,
+--   }
+-- }
+--
+-- function MyAddon:OnInitialize()
+--   -- Assuming the .toc says ## SavedVariables: MyAddonDB
+--   self.db = LibStub("AceDB-3.0"):New("MyAddonDB", defaults, true)
+-- end
+-- @class file
+-- @name AceDB-3.0.lua
+-- @release $Id: AceDB-3.0.lua 1328 2024-03-20 22:36:27Z nevcairiel $
+local ACEDB_MAJOR, ACEDB_MINOR = "AceDB-3.0", 29
+local AceDB = LibStub:NewLibrary(ACEDB_MAJOR, ACEDB_MINOR)
+
+if not AceDB then return end -- No upgrade needed
+
+-- Lua APIs
+local type, pairs, next, error = type, pairs, next, error
+local setmetatable, rawset, rawget = setmetatable, rawset, rawget
+
+-- WoW APIs
+local _G = _G
+
+AceDB.db_registry = AceDB.db_registry or {}
+AceDB.frame = AceDB.frame or CreateFrame("Frame")
+
+local CallbackHandler
+local CallbackDummy = { Fire = function() end }
+
+local DBObjectLib = {}
+
+--[[-------------------------------------------------------------------------
+	AceDB Utility Functions
+---------------------------------------------------------------------------]]
+
+-- Simple shallow copy for copying defaults
+local function copyTable(src, dest)
+	if type(dest) ~= "table" then dest = {} end
+	if type(src) == "table" then
+		for k,v in pairs(src) do
+			if type(v) == "table" then
+				-- try to index the key first so that the metatable creates the defaults, if set, and use that table
+				v = copyTable(v, dest[k])
+			end
+			dest[k] = v
+		end
+	end
+	return dest
+end
+
+-- Called to add defaults to a section of the database
+--
+-- When a ["*"] default section is indexed with a new key, a table is returned
+-- and set in the host table.  These tables must be cleaned up by removeDefaults
+-- in order to ensure we don't write empty default tables.
+local function copyDefaults(dest, src)
+	-- this happens if some value in the SV overwrites our default value with a non-table
+	--if type(dest) ~= "table" then return end
+	for k, v in pairs(src) do
+		if k == "*" or k == "**" then
+			if type(v) == "table" then
+				-- This is a metatable used for table defaults
+				local mt = {
+					-- This handles the lookup and creation of new subtables
+					__index = function(t,k2)
+							if k2 == nil then return nil end
+							local tbl = {}
+							copyDefaults(tbl, v)
+							rawset(t, k2, tbl)
+							return tbl
+						end,
+				}
+				setmetatable(dest, mt)
+				-- handle already existing tables in the SV
+				for dk, dv in pairs(dest) do
+					if not rawget(src, dk) and type(dv) == "table" then
+						copyDefaults(dv, v)
+					end
+				end
+			else
+				-- Values are not tables, so this is just a simple return
+				local mt = {__index = function(t,k2) return k2~=nil and v or nil end}
+				setmetatable(dest, mt)
+			end
+		elseif type(v) == "table" then
+			if not rawget(dest, k) then rawset(dest, k, {}) end
+			if type(dest[k]) == "table" then
+				copyDefaults(dest[k], v)
+				if src['**'] then
+					copyDefaults(dest[k], src['**'])
+				end
+			end
+		else
+			if rawget(dest, k) == nil then
+				rawset(dest, k, v)
+			end
+		end
+	end
+end
+
+-- Called to remove all defaults in the default table from the database
+local function removeDefaults(db, defaults, blocker)
+	-- remove all metatables from the db, so we don't accidentally create new sub-tables through them
+	setmetatable(db, nil)
+	-- loop through the defaults and remove their content
+	for k,v in pairs(defaults) do
+		if k == "*" or k == "**" then
+			if type(v) == "table" then
+				-- Loop through all the actual k,v pairs and remove
+				for key, value in pairs(db) do
+					if type(value) == "table" then
+						-- if the key was not explicitly specified in the defaults table, just strip everything from * and ** tables
+						if defaults[key] == nil and (not blocker or blocker[key] == nil) then
+							removeDefaults(value, v)
+							-- if the table is empty afterwards, remove it
+							if next(value) == nil then
+								db[key] = nil
+							end
+						-- if it was specified, only strip ** content, but block values which were set in the key table
+						elseif k == "**" then
+							removeDefaults(value, v, defaults[key])
+						end
+					end
+				end
+			elseif k == "*" then
+				-- check for non-table default
+				for key, value in pairs(db) do
+					if defaults[key] == nil and v == value then
+						db[key] = nil
+					end
+				end
+			end
+		elseif type(v) == "table" and type(db[k]) == "table" then
+			-- if a blocker was set, dive into it, to allow multi-level defaults
+			removeDefaults(db[k], v, blocker and blocker[k])
+			if next(db[k]) == nil then
+				db[k] = nil
+			end
+		else
+			-- check if the current value matches the default, and that its not blocked by another defaults table
+			if db[k] == defaults[k] and (not blocker or blocker[k] == nil) then
+				db[k] = nil
+			end
+		end
+	end
+end
+
+-- This is called when a table section is first accessed, to set up the defaults
+local function initSection(db, section, svstore, key, defaults)
+	local sv = rawget(db, "sv")
+
+	local tableCreated
+	if not sv[svstore] then sv[svstore] = {} end
+	if not sv[svstore][key] then
+		sv[svstore][key] = {}
+		tableCreated = true
+	end
+
+	local tbl = sv[svstore][key]
+
+	if defaults then
+		copyDefaults(tbl, defaults)
+	end
+	rawset(db, section, tbl)
+
+	return tableCreated, tbl
+end
+
+-- Metatable to handle the dynamic creation of sections and copying of sections.
+local dbmt = {
+	__index = function(t, section)
+			local keys = rawget(t, "keys")
+			local key = keys[section]
+			if key then
+				local defaultTbl = rawget(t, "defaults")
+				local defaults = defaultTbl and defaultTbl[section]
+
+				if section == "profile" then
+					local new = initSection(t, section, "profiles", key, defaults)
+					if new then
+						-- Callback: OnNewProfile, database, newProfileKey
+						t.callbacks:Fire("OnNewProfile", t, key)
+					end
+				elseif section == "profiles" then
+					local sv = rawget(t, "sv")
+					if not sv.profiles then sv.profiles = {} end
+					rawset(t, "profiles", sv.profiles)
+				elseif section == "global" then
+					local sv = rawget(t, "sv")
+					if not sv.global then sv.global = {} end
+					if defaults then
+						copyDefaults(sv.global, defaults)
+					end
+					rawset(t, section, sv.global)
+				else
+					initSection(t, section, section, key, defaults)
+				end
+			end
+
+			return rawget(t, section)
+		end
+}
+
+local function validateDefaults(defaults, keyTbl, offset)
+	if not defaults then return end
+	offset = offset or 0
+	for k in pairs(defaults) do
+		if not keyTbl[k] or k == "profiles" then
+			error(("Usage: AceDBObject:RegisterDefaults(defaults): '%s' is not a valid datatype."):format(k), 3 + offset)
+		end
+	end
+end
+
+local preserve_keys = {
+	["callbacks"] = true,
+	["RegisterCallback"] = true,
+	["UnregisterCallback"] = true,
+	["UnregisterAllCallbacks"] = true,
+	["children"] = true,
+}
+
+local realmKey = GetRealmName()
+local charKey = UnitName("player") .. " - " .. realmKey
+local _, classKey = UnitClass("player")
+local _, raceKey = UnitRace("player")
+local factionKey = UnitFactionGroup("player")
+local factionrealmKey = factionKey .. " - " .. realmKey
+local localeKey = GetLocale():lower()
+
+local regionTable = { "US", "KR", "EU", "TW", "CN" }
+local regionKey = regionTable[GetCurrentRegion()] or GetCurrentRegionName() or "TR"
+local factionrealmregionKey = factionrealmKey .. " - " .. regionKey
+
+-- Actual database initialization function
+local function initdb(sv, defaults, defaultProfile, olddb, parent)
+	-- Generate the database keys for each section
+
+	-- map "true" to our "Default" profile
+	if defaultProfile == true then defaultProfile = "Default" end
+
+	local profileKey
+	if not parent then
+		-- Make a container for profile keys
+		if not sv.profileKeys then sv.profileKeys = {} end
+
+		-- Try to get the profile selected from the char db
+		profileKey = sv.profileKeys[charKey] or defaultProfile or charKey
+
+		-- save the selected profile for later
+		sv.profileKeys[charKey] = profileKey
+	else
+		-- Use the profile of the parents DB
+		profileKey = parent.keys.profile or defaultProfile or charKey
+
+		-- clear the profileKeys in the DB, namespaces don't need to store them
+		sv.profileKeys = nil
+	end
+
+	-- This table contains keys that enable the dynamic creation
+	-- of each section of the table.  The 'global' and 'profiles'
+	-- have a key of true, since they are handled in a special case
+	local keyTbl= {
+		["char"] = charKey,
+		["realm"] = realmKey,
+		["class"] = classKey,
+		["race"] = raceKey,
+		["faction"] = factionKey,
+		["factionrealm"] = factionrealmKey,
+		["factionrealmregion"] = factionrealmregionKey,
+		["profile"] = profileKey,
+		["locale"] = localeKey,
+		["global"] = true,
+		["profiles"] = true,
+	}
+
+	validateDefaults(defaults, keyTbl, 1)
+
+	-- This allows us to use this function to reset an entire database
+	-- Clear out the old database
+	if olddb then
+		for k,v in pairs(olddb) do if not preserve_keys[k] then olddb[k] = nil end end
+	end
+
+	-- Give this database the metatable so it initializes dynamically
+	local db = setmetatable(olddb or {}, dbmt)
+
+	if not rawget(db, "callbacks") then
+		-- try to load CallbackHandler-1.0 if it loaded after our library
+		if not CallbackHandler then CallbackHandler = LibStub:GetLibrary("CallbackHandler-1.0", true) end
+		db.callbacks = CallbackHandler and CallbackHandler:New(db) or CallbackDummy
+	end
+
+	-- Copy methods locally into the database object, to avoid hitting
+	-- the metatable when calling methods
+
+	if not parent then
+		for name, func in pairs(DBObjectLib) do
+			db[name] = func
+		end
+	else
+		-- hack this one in
+		db.RegisterDefaults = DBObjectLib.RegisterDefaults
+		db.ResetProfile = DBObjectLib.ResetProfile
+	end
+
+	-- Set some properties in the database object
+	db.profiles = sv.profiles
+	db.keys = keyTbl
+	db.sv = sv
+	--db.sv_name = name
+	db.defaults = defaults
+	db.parent = parent
+
+	-- store the DB in the registry
+	AceDB.db_registry[db] = true
+
+	return db
+end
+
+-- handle PLAYER_LOGOUT
+-- strip all defaults from all databases
+-- and cleans up empty sections
+local function logoutHandler(frame, event)
+	if event == "PLAYER_LOGOUT" then
+		for db in pairs(AceDB.db_registry) do
+			db.callbacks:Fire("OnDatabaseShutdown", db)
+			db:RegisterDefaults(nil)
+
+			-- cleanup sections that are empty without defaults
+			local sv = rawget(db, "sv")
+			for section in pairs(db.keys) do
+				if rawget(sv, section) then
+					-- global is special, all other sections have sub-entrys
+					-- also don't delete empty profiles on main dbs, only on namespaces
+					if section ~= "global" and (section ~= "profiles" or rawget(db, "parent")) then
+						for key in pairs(sv[section]) do
+							if not next(sv[section][key]) then
+								sv[section][key] = nil
+							end
+						end
+					end
+					if not next(sv[section]) then
+						sv[section] = nil
+					end
+				end
+			end
+		end
+	end
+end
+
+AceDB.frame:RegisterEvent("PLAYER_LOGOUT")
+AceDB.frame:SetScript("OnEvent", logoutHandler)
+
+
+--[[-------------------------------------------------------------------------
+	AceDB Object Method Definitions
+---------------------------------------------------------------------------]]
+
+--- Sets the defaults table for the given database object by clearing any
+-- that are currently set, and then setting the new defaults.
+-- @param defaults A table of defaults for this database
+function DBObjectLib:RegisterDefaults(defaults)
+	if defaults and type(defaults) ~= "table" then
+		error(("Usage: AceDBObject:RegisterDefaults(defaults): 'defaults' - table or nil expected, got %q."):format(type(defaults)), 2)
+	end
+
+	validateDefaults(defaults, self.keys)
+
+	-- Remove any currently set defaults
+	if self.defaults then
+		for section,key in pairs(self.keys) do
+			if self.defaults[section] and rawget(self, section) then
+				removeDefaults(self[section], self.defaults[section])
+			end
+		end
+	end
+
+	-- Set the DBObject.defaults table
+	self.defaults = defaults
+
+	-- Copy in any defaults, only touching those sections already created
+	if defaults then
+		for section,key in pairs(self.keys) do
+			if defaults[section] and rawget(self, section) then
+				copyDefaults(self[section], defaults[section])
+			end
+		end
+	end
+end
+
+--- Changes the profile of the database and all of it's namespaces to the
+-- supplied named profile
+-- @param name The name of the profile to set as the current profile
+function DBObjectLib:SetProfile(name)
+	if type(name) ~= "string" then
+		error(("Usage: AceDBObject:SetProfile(name): 'name' - string expected, got %q."):format(type(name)), 2)
+	end
+
+	-- changing to the same profile, dont do anything
+	if name == self.keys.profile then return end
+
+	local oldProfile = self.profile
+	local defaults = self.defaults and self.defaults.profile
+
+	-- Callback: OnProfileShutdown, database
+	self.callbacks:Fire("OnProfileShutdown", self)
+
+	if oldProfile and defaults then
+		-- Remove the defaults from the old profile
+		removeDefaults(oldProfile, defaults)
+	end
+
+	self.profile = nil
+	self.keys["profile"] = name
+
+	-- if the storage exists, save the new profile
+	-- this won't exist on namespaces.
+	if self.sv.profileKeys then
+		self.sv.profileKeys[charKey] = name
+	end
+
+	-- populate to child namespaces
+	if self.children then
+		for _, db in pairs(self.children) do
+			DBObjectLib.SetProfile(db, name)
+		end
+	end
+
+	-- Callback: OnProfileChanged, database, newProfileKey
+	self.callbacks:Fire("OnProfileChanged", self, name)
+end
+
+--- Returns a table with the names of the existing profiles in the database.
+-- You can optionally supply a table to re-use for this purpose.
+-- @param tbl A table to store the profile names in (optional)
+function DBObjectLib:GetProfiles(tbl)
+	if tbl and type(tbl) ~= "table" then
+		error(("Usage: AceDBObject:GetProfiles(tbl): 'tbl' - table or nil expected, got %q."):format(type(tbl)), 2)
+	end
+
+	-- Clear the container table
+	if tbl then
+		for k,v in pairs(tbl) do tbl[k] = nil end
+	else
+		tbl = {}
+	end
+
+	local curProfile = self.keys.profile
+
+	local i = 0
+	for profileKey in pairs(self.profiles) do
+		i = i + 1
+		tbl[i] = profileKey
+		if curProfile and profileKey == curProfile then curProfile = nil end
+	end
+
+	-- Add the current profile, if it hasn't been created yet
+	if curProfile then
+		i = i + 1
+		tbl[i] = curProfile
+	end
+
+	return tbl, i
+end
+
+--- Returns the current profile name used by the database
+function DBObjectLib:GetCurrentProfile()
+	return self.keys.profile
+end
+
+--- Deletes a named profile.  This profile must not be the active profile.
+-- @param name The name of the profile to be deleted
+-- @param silent If true, do not raise an error when the profile does not exist
+function DBObjectLib:DeleteProfile(name, silent)
+	if type(name) ~= "string" then
+		error(("Usage: AceDBObject:DeleteProfile(name): 'name' - string expected, got %q."):format(type(name)), 2)
+	end
+
+	if self.keys.profile == name then
+		error(("Cannot delete the active profile (%q) in an AceDBObject."):format(name), 2)
+	end
+
+	if not rawget(self.profiles, name) and not silent then
+		error(("Cannot delete profile %q as it does not exist."):format(name), 2)
+	end
+
+	self.profiles[name] = nil
+
+	-- populate to child namespaces
+	if self.children then
+		for _, db in pairs(self.children) do
+			DBObjectLib.DeleteProfile(db, name, true)
+		end
+	end
+
+	-- switch all characters that use this profile back to the default
+	if self.sv.profileKeys then
+		for key, profile in pairs(self.sv.profileKeys) do
+			if profile == name then
+				self.sv.profileKeys[key] = nil
+			end
+		end
+	end
+
+	-- Callback: OnProfileDeleted, database, profileKey
+	self.callbacks:Fire("OnProfileDeleted", self, name)
+end
+
+--- Copies a named profile into the current profile, overwriting any conflicting
+-- settings.
+-- @param name The name of the profile to be copied into the current profile
+-- @param silent If true, do not raise an error when the profile does not exist
+function DBObjectLib:CopyProfile(name, silent)
+	if type(name) ~= "string" then
+		error(("Usage: AceDBObject:CopyProfile(name): 'name' - string expected, got %q."):format(type(name)), 2)
+	end
+
+	if name == self.keys.profile then
+		error(("Cannot have the same source and destination profiles (%q)."):format(name), 2)
+	end
+
+	if not rawget(self.profiles, name) and not silent then
+		error(("Cannot copy profile %q as it does not exist."):format(name), 2)
+	end
+
+	-- Reset the profile before copying
+	DBObjectLib.ResetProfile(self, nil, true)
+
+	local profile = self.profile
+	local source = self.profiles[name]
+
+	copyTable(source, profile)
+
+	-- populate to child namespaces
+	if self.children then
+		for _, db in pairs(self.children) do
+			DBObjectLib.CopyProfile(db, name, true)
+		end
+	end
+
+	-- Callback: OnProfileCopied, database, sourceProfileKey
+	self.callbacks:Fire("OnProfileCopied", self, name)
+end
+
+--- Resets the current profile to the default values (if specified).
+-- @param noChildren if set to true, the reset will not be populated to the child namespaces of this DB object
+-- @param noCallbacks if set to true, won't fire the OnProfileReset callback
+function DBObjectLib:ResetProfile(noChildren, noCallbacks)
+	local profile = self.profile
+
+	for k,v in pairs(profile) do
+		profile[k] = nil
+	end
+
+	local defaults = self.defaults and self.defaults.profile
+	if defaults then
+		copyDefaults(profile, defaults)
+	end
+
+	-- populate to child namespaces
+	if self.children and not noChildren then
+		for _, db in pairs(self.children) do
+			DBObjectLib.ResetProfile(db, nil, noCallbacks)
+		end
+	end
+
+	-- Callback: OnProfileReset, database
+	if not noCallbacks then
+		self.callbacks:Fire("OnProfileReset", self)
+	end
+end
+
+--- Resets the entire database, using the string defaultProfile as the new default
+-- profile.
+-- @param defaultProfile The profile name to use as the default
+function DBObjectLib:ResetDB(defaultProfile)
+	if defaultProfile and type(defaultProfile) ~= "string" and defaultProfile ~= true then
+		error(("Usage: AceDBObject:ResetDB(defaultProfile): 'defaultProfile' - string or true expected, got %q."):format(type(defaultProfile)), 2)
+	end
+
+	local sv = self.sv
+	for k,v in pairs(sv) do
+		sv[k] = nil
+	end
+
+	initdb(sv, self.defaults, defaultProfile, self)
+
+	-- fix the child namespaces
+	if self.children then
+		if not sv.namespaces then sv.namespaces = {} end
+		for name, db in pairs(self.children) do
+			if not sv.namespaces[name] then sv.namespaces[name] = {} end
+			initdb(sv.namespaces[name], db.defaults, self.keys.profile, db, self)
+		end
+	end
+
+	-- Callback: OnDatabaseReset, database
+	self.callbacks:Fire("OnDatabaseReset", self)
+	-- Callback: OnProfileChanged, database, profileKey
+	self.callbacks:Fire("OnProfileChanged", self, self.keys["profile"])
+
+	return self
+end
+
+--- Creates a new database namespace, directly tied to the database.  This
+-- is a full scale database in it's own rights other than the fact that
+-- it cannot control its profile individually
+-- @param name The name of the new namespace
+-- @param defaults A table of values to use as defaults
+function DBObjectLib:RegisterNamespace(name, defaults)
+	if type(name) ~= "string" then
+		error(("Usage: AceDBObject:RegisterNamespace(name, defaults): 'name' - string expected, got %q."):format(type(name)), 2)
+	end
+	if defaults and type(defaults) ~= "table" then
+		error(("Usage: AceDBObject:RegisterNamespace(name, defaults): 'defaults' - table or nil expected, got %q."):format(type(defaults)), 2)
+	end
+	if self.children and self.children[name] then
+		error(("Usage: AceDBObject:RegisterNamespace(name, defaults): 'name' - a namespace called %q already exists."):format(name), 2)
+	end
+
+	local sv = self.sv
+	if not sv.namespaces then sv.namespaces = {} end
+	if not sv.namespaces[name] then
+		sv.namespaces[name] = {}
+	end
+
+	local newDB = initdb(sv.namespaces[name], defaults, self.keys.profile, nil, self)
+
+	if not self.children then self.children = {} end
+	self.children[name] = newDB
+	return newDB
+end
+
+--- Returns an already existing namespace from the database object.
+-- @param name The name of the new namespace
+-- @param silent if true, the addon is optional, silently return nil if its not found
+-- @usage
+-- local namespace = self.db:GetNamespace('namespace')
+-- @return the namespace object if found
+function DBObjectLib:GetNamespace(name, silent)
+	if type(name) ~= "string" then
+		error(("Usage: AceDBObject:GetNamespace(name): 'name' - string expected, got %q."):format(type(name)), 2)
+	end
+	if not silent and not (self.children and self.children[name]) then
+		error(("Usage: AceDBObject:GetNamespace(name): 'name' - namespace %q does not exist."):format(name), 2)
+	end
+	if not self.children then self.children = {} end
+	return self.children[name]
+end
+
+--[[-------------------------------------------------------------------------
+	AceDB Exposed Methods
+---------------------------------------------------------------------------]]
+
+--- Creates a new database object that can be used to handle database settings and profiles.
+-- By default, an empty DB is created, using a character specific profile.
+--
+-- You can override the default profile used by passing any profile name as the third argument,
+-- or by passing //true// as the third argument to use a globally shared profile called "Default".
+--
+-- Note that there is no token replacement in the default profile name, passing a defaultProfile as "char"
+-- will use a profile named "char", and not a character-specific profile.
+-- @param tbl The name of variable, or table to use for the database
+-- @param defaults A table of database defaults
+-- @param defaultProfile The name of the default profile. If not set, a character specific profile will be used as the default.
+-- You can also pass //true// to use a shared global profile called "Default".
+-- @usage
+-- -- Create an empty DB using a character-specific default profile.
+-- self.db = LibStub("AceDB-3.0"):New("MyAddonDB")
+-- @usage
+-- -- Create a DB using defaults and using a shared default profile
+-- self.db = LibStub("AceDB-3.0"):New("MyAddonDB", defaults, true)
+function AceDB:New(tbl, defaults, defaultProfile)
+	if type(tbl) == "string" then
+		local name = tbl
+		tbl = _G[name]
+		if not tbl then
+			tbl = {}
+			_G[name] = tbl
+		end
+	end
+
+	if type(tbl) ~= "table" then
+		error(("Usage: AceDB:New(tbl, defaults, defaultProfile): 'tbl' - table expected, got %q."):format(type(tbl)), 2)
+	end
+
+	if defaults and type(defaults) ~= "table" then
+		error(("Usage: AceDB:New(tbl, defaults, defaultProfile): 'defaults' - table expected, got %q."):format(type(defaults)), 2)
+	end
+
+	if defaultProfile and type(defaultProfile) ~= "string" and defaultProfile ~= true then
+		error(("Usage: AceDB:New(tbl, defaults, defaultProfile): 'defaultProfile' - string or true expected, got %q."):format(type(defaultProfile)), 2)
+	end
+
+	return initdb(tbl, defaults, defaultProfile)
+end
+
+-- upgrade existing databases
+for db in pairs(AceDB.db_registry) do
+	if not db.parent then
+		for name,func in pairs(DBObjectLib) do
+			db[name] = func
+		end
+	else
+		db.RegisterDefaults = DBObjectLib.RegisterDefaults
+		db.ResetProfile = DBObjectLib.ResetProfile
+	end
+end
diff --git a/Carbonite/Libs/AceDB-3.0/AceDB-3.0.xml b/Carbonite/Libs/AceDB-3.0/AceDB-3.0.xml
index 28998e5..108fc70 100644
--- a/Carbonite/Libs/AceDB-3.0/AceDB-3.0.xml
+++ b/Carbonite/Libs/AceDB-3.0/AceDB-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceDB-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceDB-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceDBOptions-3.0/AceDBOptions-3.0.lua b/Carbonite/Libs/AceDBOptions-3.0/AceDBOptions-3.0.lua
index da4c5f2..46a85bf 100644
--- a/Carbonite/Libs/AceDBOptions-3.0/AceDBOptions-3.0.lua
+++ b/Carbonite/Libs/AceDBOptions-3.0/AceDBOptions-3.0.lua
@@ -1,456 +1,456 @@
---- AceDBOptions-3.0 provides a universal AceConfig options screen for managing AceDB-3.0 profiles.
--- @class file
--- @name AceDBOptions-3.0
--- @release $Id: AceDBOptions-3.0.lua 1304 2023-05-19 19:50:10Z nevcairiel $
-local ACEDBO_MAJOR, ACEDBO_MINOR = "AceDBOptions-3.0", 15
-local AceDBOptions = LibStub:NewLibrary(ACEDBO_MAJOR, ACEDBO_MINOR)
-
-if not AceDBOptions then return end -- No upgrade needed
-
--- Lua APIs
-local pairs, next = pairs, next
-
--- WoW APIs
-local UnitClass = UnitClass
-
-AceDBOptions.optionTables = AceDBOptions.optionTables or {}
-AceDBOptions.handlers = AceDBOptions.handlers or {}
-
---[[
-	Localization of AceDBOptions-3.0
-]]
-
-local L = {
-	choose = "Existing Profiles",
-	choose_desc = "You can either create a new profile by entering a name in the editbox, or choose one of the already existing profiles.",
-	choose_sub = "Select one of your currently available profiles.",
-	copy = "Copy From",
-	copy_desc = "Copy the settings from one existing profile into the currently active profile.",
-	current = "Current Profile:",
-	default = "Default",
-	delete = "Delete a Profile",
-	delete_confirm = "Are you sure you want to delete the selected profile?",
-	delete_desc = "Delete existing and unused profiles from the database to save space, and cleanup the SavedVariables file.",
-	delete_sub = "Deletes a profile from the database.",
-	intro = "You can change the active database profile, so you can have different settings for every character.",
-	new = "New",
-	new_sub = "Create a new empty profile.",
-	profiles = "Profiles",
-	profiles_sub = "Manage Profiles",
-	reset = "Reset Profile",
-	reset_desc = "Reset the current profile back to its default values, in case your configuration is broken, or you simply want to start over.",
-	reset_sub = "Reset the current profile to the default",
-}
-
-local LOCALE = GetLocale()
-if LOCALE == "deDE" then
-	L["choose"] = "Vorhandene Profile"
-	L["choose_desc"] = "Du kannst ein neues Profil erstellen, indem du einen neuen Namen in der Eingabebox 'Neu' eingibst, oder whle eines der vorhandenen Profile aus."
-	L["choose_sub"] = "Whlt ein bereits vorhandenes Profil aus."
-	L["copy"] = "Kopieren von..."
-	L["copy_desc"] = "Kopiere die Einstellungen von einem vorhandenen Profil in das aktive Profil."
-	L["current"] = "Aktuelles Profil:"
-	L["default"] = "Standard"
-	L["delete"] = "Profil lschen"
-	L["delete_confirm"] = "Willst du das ausgewhlte Profil wirklich lschen?"
-	L["delete_desc"] = "Lsche vorhandene oder unbenutzte Profile aus der Datenbank, um Platz zu sparen und die SavedVariables-Datei 'sauber' zu halten."
-	L["delete_sub"] = "Lscht ein Profil aus der Datenbank."
-	L["intro"] = "Hier kannst du das aktive Datenbankprofil ndern, damit du verschiedene Einstellungen fr jeden Charakter erstellen kannst, wodurch eine sehr flexible Konfiguration mglich wird."
-	L["new"] = "Neu"
-	L["new_sub"] = "Ein neues Profil erstellen."
-	L["profiles"] = "Profile"
-	L["profiles_sub"] = "Profile verwalten"
-	L["reset"] = "Profil zurcksetzen"
-	L["reset_desc"] = "Setzt das momentane Profil auf Standardwerte zurck, fr den Fall, dass mit der Konfiguration etwas schief lief oder weil du einfach neu starten willst."
-	L["reset_sub"] = "Das aktuelle Profil auf Standard zurcksetzen."
-elseif LOCALE == "frFR" then
-	L["choose"] = "Profils existants"
-	L["choose_desc"] = "Vous pouvez crer un nouveau profil en entrant un nouveau nom dans la bote de saisie, ou en choississant un des profils dj existants."
-	L["choose_sub"] = "Permet de choisir un des profils dj disponibles."
-	L["copy"] = "Copier  partir de"
-	L["copy_desc"] = "Copie les paramtres d'un profil dj existant dans le profil actuellement actif."
-	L["current"] = "Profil actuel :"
-	L["default"] = "Dfaut"
-	L["delete"] = "Supprimer un profil"
-	L["delete_confirm"] = "Etes-vous sr de vouloir supprimer le profil slectionn ?"
-	L["delete_desc"] = "Supprime les profils existants inutiliss de la base de donnes afin de gagner de la place et de nettoyer le fichier SavedVariables."
-	L["delete_sub"] = "Supprime un profil de la base de donnes."
-	L["intro"] = "Vous pouvez changer le profil actuel afin d'avoir des paramtres diffrents pour chaque personnage, permettant ainsi d'avoir une configuration trs flexible."
-	L["new"] = "Nouveau"
-	L["new_sub"] = "Cre un nouveau profil vierge."
-	L["profiles"] = "Profils"
-	L["profiles_sub"] = "Gestion des profils"
-	L["reset"] = "Rinitialiser le profil"
-	L["reset_desc"] = "Rinitialise le profil actuel au cas o votre configuration est corrompue ou si vous voulez tout simplement faire table rase."
-	L["reset_sub"] = "Rinitialise le profil actuel avec les paramtres par dfaut."
-elseif LOCALE == "koKR" then
-	L["choose"] = " "
-	L["choose_desc"] = "              ."
-	L["choose_sub"] = "       ."
-	L["copy"] = "  "
-	L["copy_desc"] = "      ."
-	L["current"] = " :"
-	L["default"] = ""
-	L["delete"] = " "
-	L["delete_confirm"] = "  ?"
-	L["delete_desc"] = "         SavedVariables  ."
-	L["delete_sub"] = "  ."
-	L["intro"] = "     ,        ."
-	L["new"] = " "
-	L["new_sub"] = "    ."
-	L["profiles"] = ""
-	L["profiles_sub"] = " "
-	L["reset"] = " "
-	L["reset_desc"] = "          ."
-	L["reset_sub"] = "   "
-elseif LOCALE == "esES" or LOCALE == "esMX" then
-	L["choose"] = "Perfiles existentes"
-	L["choose_desc"] = "Puedes crear un nuevo perfil introduciendo un nombre en el recuadro o puedes seleccionar un perfil de los ya existentes."
-	L["choose_sub"] = "Selecciona uno de los perfiles disponibles."
-	L["copy"] = "Copiar de"
-	L["copy_desc"] = "Copia los ajustes de un perfil existente al perfil actual."
-	L["current"] = "Perfil actual:"
-	L["default"] = "Por defecto"
-	L["delete"] = "Borrar un Perfil"
-	L["delete_confirm"] = "Estas seguro que quieres borrar el perfil seleccionado?"
-	L["delete_desc"] = "Borra los perfiles existentes y sin uso de la base de datos para ganar espacio y limpiar el archivo SavedVariables."
-	L["delete_sub"] = "Borra un perfil de la base de datos."
-	L["intro"] = "Puedes cambiar el perfil activo de tal manera que cada personaje tenga diferentes configuraciones."
-	L["new"] = "Nuevo"
-	L["new_sub"] = "Crear un nuevo perfil vacio."
-	L["profiles"] = "Perfiles"
-	L["profiles_sub"] = "Manejar Perfiles"
-	L["reset"] = "Reiniciar Perfil"
-	L["reset_desc"] = "Reinicia el perfil actual a los valores por defectos, en caso de que se haya estropeado la configuracin o quieras volver a empezar de nuevo."
-	L["reset_sub"] = "Reinicar el perfil actual al de por defecto"
-elseif LOCALE == "zhTW" then
-	L["choose"] = ""
-	L["choose_desc"] = ""
-	L["choose_sub"] = ""
-	L["copy"] = ""
-	L["copy_desc"] = ""
-	L["current"] = ""
-	L["default"] = ""
-	L["delete"] = ""
-	L["delete_confirm"] = ""
-	L["delete_desc"] = " SavedVariables "
-	L["delete_sub"] = ""
-	L["intro"] = ""
-	L["new"] = ""
-	L["new_sub"] = ""
-	L["profiles"] = ""
-	L["profiles_sub"] = ""
-	L["reset"] = ""
-	L["reset_desc"] = ""
-	L["reset_sub"] = ""
-elseif LOCALE == "zhCN" then
-	L["choose"] = ""
-	L["choose_desc"] = ""
-	L["choose_sub"] = ""
-	L["copy"] = ""
-	L["copy_desc"] = ""
-	L["current"] = ""
-	L["default"] = ""
-	L["delete"] = ""
-	L["delete_confirm"] = ""
-	L["delete_desc"] = "SavedVariables"
-	L["delete_sub"] = ""
-	L["intro"] = ""
-	L["new"] = ""
-	L["new_sub"] = ""
-	L["profiles"] = ""
-	L["profiles_sub"] = ""
-	L["reset"] = ""
-	L["reset_desc"] = ""
-	L["reset_sub"] = ""
-elseif LOCALE == "ruRU" then
-	L["choose"] = " "
-	L["choose_desc"] = "    ,     ,       ."
-	L["choose_sub"] = "     ."
-	L["copy"] = " "
-	L["copy_desc"] = "      ."
-	L["current"] = " :"
-	L["default"] = " "
-	L["delete"] = " "
-	L["delete_confirm"] = " ,     ?"
-	L["delete_desc"] = "          ,    SavedVariables."
-	L["delete_sub"] = "    ."
-	L["intro"] = "  ,        ."
-	L["new"] = ""
-	L["new_sub"] = "   ."
-	L["profiles"] = ""
-	L["profiles_sub"] = " "
-	L["reset"] = " "
-	L["reset_desc"] = "     ,          ."
-	L["reset_sub"] = "    "
-elseif LOCALE == "itIT" then
-	L["choose"] = "Profili Esistenti"
-	L["choose_desc"] = "Puoi creare un nuovo profilo digitando il nome della casella di testo, oppure scegliendone uno tra i profili gi esistenti."
-	L["choose_sub"] = "Seleziona uno dei profili attualmente disponibili."
-	L["copy"] = "Copia Da"
-	L["copy_desc"] = "Copia le impostazioni da un profilo esistente nel profilo attivo in questo momento."
-	L["current"] = "Profilo Attivo:"
-	L["default"] = "Predefinito"
-	L["delete"] = "Cancella un Profilo"
-	L["delete_confirm"] = "Sei sicuro di voler cancellare il profilo selezionato?"
-	L["delete_desc"] = "Cancella i profili non utilizzati dal database per risparmiare spazio e mantenere puliti i file di configurazione SavedVariables."
-	L["delete_sub"] = "Cancella un profilo dal Database."
-	L["intro"] = "Puoi cambiare il profilo attivo, in modo da usare impostazioni diverse per ogni personaggio."
-	L["new"] = "Nuovo"
-	L["new_sub"] = "Crea un nuovo profilo vuoto."
-	L["profiles"] = "Profili"
-	L["profiles_sub"] = "Gestisci Profili"
-	L["reset"] = "Reimposta Profilo"
-	L["reset_desc"] = "Riporta il tuo profilo attivo alle sue impostazioni predefinite, nel caso in cui la tua configurazione si sia corrotta, o semplicemente tu voglia re-inizializzarla."
-	L["reset_sub"] = "Reimposta il profilo ai suoi valori predefiniti."
-elseif LOCALE == "ptBR" then
-	L["choose"] = "Perfis Existentes"
-	L["choose_desc"] = "Voc pode tanto criar um perfil novo tanto digitando um nome na caixa de texto, quanto escolher um dos perfis j existentes."
-	L["choose_sub"] = "Selecione um de seus perfis atualmente disponveis."
-	L["copy"] = "Copiar De"
-	L["copy_desc"] = "Copia as definies de um perfil existente no perfil atualmente ativo."
-	L["current"] = "Perfil Autal:"
-	L["default"] = "Padro"
-	L["delete"] = "Remover um Perfil"
-	L["delete_confirm"] = "Tem certeza que deseja remover o perfil selecionado?"
-	L["delete_desc"] = "Remove perfis existentes e inutilizados do banco de dados para economizar espao, e limpar o arquivo SavedVariables."
-	L["delete_sub"] = "Remove um perfil do banco de dados."
-	L["intro"] = "Voc pode alterar o perfil do banco de dados ativo, para que possa ter definies diferentes para cada personagem."
-	L["new"] = "Novo"
-	L["new_sub"] = "Cria um novo perfil vazio."
-	L["profiles"] = "Perfis"
-	L["profiles_sub"] = "Gerenciar Perfis"
-	L["reset"] = "Resetar Perfil"
-	L["reset_desc"] = "Reseta o perfil atual para os valores padres, no caso de sua configurao estar quebrada, ou simplesmente se deseja comear novamente."
-	L["reset_sub"] = "Resetar o perfil atual ao padro"
-end
-
-local defaultProfiles
-local tmpprofiles = {}
-
--- Get a list of available profiles for the specified database.
--- You can specify which profiles to include/exclude in the list using the two boolean parameters listed below.
--- @param db The db object to retrieve the profiles from
--- @param common If true, getProfileList will add the default profiles to the return list, even if they have not been created yet
--- @param nocurrent If true, then getProfileList will not display the current profile in the list
--- @return Hashtable of all profiles with the internal name as keys and the display name as value.
-local function getProfileList(db, common, nocurrent)
-	local profiles = {}
-
-	-- copy existing profiles into the table
-	local currentProfile = db:GetCurrentProfile()
-	for i,v in pairs(db:GetProfiles(tmpprofiles)) do
-		if not (nocurrent and v == currentProfile) then
-			profiles[v] = v
-		end
-	end
-
-	-- add our default profiles to choose from ( or rename existing profiles)
-	for k,v in pairs(defaultProfiles) do
-		if (common or profiles[k]) and not (nocurrent and k == currentProfile) then
-			profiles[k] = v
-		end
-	end
-
-	return profiles
-end
-
---[[
-	OptionsHandlerPrototype
-	prototype class for handling the options in a sane way
-]]
-local OptionsHandlerPrototype = {}
-
---[[ Reset the profile ]]
-function OptionsHandlerPrototype:Reset()
-	self.db:ResetProfile()
-end
-
---[[ Set the profile to value ]]
-function OptionsHandlerPrototype:SetProfile(info, value)
-	self.db:SetProfile(value)
-end
-
---[[ returns the currently active profile ]]
-function OptionsHandlerPrototype:GetCurrentProfile()
-	return self.db:GetCurrentProfile()
-end
-
---[[
-	List all active profiles
-	you can control the output with the .arg variable
-	currently four modes are supported
-
-	(empty) - return all available profiles
-	"nocurrent" - returns all available profiles except the currently active profile
-	"common" - returns all avaialble profiles + some commonly used profiles ("char - realm", "realm", "class", "Default")
-	"both" - common except the active profile
-]]
-function OptionsHandlerPrototype:ListProfiles(info)
-	local arg = info.arg
-	local profiles
-	if arg == "common" and not self.noDefaultProfiles then
-		profiles = getProfileList(self.db, true, nil)
-	elseif arg == "nocurrent" then
-		profiles = getProfileList(self.db, nil, true)
-	elseif arg == "both" then -- currently not used
-		profiles = getProfileList(self.db, (not self.noDefaultProfiles) and true, true)
-	else
-		profiles = getProfileList(self.db)
-	end
-
-	return profiles
-end
-
-function OptionsHandlerPrototype:HasNoProfiles(info)
-	local profiles = self:ListProfiles(info)
-	return ((not next(profiles)) and true or false)
-end
-
---[[ Copy a profile ]]
-function OptionsHandlerPrototype:CopyProfile(info, value)
-	self.db:CopyProfile(value)
-end
-
---[[ Delete a profile from the db ]]
-function OptionsHandlerPrototype:DeleteProfile(info, value)
-	self.db:DeleteProfile(value)
-end
-
---[[ fill defaultProfiles with some generic values ]]
-local function generateDefaultProfiles(db)
-	defaultProfiles = {
-		["Default"] = L["default"],
-		[db.keys.char] = db.keys.char,
-		[db.keys.realm] = db.keys.realm,
-		[db.keys.class] = UnitClass("player")
-	}
-end
-
---[[ create and return a handler object for the db, or upgrade it if it already existed ]]
-local function getOptionsHandler(db, noDefaultProfiles)
-	if not defaultProfiles then
-		generateDefaultProfiles(db)
-	end
-
-	local handler = AceDBOptions.handlers[db] or { db = db, noDefaultProfiles = noDefaultProfiles }
-
-	for k,v in pairs(OptionsHandlerPrototype) do
-		handler[k] = v
-	end
-
-	AceDBOptions.handlers[db] = handler
-	return handler
-end
-
---[[
-	the real options table
-]]
-local optionsTable = {
-	desc = {
-		order = 1,
-		type = "description",
-		name = L["intro"] .. "\n",
-	},
-	descreset = {
-		order = 9,
-		type = "description",
-		name = L["reset_desc"],
-	},
-	reset = {
-		order = 10,
-		type = "execute",
-		name = L["reset"],
-		desc = L["reset_sub"],
-		func = "Reset",
-	},
-	current = {
-		order = 11,
-		type = "description",
-		name = function(info) return L["current"] .. " " .. NORMAL_FONT_COLOR_CODE .. info.handler:GetCurrentProfile() .. FONT_COLOR_CODE_CLOSE end,
-		width = "default",
-	},
-	choosedesc = {
-		order = 20,
-		type = "description",
-		name = "\n" .. L["choose_desc"],
-	},
-	new = {
-		name = L["new"],
-		desc = L["new_sub"],
-		type = "input",
-		order = 30,
-		get = false,
-		set = "SetProfile",
-	},
-	choose = {
-		name = L["choose"],
-		desc = L["choose_sub"],
-		type = "select",
-		order = 40,
-		get = "GetCurrentProfile",
-		set = "SetProfile",
-		values = "ListProfiles",
-		arg = "common",
-	},
-	copydesc = {
-		order = 50,
-		type = "description",
-		name = "\n" .. L["copy_desc"],
-	},
-	copyfrom = {
-		order = 60,
-		type = "select",
-		name = L["copy"],
-		desc = L["copy_desc"],
-		get = false,
-		set = "CopyProfile",
-		values = "ListProfiles",
-		disabled = "HasNoProfiles",
-		arg = "nocurrent",
-	},
-	deldesc = {
-		order = 70,
-		type = "description",
-		name = "\n" .. L["delete_desc"],
-	},
-	delete = {
-		order = 80,
-		type = "select",
-		name = L["delete"],
-		desc = L["delete_sub"],
-		get = false,
-		set = "DeleteProfile",
-		values = "ListProfiles",
-		disabled = "HasNoProfiles",
-		arg = "nocurrent",
-		confirm = true,
-		confirmText = L["delete_confirm"],
-	},
-}
-
---- Get/Create a option table that you can use in your addon to control the profiles of AceDB-3.0.
--- @param db The database object to create the options table for.
--- @return The options table to be used in AceConfig-3.0
--- @usage
--- -- Assuming `options` is your top-level options table and `self.db` is your database:
--- options.args.profiles = LibStub("AceDBOptions-3.0"):GetOptionsTable(self.db)
-function AceDBOptions:GetOptionsTable(db, noDefaultProfiles)
-	local tbl = AceDBOptions.optionTables[db] or {
-			type = "group",
-			name = L["profiles"],
-			desc = L["profiles_sub"],
-		}
-
-	tbl.handler = getOptionsHandler(db, noDefaultProfiles)
-	tbl.args = optionsTable
-
-	AceDBOptions.optionTables[db] = tbl
-	return tbl
-end
-
--- upgrade existing tables
-for db,tbl in pairs(AceDBOptions.optionTables) do
-	tbl.handler = getOptionsHandler(db)
-	tbl.args = optionsTable
-end
+--- AceDBOptions-3.0 provides a universal AceConfig options screen for managing AceDB-3.0 profiles.
+-- @class file
+-- @name AceDBOptions-3.0
+-- @release $Id: AceDBOptions-3.0.lua 1304 2023-05-19 19:50:10Z nevcairiel $
+local ACEDBO_MAJOR, ACEDBO_MINOR = "AceDBOptions-3.0", 15
+local AceDBOptions = LibStub:NewLibrary(ACEDBO_MAJOR, ACEDBO_MINOR)
+
+if not AceDBOptions then return end -- No upgrade needed
+
+-- Lua APIs
+local pairs, next = pairs, next
+
+-- WoW APIs
+local UnitClass = UnitClass
+
+AceDBOptions.optionTables = AceDBOptions.optionTables or {}
+AceDBOptions.handlers = AceDBOptions.handlers or {}
+
+--[[
+	Localization of AceDBOptions-3.0
+]]
+
+local L = {
+	choose = "Existing Profiles",
+	choose_desc = "You can either create a new profile by entering a name in the editbox, or choose one of the already existing profiles.",
+	choose_sub = "Select one of your currently available profiles.",
+	copy = "Copy From",
+	copy_desc = "Copy the settings from one existing profile into the currently active profile.",
+	current = "Current Profile:",
+	default = "Default",
+	delete = "Delete a Profile",
+	delete_confirm = "Are you sure you want to delete the selected profile?",
+	delete_desc = "Delete existing and unused profiles from the database to save space, and cleanup the SavedVariables file.",
+	delete_sub = "Deletes a profile from the database.",
+	intro = "You can change the active database profile, so you can have different settings for every character.",
+	new = "New",
+	new_sub = "Create a new empty profile.",
+	profiles = "Profiles",
+	profiles_sub = "Manage Profiles",
+	reset = "Reset Profile",
+	reset_desc = "Reset the current profile back to its default values, in case your configuration is broken, or you simply want to start over.",
+	reset_sub = "Reset the current profile to the default",
+}
+
+local LOCALE = GetLocale()
+if LOCALE == "deDE" then
+	L["choose"] = "Vorhandene Profile"
+	L["choose_desc"] = "Du kannst ein neues Profil erstellen, indem du einen neuen Namen in der Eingabebox 'Neu' eingibst, oder whle eines der vorhandenen Profile aus."
+	L["choose_sub"] = "Whlt ein bereits vorhandenes Profil aus."
+	L["copy"] = "Kopieren von..."
+	L["copy_desc"] = "Kopiere die Einstellungen von einem vorhandenen Profil in das aktive Profil."
+	L["current"] = "Aktuelles Profil:"
+	L["default"] = "Standard"
+	L["delete"] = "Profil lschen"
+	L["delete_confirm"] = "Willst du das ausgewhlte Profil wirklich lschen?"
+	L["delete_desc"] = "Lsche vorhandene oder unbenutzte Profile aus der Datenbank, um Platz zu sparen und die SavedVariables-Datei 'sauber' zu halten."
+	L["delete_sub"] = "Lscht ein Profil aus der Datenbank."
+	L["intro"] = "Hier kannst du das aktive Datenbankprofil ndern, damit du verschiedene Einstellungen fr jeden Charakter erstellen kannst, wodurch eine sehr flexible Konfiguration mglich wird."
+	L["new"] = "Neu"
+	L["new_sub"] = "Ein neues Profil erstellen."
+	L["profiles"] = "Profile"
+	L["profiles_sub"] = "Profile verwalten"
+	L["reset"] = "Profil zurcksetzen"
+	L["reset_desc"] = "Setzt das momentane Profil auf Standardwerte zurck, fr den Fall, dass mit der Konfiguration etwas schief lief oder weil du einfach neu starten willst."
+	L["reset_sub"] = "Das aktuelle Profil auf Standard zurcksetzen."
+elseif LOCALE == "frFR" then
+	L["choose"] = "Profils existants"
+	L["choose_desc"] = "Vous pouvez crer un nouveau profil en entrant un nouveau nom dans la bote de saisie, ou en choississant un des profils dj existants."
+	L["choose_sub"] = "Permet de choisir un des profils dj disponibles."
+	L["copy"] = "Copier  partir de"
+	L["copy_desc"] = "Copie les paramtres d'un profil dj existant dans le profil actuellement actif."
+	L["current"] = "Profil actuel :"
+	L["default"] = "Dfaut"
+	L["delete"] = "Supprimer un profil"
+	L["delete_confirm"] = "Etes-vous sr de vouloir supprimer le profil slectionn ?"
+	L["delete_desc"] = "Supprime les profils existants inutiliss de la base de donnes afin de gagner de la place et de nettoyer le fichier SavedVariables."
+	L["delete_sub"] = "Supprime un profil de la base de donnes."
+	L["intro"] = "Vous pouvez changer le profil actuel afin d'avoir des paramtres diffrents pour chaque personnage, permettant ainsi d'avoir une configuration trs flexible."
+	L["new"] = "Nouveau"
+	L["new_sub"] = "Cre un nouveau profil vierge."
+	L["profiles"] = "Profils"
+	L["profiles_sub"] = "Gestion des profils"
+	L["reset"] = "Rinitialiser le profil"
+	L["reset_desc"] = "Rinitialise le profil actuel au cas o votre configuration est corrompue ou si vous voulez tout simplement faire table rase."
+	L["reset_sub"] = "Rinitialise le profil actuel avec les paramtres par dfaut."
+elseif LOCALE == "koKR" then
+	L["choose"] = " "
+	L["choose_desc"] = "              ."
+	L["choose_sub"] = "       ."
+	L["copy"] = "  "
+	L["copy_desc"] = "      ."
+	L["current"] = " :"
+	L["default"] = ""
+	L["delete"] = " "
+	L["delete_confirm"] = "  ?"
+	L["delete_desc"] = "         SavedVariables  ."
+	L["delete_sub"] = "  ."
+	L["intro"] = "     ,        ."
+	L["new"] = " "
+	L["new_sub"] = "    ."
+	L["profiles"] = ""
+	L["profiles_sub"] = " "
+	L["reset"] = " "
+	L["reset_desc"] = "          ."
+	L["reset_sub"] = "   "
+elseif LOCALE == "esES" or LOCALE == "esMX" then
+	L["choose"] = "Perfiles existentes"
+	L["choose_desc"] = "Puedes crear un nuevo perfil introduciendo un nombre en el recuadro o puedes seleccionar un perfil de los ya existentes."
+	L["choose_sub"] = "Selecciona uno de los perfiles disponibles."
+	L["copy"] = "Copiar de"
+	L["copy_desc"] = "Copia los ajustes de un perfil existente al perfil actual."
+	L["current"] = "Perfil actual:"
+	L["default"] = "Por defecto"
+	L["delete"] = "Borrar un Perfil"
+	L["delete_confirm"] = "Estas seguro que quieres borrar el perfil seleccionado?"
+	L["delete_desc"] = "Borra los perfiles existentes y sin uso de la base de datos para ganar espacio y limpiar el archivo SavedVariables."
+	L["delete_sub"] = "Borra un perfil de la base de datos."
+	L["intro"] = "Puedes cambiar el perfil activo de tal manera que cada personaje tenga diferentes configuraciones."
+	L["new"] = "Nuevo"
+	L["new_sub"] = "Crear un nuevo perfil vacio."
+	L["profiles"] = "Perfiles"
+	L["profiles_sub"] = "Manejar Perfiles"
+	L["reset"] = "Reiniciar Perfil"
+	L["reset_desc"] = "Reinicia el perfil actual a los valores por defectos, en caso de que se haya estropeado la configuracin o quieras volver a empezar de nuevo."
+	L["reset_sub"] = "Reinicar el perfil actual al de por defecto"
+elseif LOCALE == "zhTW" then
+	L["choose"] = ""
+	L["choose_desc"] = ""
+	L["choose_sub"] = ""
+	L["copy"] = ""
+	L["copy_desc"] = ""
+	L["current"] = ""
+	L["default"] = ""
+	L["delete"] = ""
+	L["delete_confirm"] = ""
+	L["delete_desc"] = " SavedVariables "
+	L["delete_sub"] = ""
+	L["intro"] = ""
+	L["new"] = ""
+	L["new_sub"] = ""
+	L["profiles"] = ""
+	L["profiles_sub"] = ""
+	L["reset"] = ""
+	L["reset_desc"] = ""
+	L["reset_sub"] = ""
+elseif LOCALE == "zhCN" then
+	L["choose"] = ""
+	L["choose_desc"] = ""
+	L["choose_sub"] = ""
+	L["copy"] = ""
+	L["copy_desc"] = ""
+	L["current"] = ""
+	L["default"] = ""
+	L["delete"] = ""
+	L["delete_confirm"] = ""
+	L["delete_desc"] = "SavedVariables"
+	L["delete_sub"] = ""
+	L["intro"] = ""
+	L["new"] = ""
+	L["new_sub"] = ""
+	L["profiles"] = ""
+	L["profiles_sub"] = ""
+	L["reset"] = ""
+	L["reset_desc"] = ""
+	L["reset_sub"] = ""
+elseif LOCALE == "ruRU" then
+	L["choose"] = " "
+	L["choose_desc"] = "    ,     ,       ."
+	L["choose_sub"] = "     ."
+	L["copy"] = " "
+	L["copy_desc"] = "      ."
+	L["current"] = " :"
+	L["default"] = " "
+	L["delete"] = " "
+	L["delete_confirm"] = " ,     ?"
+	L["delete_desc"] = "          ,    SavedVariables."
+	L["delete_sub"] = "    ."
+	L["intro"] = "  ,        ."
+	L["new"] = ""
+	L["new_sub"] = "   ."
+	L["profiles"] = ""
+	L["profiles_sub"] = " "
+	L["reset"] = " "
+	L["reset_desc"] = "     ,          ."
+	L["reset_sub"] = "    "
+elseif LOCALE == "itIT" then
+	L["choose"] = "Profili Esistenti"
+	L["choose_desc"] = "Puoi creare un nuovo profilo digitando il nome della casella di testo, oppure scegliendone uno tra i profili gi esistenti."
+	L["choose_sub"] = "Seleziona uno dei profili attualmente disponibili."
+	L["copy"] = "Copia Da"
+	L["copy_desc"] = "Copia le impostazioni da un profilo esistente nel profilo attivo in questo momento."
+	L["current"] = "Profilo Attivo:"
+	L["default"] = "Predefinito"
+	L["delete"] = "Cancella un Profilo"
+	L["delete_confirm"] = "Sei sicuro di voler cancellare il profilo selezionato?"
+	L["delete_desc"] = "Cancella i profili non utilizzati dal database per risparmiare spazio e mantenere puliti i file di configurazione SavedVariables."
+	L["delete_sub"] = "Cancella un profilo dal Database."
+	L["intro"] = "Puoi cambiare il profilo attivo, in modo da usare impostazioni diverse per ogni personaggio."
+	L["new"] = "Nuovo"
+	L["new_sub"] = "Crea un nuovo profilo vuoto."
+	L["profiles"] = "Profili"
+	L["profiles_sub"] = "Gestisci Profili"
+	L["reset"] = "Reimposta Profilo"
+	L["reset_desc"] = "Riporta il tuo profilo attivo alle sue impostazioni predefinite, nel caso in cui la tua configurazione si sia corrotta, o semplicemente tu voglia re-inizializzarla."
+	L["reset_sub"] = "Reimposta il profilo ai suoi valori predefiniti."
+elseif LOCALE == "ptBR" then
+	L["choose"] = "Perfis Existentes"
+	L["choose_desc"] = "Voc pode tanto criar um perfil novo tanto digitando um nome na caixa de texto, quanto escolher um dos perfis j existentes."
+	L["choose_sub"] = "Selecione um de seus perfis atualmente disponveis."
+	L["copy"] = "Copiar De"
+	L["copy_desc"] = "Copia as definies de um perfil existente no perfil atualmente ativo."
+	L["current"] = "Perfil Autal:"
+	L["default"] = "Padro"
+	L["delete"] = "Remover um Perfil"
+	L["delete_confirm"] = "Tem certeza que deseja remover o perfil selecionado?"
+	L["delete_desc"] = "Remove perfis existentes e inutilizados do banco de dados para economizar espao, e limpar o arquivo SavedVariables."
+	L["delete_sub"] = "Remove um perfil do banco de dados."
+	L["intro"] = "Voc pode alterar o perfil do banco de dados ativo, para que possa ter definies diferentes para cada personagem."
+	L["new"] = "Novo"
+	L["new_sub"] = "Cria um novo perfil vazio."
+	L["profiles"] = "Perfis"
+	L["profiles_sub"] = "Gerenciar Perfis"
+	L["reset"] = "Resetar Perfil"
+	L["reset_desc"] = "Reseta o perfil atual para os valores padres, no caso de sua configurao estar quebrada, ou simplesmente se deseja comear novamente."
+	L["reset_sub"] = "Resetar o perfil atual ao padro"
+end
+
+local defaultProfiles
+local tmpprofiles = {}
+
+-- Get a list of available profiles for the specified database.
+-- You can specify which profiles to include/exclude in the list using the two boolean parameters listed below.
+-- @param db The db object to retrieve the profiles from
+-- @param common If true, getProfileList will add the default profiles to the return list, even if they have not been created yet
+-- @param nocurrent If true, then getProfileList will not display the current profile in the list
+-- @return Hashtable of all profiles with the internal name as keys and the display name as value.
+local function getProfileList(db, common, nocurrent)
+	local profiles = {}
+
+	-- copy existing profiles into the table
+	local currentProfile = db:GetCurrentProfile()
+	for i,v in pairs(db:GetProfiles(tmpprofiles)) do
+		if not (nocurrent and v == currentProfile) then
+			profiles[v] = v
+		end
+	end
+
+	-- add our default profiles to choose from ( or rename existing profiles)
+	for k,v in pairs(defaultProfiles) do
+		if (common or profiles[k]) and not (nocurrent and k == currentProfile) then
+			profiles[k] = v
+		end
+	end
+
+	return profiles
+end
+
+--[[
+	OptionsHandlerPrototype
+	prototype class for handling the options in a sane way
+]]
+local OptionsHandlerPrototype = {}
+
+--[[ Reset the profile ]]
+function OptionsHandlerPrototype:Reset()
+	self.db:ResetProfile()
+end
+
+--[[ Set the profile to value ]]
+function OptionsHandlerPrototype:SetProfile(info, value)
+	self.db:SetProfile(value)
+end
+
+--[[ returns the currently active profile ]]
+function OptionsHandlerPrototype:GetCurrentProfile()
+	return self.db:GetCurrentProfile()
+end
+
+--[[
+	List all active profiles
+	you can control the output with the .arg variable
+	currently four modes are supported
+
+	(empty) - return all available profiles
+	"nocurrent" - returns all available profiles except the currently active profile
+	"common" - returns all avaialble profiles + some commonly used profiles ("char - realm", "realm", "class", "Default")
+	"both" - common except the active profile
+]]
+function OptionsHandlerPrototype:ListProfiles(info)
+	local arg = info.arg
+	local profiles
+	if arg == "common" and not self.noDefaultProfiles then
+		profiles = getProfileList(self.db, true, nil)
+	elseif arg == "nocurrent" then
+		profiles = getProfileList(self.db, nil, true)
+	elseif arg == "both" then -- currently not used
+		profiles = getProfileList(self.db, (not self.noDefaultProfiles) and true, true)
+	else
+		profiles = getProfileList(self.db)
+	end
+
+	return profiles
+end
+
+function OptionsHandlerPrototype:HasNoProfiles(info)
+	local profiles = self:ListProfiles(info)
+	return ((not next(profiles)) and true or false)
+end
+
+--[[ Copy a profile ]]
+function OptionsHandlerPrototype:CopyProfile(info, value)
+	self.db:CopyProfile(value)
+end
+
+--[[ Delete a profile from the db ]]
+function OptionsHandlerPrototype:DeleteProfile(info, value)
+	self.db:DeleteProfile(value)
+end
+
+--[[ fill defaultProfiles with some generic values ]]
+local function generateDefaultProfiles(db)
+	defaultProfiles = {
+		["Default"] = L["default"],
+		[db.keys.char] = db.keys.char,
+		[db.keys.realm] = db.keys.realm,
+		[db.keys.class] = UnitClass("player")
+	}
+end
+
+--[[ create and return a handler object for the db, or upgrade it if it already existed ]]
+local function getOptionsHandler(db, noDefaultProfiles)
+	if not defaultProfiles then
+		generateDefaultProfiles(db)
+	end
+
+	local handler = AceDBOptions.handlers[db] or { db = db, noDefaultProfiles = noDefaultProfiles }
+
+	for k,v in pairs(OptionsHandlerPrototype) do
+		handler[k] = v
+	end
+
+	AceDBOptions.handlers[db] = handler
+	return handler
+end
+
+--[[
+	the real options table
+]]
+local optionsTable = {
+	desc = {
+		order = 1,
+		type = "description",
+		name = L["intro"] .. "\n",
+	},
+	descreset = {
+		order = 9,
+		type = "description",
+		name = L["reset_desc"],
+	},
+	reset = {
+		order = 10,
+		type = "execute",
+		name = L["reset"],
+		desc = L["reset_sub"],
+		func = "Reset",
+	},
+	current = {
+		order = 11,
+		type = "description",
+		name = function(info) return L["current"] .. " " .. NORMAL_FONT_COLOR_CODE .. info.handler:GetCurrentProfile() .. FONT_COLOR_CODE_CLOSE end,
+		width = "default",
+	},
+	choosedesc = {
+		order = 20,
+		type = "description",
+		name = "\n" .. L["choose_desc"],
+	},
+	new = {
+		name = L["new"],
+		desc = L["new_sub"],
+		type = "input",
+		order = 30,
+		get = false,
+		set = "SetProfile",
+	},
+	choose = {
+		name = L["choose"],
+		desc = L["choose_sub"],
+		type = "select",
+		order = 40,
+		get = "GetCurrentProfile",
+		set = "SetProfile",
+		values = "ListProfiles",
+		arg = "common",
+	},
+	copydesc = {
+		order = 50,
+		type = "description",
+		name = "\n" .. L["copy_desc"],
+	},
+	copyfrom = {
+		order = 60,
+		type = "select",
+		name = L["copy"],
+		desc = L["copy_desc"],
+		get = false,
+		set = "CopyProfile",
+		values = "ListProfiles",
+		disabled = "HasNoProfiles",
+		arg = "nocurrent",
+	},
+	deldesc = {
+		order = 70,
+		type = "description",
+		name = "\n" .. L["delete_desc"],
+	},
+	delete = {
+		order = 80,
+		type = "select",
+		name = L["delete"],
+		desc = L["delete_sub"],
+		get = false,
+		set = "DeleteProfile",
+		values = "ListProfiles",
+		disabled = "HasNoProfiles",
+		arg = "nocurrent",
+		confirm = true,
+		confirmText = L["delete_confirm"],
+	},
+}
+
+--- Get/Create a option table that you can use in your addon to control the profiles of AceDB-3.0.
+-- @param db The database object to create the options table for.
+-- @return The options table to be used in AceConfig-3.0
+-- @usage
+-- -- Assuming `options` is your top-level options table and `self.db` is your database:
+-- options.args.profiles = LibStub("AceDBOptions-3.0"):GetOptionsTable(self.db)
+function AceDBOptions:GetOptionsTable(db, noDefaultProfiles)
+	local tbl = AceDBOptions.optionTables[db] or {
+			type = "group",
+			name = L["profiles"],
+			desc = L["profiles_sub"],
+		}
+
+	tbl.handler = getOptionsHandler(db, noDefaultProfiles)
+	tbl.args = optionsTable
+
+	AceDBOptions.optionTables[db] = tbl
+	return tbl
+end
+
+-- upgrade existing tables
+for db,tbl in pairs(AceDBOptions.optionTables) do
+	tbl.handler = getOptionsHandler(db)
+	tbl.args = optionsTable
+end
diff --git a/Carbonite/Libs/AceDBOptions-3.0/AceDBOptions-3.0.xml b/Carbonite/Libs/AceDBOptions-3.0/AceDBOptions-3.0.xml
index 9ecffa1..51305f9 100644
--- a/Carbonite/Libs/AceDBOptions-3.0/AceDBOptions-3.0.xml
+++ b/Carbonite/Libs/AceDBOptions-3.0/AceDBOptions-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceDBOptions-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceDBOptions-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceEvent-3.0/AceEvent-3.0.lua b/Carbonite/Libs/AceEvent-3.0/AceEvent-3.0.lua
index c6aab1f..7ccd880 100644
--- a/Carbonite/Libs/AceEvent-3.0/AceEvent-3.0.lua
+++ b/Carbonite/Libs/AceEvent-3.0/AceEvent-3.0.lua
@@ -1,126 +1,126 @@
---- AceEvent-3.0 provides event registration and secure dispatching.
--- All dispatching is done using **CallbackHandler-1.0**. AceEvent is a simple wrapper around
--- CallbackHandler, and dispatches all game events or addon message to the registrees.
---
--- **AceEvent-3.0** can be embeded into your addon, either explicitly by calling AceEvent:Embed(MyAddon) or by
--- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
--- and can be accessed directly, without having to explicitly call AceEvent itself.\\
--- It is recommended to embed AceEvent, otherwise you'll have to specify a custom `self` on all calls you
--- make into AceEvent.
--- @class file
--- @name AceEvent-3.0
--- @release $Id: AceEvent-3.0.lua 1202 2019-05-15 23:11:22Z nevcairiel $
-local CallbackHandler = LibStub("CallbackHandler-1.0")
-
-local MAJOR, MINOR = "AceEvent-3.0", 4
-local AceEvent = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceEvent then return end
-
--- Lua APIs
-local pairs = pairs
-
-AceEvent.frame = AceEvent.frame or CreateFrame("Frame", "AceEvent30Frame") -- our event frame
-AceEvent.embeds = AceEvent.embeds or {} -- what objects embed this lib
-
--- APIs and registry for blizzard events, using CallbackHandler lib
-if not AceEvent.events then
-	AceEvent.events = CallbackHandler:New(AceEvent,
-		"RegisterEvent", "UnregisterEvent", "UnregisterAllEvents")
-end
-
-function AceEvent.events:OnUsed(target, eventname)
-	AceEvent.frame:RegisterEvent(eventname)
-end
-
-function AceEvent.events:OnUnused(target, eventname)
-	AceEvent.frame:UnregisterEvent(eventname)
-end
-
-
--- APIs and registry for IPC messages, using CallbackHandler lib
-if not AceEvent.messages then
-	AceEvent.messages = CallbackHandler:New(AceEvent,
-		"RegisterMessage", "UnregisterMessage", "UnregisterAllMessages"
-	)
-	AceEvent.SendMessage = AceEvent.messages.Fire
-end
-
---- embedding and embed handling
-local mixins = {
-	"RegisterEvent", "UnregisterEvent",
-	"RegisterMessage", "UnregisterMessage",
-	"SendMessage",
-	"UnregisterAllEvents", "UnregisterAllMessages",
-}
-
---- Register for a Blizzard Event.
--- The callback will be called with the optional `arg` as the first argument (if supplied), and the event name as the second (or first, if no arg was supplied)
--- Any arguments to the event will be passed on after that.
--- @name AceEvent:RegisterEvent
--- @class function
--- @paramsig event[, callback [, arg]]
--- @param event The event to register for
--- @param callback The callback function to call when the event is triggered (funcref or method, defaults to a method with the event name)
--- @param arg An optional argument to pass to the callback function
-
---- Unregister an event.
--- @name AceEvent:UnregisterEvent
--- @class function
--- @paramsig event
--- @param event The event to unregister
-
---- Register for a custom AceEvent-internal message.
--- The callback will be called with the optional `arg` as the first argument (if supplied), and the event name as the second (or first, if no arg was supplied)
--- Any arguments to the event will be passed on after that.
--- @name AceEvent:RegisterMessage
--- @class function
--- @paramsig message[, callback [, arg]]
--- @param message The message to register for
--- @param callback The callback function to call when the message is triggered (funcref or method, defaults to a method with the event name)
--- @param arg An optional argument to pass to the callback function
-
---- Unregister a message
--- @name AceEvent:UnregisterMessage
--- @class function
--- @paramsig message
--- @param message The message to unregister
-
---- Send a message over the AceEvent-3.0 internal message system to other addons registered for this message.
--- @name AceEvent:SendMessage
--- @class function
--- @paramsig message, ...
--- @param message The message to send
--- @param ... Any arguments to the message
-
-
--- Embeds AceEvent into the target object making the functions from the mixins list available on target:..
--- @param target target object to embed AceEvent in
-function AceEvent:Embed(target)
-	for k, v in pairs(mixins) do
-		target[v] = self[v]
-	end
-	self.embeds[target] = true
-	return target
-end
-
--- AceEvent:OnEmbedDisable( target )
--- target (object) - target object that is being disabled
---
--- Unregister all events messages etc when the target disables.
--- this method should be called by the target manually or by an addon framework
-function AceEvent:OnEmbedDisable(target)
-	target:UnregisterAllEvents()
-	target:UnregisterAllMessages()
-end
-
--- Script to fire blizzard events into the event listeners
-local events = AceEvent.events
-AceEvent.frame:SetScript("OnEvent", function(this, event, ...)
-	events:Fire(event, ...)
-end)
-
---- Finally: upgrade our old embeds
-for target, v in pairs(AceEvent.embeds) do
-	AceEvent:Embed(target)
-end
+--- AceEvent-3.0 provides event registration and secure dispatching.
+-- All dispatching is done using **CallbackHandler-1.0**. AceEvent is a simple wrapper around
+-- CallbackHandler, and dispatches all game events or addon message to the registrees.
+--
+-- **AceEvent-3.0** can be embeded into your addon, either explicitly by calling AceEvent:Embed(MyAddon) or by
+-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
+-- and can be accessed directly, without having to explicitly call AceEvent itself.\\
+-- It is recommended to embed AceEvent, otherwise you'll have to specify a custom `self` on all calls you
+-- make into AceEvent.
+-- @class file
+-- @name AceEvent-3.0
+-- @release $Id: AceEvent-3.0.lua 1202 2019-05-15 23:11:22Z nevcairiel $
+local CallbackHandler = LibStub("CallbackHandler-1.0")
+
+local MAJOR, MINOR = "AceEvent-3.0", 4
+local AceEvent = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceEvent then return end
+
+-- Lua APIs
+local pairs = pairs
+
+AceEvent.frame = AceEvent.frame or CreateFrame("Frame", "AceEvent30Frame") -- our event frame
+AceEvent.embeds = AceEvent.embeds or {} -- what objects embed this lib
+
+-- APIs and registry for blizzard events, using CallbackHandler lib
+if not AceEvent.events then
+	AceEvent.events = CallbackHandler:New(AceEvent,
+		"RegisterEvent", "UnregisterEvent", "UnregisterAllEvents")
+end
+
+function AceEvent.events:OnUsed(target, eventname)
+	AceEvent.frame:RegisterEvent(eventname)
+end
+
+function AceEvent.events:OnUnused(target, eventname)
+	AceEvent.frame:UnregisterEvent(eventname)
+end
+
+
+-- APIs and registry for IPC messages, using CallbackHandler lib
+if not AceEvent.messages then
+	AceEvent.messages = CallbackHandler:New(AceEvent,
+		"RegisterMessage", "UnregisterMessage", "UnregisterAllMessages"
+	)
+	AceEvent.SendMessage = AceEvent.messages.Fire
+end
+
+--- embedding and embed handling
+local mixins = {
+	"RegisterEvent", "UnregisterEvent",
+	"RegisterMessage", "UnregisterMessage",
+	"SendMessage",
+	"UnregisterAllEvents", "UnregisterAllMessages",
+}
+
+--- Register for a Blizzard Event.
+-- The callback will be called with the optional `arg` as the first argument (if supplied), and the event name as the second (or first, if no arg was supplied)
+-- Any arguments to the event will be passed on after that.
+-- @name AceEvent:RegisterEvent
+-- @class function
+-- @paramsig event[, callback [, arg]]
+-- @param event The event to register for
+-- @param callback The callback function to call when the event is triggered (funcref or method, defaults to a method with the event name)
+-- @param arg An optional argument to pass to the callback function
+
+--- Unregister an event.
+-- @name AceEvent:UnregisterEvent
+-- @class function
+-- @paramsig event
+-- @param event The event to unregister
+
+--- Register for a custom AceEvent-internal message.
+-- The callback will be called with the optional `arg` as the first argument (if supplied), and the event name as the second (or first, if no arg was supplied)
+-- Any arguments to the event will be passed on after that.
+-- @name AceEvent:RegisterMessage
+-- @class function
+-- @paramsig message[, callback [, arg]]
+-- @param message The message to register for
+-- @param callback The callback function to call when the message is triggered (funcref or method, defaults to a method with the event name)
+-- @param arg An optional argument to pass to the callback function
+
+--- Unregister a message
+-- @name AceEvent:UnregisterMessage
+-- @class function
+-- @paramsig message
+-- @param message The message to unregister
+
+--- Send a message over the AceEvent-3.0 internal message system to other addons registered for this message.
+-- @name AceEvent:SendMessage
+-- @class function
+-- @paramsig message, ...
+-- @param message The message to send
+-- @param ... Any arguments to the message
+
+
+-- Embeds AceEvent into the target object making the functions from the mixins list available on target:..
+-- @param target target object to embed AceEvent in
+function AceEvent:Embed(target)
+	for k, v in pairs(mixins) do
+		target[v] = self[v]
+	end
+	self.embeds[target] = true
+	return target
+end
+
+-- AceEvent:OnEmbedDisable( target )
+-- target (object) - target object that is being disabled
+--
+-- Unregister all events messages etc when the target disables.
+-- this method should be called by the target manually or by an addon framework
+function AceEvent:OnEmbedDisable(target)
+	target:UnregisterAllEvents()
+	target:UnregisterAllMessages()
+end
+
+-- Script to fire blizzard events into the event listeners
+local events = AceEvent.events
+AceEvent.frame:SetScript("OnEvent", function(this, event, ...)
+	events:Fire(event, ...)
+end)
+
+--- Finally: upgrade our old embeds
+for target, v in pairs(AceEvent.embeds) do
+	AceEvent:Embed(target)
+end
diff --git a/Carbonite/Libs/AceEvent-3.0/AceEvent-3.0.xml b/Carbonite/Libs/AceEvent-3.0/AceEvent-3.0.xml
index dc3cc5d..41ef791 100644
--- a/Carbonite/Libs/AceEvent-3.0/AceEvent-3.0.xml
+++ b/Carbonite/Libs/AceEvent-3.0/AceEvent-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceEvent-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceEvent-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceGUI-3.0/AceGUI-3.0.lua b/Carbonite/Libs/AceGUI-3.0/AceGUI-3.0.lua
index 7d9a2cf..f05b1ed 100644
--- a/Carbonite/Libs/AceGUI-3.0/AceGUI-3.0.lua
+++ b/Carbonite/Libs/AceGUI-3.0/AceGUI-3.0.lua
@@ -1,1020 +1,1020 @@
---- **AceGUI-3.0** provides access to numerous widgets which can be used to create GUIs.
--- AceGUI is used by AceConfigDialog to create the option GUIs, but you can use it by itself
--- to create any custom GUI. There are more extensive examples in the test suite in the Ace3
--- stand-alone distribution.
---
--- **Note**: When using AceGUI-3.0 directly, please do not modify the frames of the widgets directly,
--- as any "unknown" change to the widgets will cause addons that get your widget out of the widget pool
--- to misbehave. If you think some part of a widget should be modifiable, please open a ticket, and we"ll
--- implement a proper API to modify it.
--- @usage
--- local AceGUI = LibStub("AceGUI-3.0")
--- -- Create a container frame
--- local f = AceGUI:Create("Frame")
--- f:SetCallback("OnClose",function(widget) AceGUI:Release(widget) end)
--- f:SetTitle("AceGUI-3.0 Example")
--- f:SetStatusText("Status Bar")
--- f:SetLayout("Flow")
--- -- Create a button
--- local btn = AceGUI:Create("Button")
--- btn:SetWidth(170)
--- btn:SetText("Button !")
--- btn:SetCallback("OnClick", function() print("Click!") end)
--- -- Add the button to the container
--- f:AddChild(btn)
--- @class file
--- @name AceGUI-3.0
--- @release $Id: AceGUI-3.0.lua 1288 2022-09-25 14:19:00Z funkehdude $
-local ACEGUI_MAJOR, ACEGUI_MINOR = "AceGUI-3.0", 41
-local AceGUI, oldminor = LibStub:NewLibrary(ACEGUI_MAJOR, ACEGUI_MINOR)
-
-if not AceGUI then return end -- No upgrade needed
-
--- Lua APIs
-local tinsert, wipe = table.insert, table.wipe
-local select, pairs, next, type = select, pairs, next, type
-local error, assert = error, assert
-local setmetatable, rawget = setmetatable, rawget
-local math_max, math_min, math_ceil = math.max, math.min, math.ceil
-
--- WoW APIs
-local UIParent = UIParent
-
-AceGUI.WidgetRegistry = AceGUI.WidgetRegistry or {}
-AceGUI.LayoutRegistry = AceGUI.LayoutRegistry or {}
-AceGUI.WidgetBase = AceGUI.WidgetBase or {}
-AceGUI.WidgetContainerBase = AceGUI.WidgetContainerBase or {}
-AceGUI.WidgetVersions = AceGUI.WidgetVersions or {}
-AceGUI.tooltip = AceGUI.tooltip or CreateFrame("GameTooltip", "AceGUITooltip", UIParent, "GameTooltipTemplate")
-
--- local upvalues
-local WidgetRegistry = AceGUI.WidgetRegistry
-local LayoutRegistry = AceGUI.LayoutRegistry
-local WidgetVersions = AceGUI.WidgetVersions
-
---[[
-	 xpcall safecall implementation
-]]
-local xpcall = xpcall
-
-local function errorhandler(err)
-	return geterrorhandler()(err)
-end
-
-local function safecall(func, ...)
-	if func then
-		return xpcall(func, errorhandler, ...)
-	end
-end
-
--- Recycling functions
-local newWidget, delWidget
-do
-	-- Version Upgrade in Minor 29
-	-- Internal Storage of the objects changed, from an array table
-	-- to a hash table, and additionally we introduced versioning on
-	-- the widgets which would discard all widgets from a pre-29 version
-	-- anyway, so we just clear the storage now, and don't try to
-	-- convert the storage tables to the new format.
-	-- This should generally not cause *many* widgets to end up in trash,
-	-- since once dialogs are opened, all addons should be loaded already
-	-- and AceGUI should be on the latest version available on the users
-	-- setup.
-	-- -- nevcairiel - Nov 2nd, 2009
-	if oldminor and oldminor < 29 and AceGUI.objPools then
-		AceGUI.objPools = nil
-	end
-
-	AceGUI.objPools = AceGUI.objPools or {}
-	local objPools = AceGUI.objPools
-	--Returns a new instance, if none are available either returns a new table or calls the given contructor
-	function newWidget(widgetType)
-		if not WidgetRegistry[widgetType] then
-			error("Attempt to instantiate unknown widget type", 2)
-		end
-
-		if not objPools[widgetType] then
-			objPools[widgetType] = {}
-		end
-
-		local newObj = next(objPools[widgetType])
-		if not newObj then
-			newObj = WidgetRegistry[widgetType]()
-			newObj.AceGUIWidgetVersion = WidgetVersions[widgetType]
-		else
-			objPools[widgetType][newObj] = nil
-			-- if the widget is older then the latest, don't even try to reuse it
-			-- just forget about it, and grab a new one.
-			if not newObj.AceGUIWidgetVersion or newObj.AceGUIWidgetVersion < WidgetVersions[widgetType] then
-				return newWidget(widgetType)
-			end
-		end
-		return newObj
-	end
-	-- Releases an instance to the Pool
-	function delWidget(obj,widgetType)
-		if not objPools[widgetType] then
-			objPools[widgetType] = {}
-		end
-		if objPools[widgetType][obj] then
-			error("Attempt to Release Widget that is already released", 2)
-		end
-		objPools[widgetType][obj] = true
-	end
-end
-
-
--------------------
--- API Functions --
--------------------
-
--- Gets a widget Object
-
---- Create a new Widget of the given type.
--- This function will instantiate a new widget (or use one from the widget pool), and call the
--- OnAcquire function on it, before returning.
--- @param type The type of the widget.
--- @return The newly created widget.
-function AceGUI:Create(widgetType)
-	if WidgetRegistry[widgetType] then
-		local widget = newWidget(widgetType)
-
-		if rawget(widget, "Acquire") then
-			widget.OnAcquire = widget.Acquire
-			widget.Acquire = nil
-		elseif rawget(widget, "Aquire") then
-			widget.OnAcquire = widget.Aquire
-			widget.Aquire = nil
-		end
-
-		if rawget(widget, "Release") then
-			widget.OnRelease = rawget(widget, "Release")
-			widget.Release = nil
-		end
-
-		if widget.OnAcquire then
-			widget:OnAcquire()
-		else
-			error(("Widget type %s doesn't supply an OnAcquire Function"):format(widgetType))
-		end
-		-- Set the default Layout ("List")
-		safecall(widget.SetLayout, widget, "List")
-		safecall(widget.ResumeLayout, widget)
-		return widget
-	end
-end
-
---- Releases a widget Object.
--- This function calls OnRelease on the widget and places it back in the widget pool.
--- Any data on the widget is being erased, and the widget will be hidden.\\
--- If this widget is a Container-Widget, all of its Child-Widgets will be releases as well.
--- @param widget The widget to release
-function AceGUI:Release(widget)
-	if widget.isQueuedForRelease then return end
-	widget.isQueuedForRelease = true
-	safecall(widget.PauseLayout, widget)
-	widget.frame:Hide()
-	widget:Fire("OnRelease")
-	safecall(widget.ReleaseChildren, widget)
-
-	if widget.OnRelease then
-		widget:OnRelease()
---	else
---		error(("Widget type %s doesn't supply an OnRelease Function"):format(widget.type))
-	end
-	for k in pairs(widget.userdata) do
-		widget.userdata[k] = nil
-	end
-	for k in pairs(widget.events) do
-		widget.events[k] = nil
-	end
-	widget.width = nil
-	widget.relWidth = nil
-	widget.height = nil
-	widget.relHeight = nil
-	widget.noAutoHeight = nil
-	widget.frame:ClearAllPoints()
-	widget.frame:Hide()
-	widget.frame:SetParent(UIParent)
-	widget.frame.width = nil
-	widget.frame.height = nil
-	if widget.content then
-		widget.content.width = nil
-		widget.content.height = nil
-	end
-	widget.isQueuedForRelease = nil
-	delWidget(widget, widget.type)
-end
-
---- Check if a widget is currently in the process of being released
--- This function check if this widget, or any of its parents (in which case it'll be released shortly as well)
--- are currently being released. This allows addon to handle any callbacks accordingly.
--- @param widget The widget to check
-function AceGUI:IsReleasing(widget)
-	if widget.isQueuedForRelease then
-		return true
-	end
-
-	if widget.parent and widget.parent.AceGUIWidgetVersion then
-		return AceGUI:IsReleasing(widget.parent)
-	end
-
-	return false
-end
-
------------
--- Focus --
------------
-
-
---- Called when a widget has taken focus.
--- e.g. Dropdowns opening, Editboxes gaining kb focus
--- @param widget The widget that should be focused
-function AceGUI:SetFocus(widget)
-	if self.FocusedWidget and self.FocusedWidget ~= widget then
-		safecall(self.FocusedWidget.ClearFocus, self.FocusedWidget)
-	end
-	self.FocusedWidget = widget
-end
-
-
---- Called when something has happened that could cause widgets with focus to drop it
--- e.g. titlebar of a frame being clicked
-function AceGUI:ClearFocus()
-	if self.FocusedWidget then
-		safecall(self.FocusedWidget.ClearFocus, self.FocusedWidget)
-		self.FocusedWidget = nil
-	end
-end
-
--------------
--- Widgets --
--------------
---[[
-	Widgets must provide the following functions
-		OnAcquire() - Called when the object is acquired, should set everything to a default hidden state
-
-	And the following members
-		frame - the frame or derivitive object that will be treated as the widget for size and anchoring purposes
-		type - the type of the object, same as the name given to :RegisterWidget()
-
-	Widgets contain a table called userdata, this is a safe place to store data associated with the wigdet
-	It will be cleared automatically when a widget is released
-	Placing values directly into a widget object should be avoided
-
-	If the Widget can act as a container for other Widgets the following
-		content - frame or derivitive that children will be anchored to
-
-	The Widget can supply the following Optional Members
-		:OnRelease() - Called when the object is Released, should remove any additional anchors and clear any data
-		:OnWidthSet(width) - Called when the width of the widget is changed
-		:OnHeightSet(height) - Called when the height of the widget is changed
-			Widgets should not use the OnSizeChanged events of thier frame or content members, use these methods instead
-			AceGUI already sets a handler to the event
-		:LayoutFinished(width, height) - called after a layout has finished, the width and height will be the width and height of the
-			area used for controls. These can be nil if the layout used the existing size to layout the controls.
-
-]]
-
---------------------------
--- Widget Base Template --
---------------------------
-do
-	local WidgetBase = AceGUI.WidgetBase
-
-	WidgetBase.SetParent = function(self, parent)
-		local frame = self.frame
-		frame:SetParent(nil)
-		frame:SetParent(parent.content)
-		self.parent = parent
-	end
-
-	WidgetBase.SetCallback = function(self, name, func)
-		if type(func) == "function" then
-			self.events[name] = func
-		end
-	end
-
-	WidgetBase.Fire = function(self, name, ...)
-		if self.events[name] then
-			local success, ret = safecall(self.events[name], self, name, ...)
-			if success then
-				return ret
-			end
-		end
-	end
-
-	WidgetBase.SetWidth = function(self, width)
-		self.frame:SetWidth(width)
-		self.frame.width = width
-		if self.OnWidthSet then
-			self:OnWidthSet(width)
-		end
-	end
-
-	WidgetBase.SetRelativeWidth = function(self, width)
-		if width <= 0 or width > 1 then
-			error(":SetRelativeWidth(width): Invalid relative width.", 2)
-		end
-		self.relWidth = width
-		self.width = "relative"
-	end
-
-	WidgetBase.SetHeight = function(self, height)
-		self.frame:SetHeight(height)
-		self.frame.height = height
-		if self.OnHeightSet then
-			self:OnHeightSet(height)
-		end
-	end
-
-	--[[ WidgetBase.SetRelativeHeight = function(self, height)
-		if height <= 0 or height > 1 then
-			error(":SetRelativeHeight(height): Invalid relative height.", 2)
-		end
-		self.relHeight = height
-		self.height = "relative"
-	end ]]
-
-	WidgetBase.IsVisible = function(self)
-		return self.frame:IsVisible()
-	end
-
-	WidgetBase.IsShown= function(self)
-		return self.frame:IsShown()
-	end
-
-	WidgetBase.Release = function(self)
-		AceGUI:Release(self)
-	end
-
-	WidgetBase.IsReleasing = function(self)
-		return AceGUI:IsReleasing(self)
-	end
-
-	WidgetBase.SetPoint = function(self, ...)
-		return self.frame:SetPoint(...)
-	end
-
-	WidgetBase.ClearAllPoints = function(self)
-		return self.frame:ClearAllPoints()
-	end
-
-	WidgetBase.GetNumPoints = function(self)
-		return self.frame:GetNumPoints()
-	end
-
-	WidgetBase.GetPoint = function(self, ...)
-		return self.frame:GetPoint(...)
-	end
-
-	WidgetBase.GetUserDataTable = function(self)
-		return self.userdata
-	end
-
-	WidgetBase.SetUserData = function(self, key, value)
-		self.userdata[key] = value
-	end
-
-	WidgetBase.GetUserData = function(self, key)
-		return self.userdata[key]
-	end
-
-	WidgetBase.IsFullHeight = function(self)
-		return self.height == "fill"
-	end
-
-	WidgetBase.SetFullHeight = function(self, isFull)
-		if isFull then
-			self.height = "fill"
-		else
-			self.height = nil
-		end
-	end
-
-	WidgetBase.IsFullWidth = function(self)
-		return self.width == "fill"
-	end
-
-	WidgetBase.SetFullWidth = function(self, isFull)
-		if isFull then
-			self.width = "fill"
-		else
-			self.width = nil
-		end
-	end
-
---	local function LayoutOnUpdate(this)
---		this:SetScript("OnUpdate",nil)
---		this.obj:PerformLayout()
---	end
-
-	local WidgetContainerBase = AceGUI.WidgetContainerBase
-
-	WidgetContainerBase.PauseLayout = function(self)
-		self.LayoutPaused = true
-	end
-
-	WidgetContainerBase.ResumeLayout = function(self)
-		self.LayoutPaused = nil
-	end
-
-	WidgetContainerBase.PerformLayout = function(self)
-		if self.LayoutPaused then
-			return
-		end
-		safecall(self.LayoutFunc, self.content, self.children)
-	end
-
-	--call this function to layout, makes sure layed out objects get a frame to get sizes etc
-	WidgetContainerBase.DoLayout = function(self)
-		self:PerformLayout()
---		if not self.parent then
---			self.frame:SetScript("OnUpdate", LayoutOnUpdate)
---		end
-	end
-
-	WidgetContainerBase.AddChild = function(self, child, beforeWidget)
-		if beforeWidget then
-			local siblingIndex = 1
-			for _, widget in pairs(self.children) do
-				if widget == beforeWidget then
-					break
-				end
-				siblingIndex = siblingIndex + 1
-			end
-			tinsert(self.children, siblingIndex, child)
-		else
-			tinsert(self.children, child)
-		end
-		child:SetParent(self)
-		child.frame:Show()
-		self:DoLayout()
-	end
-
-	WidgetContainerBase.AddChildren = function(self, ...)
-		for i = 1, select("#", ...) do
-			local child = select(i, ...)
-			tinsert(self.children, child)
-			child:SetParent(self)
-			child.frame:Show()
-		end
-		self:DoLayout()
-	end
-
-	WidgetContainerBase.ReleaseChildren = function(self)
-		local children = self.children
-		for i = 1,#children do
-			AceGUI:Release(children[i])
-			children[i] = nil
-		end
-	end
-
-	WidgetContainerBase.SetLayout = function(self, Layout)
-		self.LayoutFunc = AceGUI:GetLayout(Layout)
-	end
-
-	WidgetContainerBase.SetAutoAdjustHeight = function(self, adjust)
-		if adjust then
-			self.noAutoHeight = nil
-		else
-			self.noAutoHeight = true
-		end
-	end
-
-	local function FrameResize(this)
-		local self = this.obj
-		if this:GetWidth() and this:GetHeight() then
-			if self.OnWidthSet then
-				self:OnWidthSet(this:GetWidth())
-			end
-			if self.OnHeightSet then
-				self:OnHeightSet(this:GetHeight())
-			end
-		end
-	end
-
-	local function ContentResize(this)
-		if this:GetWidth() and this:GetHeight() then
-			this.width = this:GetWidth()
-			this.height = this:GetHeight()
-			this.obj:DoLayout()
-		end
-	end
-
-	setmetatable(WidgetContainerBase, {__index=WidgetBase})
-
-	--One of these function should be called on each Widget Instance as part of its creation process
-
-	--- Register a widget-class as a container for newly created widgets.
-	-- @param widget The widget class
-	function AceGUI:RegisterAsContainer(widget)
-		widget.children = {}
-		widget.userdata = {}
-		widget.events = {}
-		widget.base = WidgetContainerBase
-		widget.content.obj = widget
-		widget.frame.obj = widget
-		widget.content:SetScript("OnSizeChanged", ContentResize)
-		widget.frame:SetScript("OnSizeChanged", FrameResize)
-		setmetatable(widget, {__index = WidgetContainerBase})
-		widget:SetLayout("List")
-		return widget
-	end
-
-	--- Register a widget-class as a widget.
-	-- @param widget The widget class
-	function AceGUI:RegisterAsWidget(widget)
-		widget.userdata = {}
-		widget.events = {}
-		widget.base = WidgetBase
-		widget.frame.obj = widget
-		widget.frame:SetScript("OnSizeChanged", FrameResize)
-		setmetatable(widget, {__index = WidgetBase})
-		return widget
-	end
-end
-
-
-
-
-------------------
--- Widget API   --
-------------------
-
---- Registers a widget Constructor, this function returns a new instance of the Widget
--- @param Name The name of the widget
--- @param Constructor The widget constructor function
--- @param Version The version of the widget
-function AceGUI:RegisterWidgetType(Name, Constructor, Version)
-	assert(type(Constructor) == "function")
-	assert(type(Version) == "number")
-
-	local oldVersion = WidgetVersions[Name]
-	if oldVersion and oldVersion >= Version then return end
-
-	WidgetVersions[Name] = Version
-	WidgetRegistry[Name] = Constructor
-end
-
---- Registers a Layout Function
--- @param Name The name of the layout
--- @param LayoutFunc Reference to the layout function
-function AceGUI:RegisterLayout(Name, LayoutFunc)
-	assert(type(LayoutFunc) == "function")
-	if type(Name) == "string" then
-		Name = Name:upper()
-	end
-	LayoutRegistry[Name] = LayoutFunc
-end
-
---- Get a Layout Function from the registry
--- @param Name The name of the layout
-function AceGUI:GetLayout(Name)
-	if type(Name) == "string" then
-		Name = Name:upper()
-	end
-	return LayoutRegistry[Name]
-end
-
-AceGUI.counts = AceGUI.counts or {}
-
---- A type-based counter to count the number of widgets created.
--- This is used by widgets that require a named frame, e.g. when a Blizzard
--- Template requires it.
--- @param type The widget type
-function AceGUI:GetNextWidgetNum(widgetType)
-	if not self.counts[widgetType] then
-		self.counts[widgetType] = 0
-	end
-	self.counts[widgetType] = self.counts[widgetType] + 1
-	return self.counts[widgetType]
-end
-
---- Return the number of created widgets for this type.
--- In contrast to GetNextWidgetNum, the number is not incremented.
--- @param widgetType The widget type
-function AceGUI:GetWidgetCount(widgetType)
-	return self.counts[widgetType] or 0
-end
-
---- Return the version of the currently registered widget type.
--- @param widgetType The widget type
-function AceGUI:GetWidgetVersion(widgetType)
-	return WidgetVersions[widgetType]
-end
-
--------------
--- Layouts --
--------------
-
---[[
-	A Layout is a func that takes 2 parameters
-		content - the frame that widgets will be placed inside
-		children - a table containing the widgets to layout
-]]
-
--- Very simple Layout, Children are stacked on top of each other down the left side
-AceGUI:RegisterLayout("List",
-	function(content, children)
-		local height = 0
-		local width = content.width or content:GetWidth() or 0
-		for i = 1, #children do
-			local child = children[i]
-
-			local frame = child.frame
-			frame:ClearAllPoints()
-			frame:Show()
-			if i == 1 then
-				frame:SetPoint("TOPLEFT", content)
-			else
-				frame:SetPoint("TOPLEFT", children[i-1].frame, "BOTTOMLEFT")
-			end
-
-			if child.width == "fill" then
-				child:SetWidth(width)
-				frame:SetPoint("RIGHT", content)
-
-				if child.DoLayout then
-					child:DoLayout()
-				end
-			elseif child.width == "relative" then
-				child:SetWidth(width * child.relWidth)
-
-				if child.DoLayout then
-					child:DoLayout()
-				end
-			end
-
-			height = height + (frame.height or frame:GetHeight() or 0)
-		end
-		safecall(content.obj.LayoutFinished, content.obj, nil, height)
-	end)
-
--- A single control fills the whole content area
-AceGUI:RegisterLayout("Fill",
-	function(content, children)
-		if children[1] then
-			children[1]:SetWidth(content:GetWidth() or 0)
-			children[1]:SetHeight(content:GetHeight() or 0)
-			children[1].frame:ClearAllPoints()
-			children[1].frame:SetAllPoints(content)
-			children[1].frame:Show()
-			safecall(content.obj.LayoutFinished, content.obj, nil, children[1].frame:GetHeight())
-		end
-	end)
-
-local layoutrecursionblock = nil
-local function safelayoutcall(object, func, ...)
-	layoutrecursionblock = true
-	object[func](object, ...)
-	layoutrecursionblock = nil
-end
-
-AceGUI:RegisterLayout("Flow",
-	function(content, children)
-		if layoutrecursionblock then return end
-		--used height so far
-		local height = 0
-		--width used in the current row
-		local usedwidth = 0
-		--height of the current row
-		local rowheight = 0
-		local rowoffset = 0
-
-		local width = content.width or content:GetWidth() or 0
-
-		--control at the start of the row
-		local rowstart
-		local rowstartoffset
-		local isfullheight
-
-		local frameoffset
-		local lastframeoffset
-		local oversize
-		for i = 1, #children do
-			local child = children[i]
-			oversize = nil
-			local frame = child.frame
-			local frameheight = frame.height or frame:GetHeight() or 0
-			local framewidth = frame.width or frame:GetWidth() or 0
-			lastframeoffset = frameoffset
-			-- HACK: Why did we set a frameoffset of (frameheight / 2) ?
-			-- That was moving all widgets half the widgets size down, is that intended?
-			-- Actually, it seems to be neccessary for many cases, we'll leave it in for now.
-			-- If widgets seem to anchor weirdly with this, provide a valid alignoffset for them.
-			-- TODO: Investigate moar!
-			frameoffset = child.alignoffset or (frameheight / 2)
-
-			if child.width == "relative" then
-				framewidth = width * child.relWidth
-			end
-
-			frame:Show()
-			frame:ClearAllPoints()
-			if i == 1 then
-				-- anchor the first control to the top left
-				frame:SetPoint("TOPLEFT", content)
-				rowheight = frameheight
-				rowoffset = frameoffset
-				rowstart = frame
-				rowstartoffset = frameoffset
-				usedwidth = framewidth
-				if usedwidth > width then
-					oversize = true
-				end
-			else
-				-- if there isn't available width for the control start a new row
-				-- if a control is "fill" it will be on a row of its own full width
-				if usedwidth == 0 or ((framewidth) + usedwidth > width) or child.width == "fill" then
-					if isfullheight then
-						-- a previous row has already filled the entire height, there's nothing we can usefully do anymore
-						-- (maybe error/warn about this?)
-						break
-					end
-					--anchor the previous row, we will now know its height and offset
-					rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -(height + (rowoffset - rowstartoffset) + 3))
-					height = height + rowheight + 3
-					--save this as the rowstart so we can anchor it after the row is complete and we have the max height and offset of controls in it
-					rowstart = frame
-					rowstartoffset = frameoffset
-					rowheight = frameheight
-					rowoffset = frameoffset
-					usedwidth = framewidth
-					if usedwidth > width then
-						oversize = true
-					end
-				-- put the control on the current row, adding it to the width and checking if the height needs to be increased
-				else
-					--handles cases where the new height is higher than either control because of the offsets
-					--math.max(rowheight-rowoffset+frameoffset, frameheight-frameoffset+rowoffset)
-
-					--offset is always the larger of the two offsets
-					rowoffset = math_max(rowoffset, frameoffset)
-					rowheight = math_max(rowheight, rowoffset + (frameheight / 2))
-
-					frame:SetPoint("TOPLEFT", children[i-1].frame, "TOPRIGHT", 0, frameoffset - lastframeoffset)
-					usedwidth = framewidth + usedwidth
-				end
-			end
-
-			if child.width == "fill" then
-				safelayoutcall(child, "SetWidth", width)
-				frame:SetPoint("RIGHT", content)
-
-				usedwidth = 0
-				rowstart = frame
-
-				if child.DoLayout then
-					child:DoLayout()
-				end
-				rowheight = frame.height or frame:GetHeight() or 0
-				rowoffset = child.alignoffset or (rowheight / 2)
-				rowstartoffset = rowoffset
-			elseif child.width == "relative" then
-				safelayoutcall(child, "SetWidth", width * child.relWidth)
-
-				if child.DoLayout then
-					child:DoLayout()
-				end
-			elseif oversize then
-				if width > 1 then
-					frame:SetPoint("RIGHT", content)
-				end
-			end
-
-			if child.height == "fill" then
-				frame:SetPoint("BOTTOM", content)
-				isfullheight = true
-			end
-		end
-
-		--anchor the last row, if its full height needs a special case since  its height has just been changed by the anchor
-		if isfullheight then
-			rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -height)
-		elseif rowstart then
-			rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -(height + (rowoffset - rowstartoffset) + 3))
-		end
-
-		height = height + rowheight + 3
-		safecall(content.obj.LayoutFinished, content.obj, nil, height)
-	end)
-
--- Get alignment method and value. Possible alignment methods are a callback, a number, "start", "middle", "end", "fill" or "TOPLEFT", "BOTTOMRIGHT" etc.
-local GetCellAlign = function (dir, tableObj, colObj, cellObj, cell, child)
-	local fn = cellObj and (cellObj["align" .. dir] or cellObj.align)
-			or colObj and (colObj["align" .. dir] or colObj.align)
-			or tableObj["align" .. dir] or tableObj.align
-			or "CENTERLEFT"
-	local val
-	child, cell = child or 0, cell or 0
-
-	if type(fn) == "string" then
-		fn = fn:lower()
-		fn = dir == "V" and (fn:sub(1, 3) == "top" and "start" or fn:sub(1, 6) == "bottom" and "end" or fn:sub(1, 6) == "center" and "middle")
-		  or dir == "H" and (fn:sub(-4) == "left" and "start" or fn:sub(-5) == "right" and "end" or fn:sub(-6) == "center" and "middle")
-		  or fn
-		val = (fn == "start" or fn == "fill") and 0 or fn == "end" and cell - child or (cell - child) / 2
-	elseif type(fn) == "function" then
-		val = fn(child or 0, cell, dir)
-	else
-		val = fn
-	end
-
-	return fn, math_max(0, math_min(val, cell))
-end
-
--- Get width or height for multiple cells combined
-local GetCellDimension = function (dir, laneDim, from, to, space)
-	local dim = 0
-	for cell=from,to do
-		dim = dim + (laneDim[cell] or 0)
-	end
-	return dim + math_max(0, to - from) * (space or 0)
-end
-
---[[ Options
-============
-Container:
- - columns ({col, col, ...}): Column settings. "col" can be a number (<= 0: content width, <1: rel. width, <10: weight, >=10: abs. width) or a table with column setting.
- - space, spaceH, spaceV: Overall, horizontal and vertical spacing between cells.
- - align, alignH, alignV: Overall, horizontal and vertical cell alignment. See GetCellAlign() for possible values.
-Columns:
- - width: Fixed column width (nil or <=0: content width, <1: rel. width, >=1: abs. width).
- - min or 1: Min width for content based width
- - max or 2: Max width for content based width
- - weight: Flexible column width. The leftover width after accounting for fixed-width columns is distributed to weighted columns according to their weights.
- - align, alignH, alignV: Overwrites the container setting for alignment.
-Cell:
- - colspan: Makes a cell span multiple columns.
- - rowspan: Makes a cell span multiple rows.
- - align, alignH, alignV: Overwrites the container and column setting for alignment.
-]]
-AceGUI:RegisterLayout("Table",
-	function (content, children)
-		local obj = content.obj
-		obj:PauseLayout()
-
-		local tableObj = obj:GetUserData("table")
-		local cols = tableObj.columns
-		local spaceH = tableObj.spaceH or tableObj.space or 0
-		local spaceV = tableObj.spaceV or tableObj.space or 0
-		local totalH = (content:GetWidth() or content.width or 0) - spaceH * (#cols - 1)
-
-		-- We need to reuse these because layout events can come in very frequently
-		local layoutCache = obj:GetUserData("layoutCache")
-		if not layoutCache then
-			layoutCache = {{}, {}, {}, {}, {}, {}}
-			obj:SetUserData("layoutCache", layoutCache)
-		end
-		local t, laneH, laneV, rowspans, rowStart, colStart = unpack(layoutCache)
-
-		-- Create the grid
-		local n, slotFound = 0
-		for i,child in ipairs(children) do
-			if child:IsShown() then
-				repeat
-					n = n + 1
-					local col = (n - 1) % #cols + 1
-					local row = math_ceil(n / #cols)
-					local rowspan = rowspans[col]
-					local cell = rowspan and rowspan.child or child
-					local cellObj = cell:GetUserData("cell")
-					slotFound = not rowspan
-
-					-- Rowspan
-					if not rowspan and cellObj and cellObj.rowspan then
-						rowspan = {child = child, from = row, to = row + cellObj.rowspan - 1}
-						rowspans[col] = rowspan
-					end
-					if rowspan and i == #children then
-						rowspan.to = row
-					end
-
-					-- Colspan
-					local colspan = math_max(0, math_min((cellObj and cellObj.colspan or 1) - 1, #cols - col))
-					n = n + colspan
-
-					-- Place the cell
-					if not rowspan or rowspan.to == row then
-						t[n] = cell
-						rowStart[cell] = rowspan and rowspan.from or row
-						colStart[cell] = col
-
-						if rowspan then
-							rowspans[col] = nil
-						end
-					end
-				until slotFound
-			end
-		end
-
-		local rows = math_ceil(n / #cols)
-
-		-- Determine fixed size cols and collect weights
-		local extantH, totalWeight = totalH, 0
-		for col,colObj in ipairs(cols) do
-			laneH[col] = 0
-
-			if type(colObj) == "number" then
-				colObj = {[colObj >= 1 and colObj < 10 and "weight" or "width"] = colObj}
-				cols[col] = colObj
-			end
-
-			if colObj.weight then
-				-- Weight
-				totalWeight = totalWeight + (colObj.weight or 1)
-			else
-				if not colObj.width or colObj.width <= 0 then
-					-- Content width
-					for row=1,rows do
-						local child = t[(row - 1) * #cols + col]
-						if child then
-							local f = child.frame
-							f:ClearAllPoints()
-							local childH = f:GetWidth() or 0
-
-							laneH[col] = math_max(laneH[col], childH - GetCellDimension("H", laneH, colStart[child], col - 1, spaceH))
-						end
-					end
-
-					laneH[col] = math_max(colObj.min or colObj[1] or 0, math_min(laneH[col], colObj.max or colObj[2] or laneH[col]))
-				else
-					-- Rel./Abs. width
-					laneH[col] = colObj.width < 1 and colObj.width * totalH or colObj.width
-				end
-				extantH = math_max(0, extantH - laneH[col])
-			end
-		end
-
-		-- Determine sizes based on weight
-		local scale = totalWeight > 0 and extantH / totalWeight or 0
-		for col,colObj in pairs(cols) do
-			if colObj.weight then
-				laneH[col] = scale * colObj.weight
-			end
-		end
-
-		-- Arrange children
-		for row=1,rows do
-			local rowV = 0
-
-			-- Horizontal placement and sizing
-			for col=1,#cols do
-				local child = t[(row - 1) * #cols + col]
-				if child then
-					local colObj = cols[colStart[child]]
-					local cellObj = child:GetUserData("cell")
-					local offsetH = GetCellDimension("H", laneH, 1, colStart[child] - 1, spaceH) + (colStart[child] == 1 and 0 or spaceH)
-					local cellH = GetCellDimension("H", laneH, colStart[child], col, spaceH)
-
-					local f = child.frame
-					f:ClearAllPoints()
-					local childH = f:GetWidth() or 0
-
-					local alignFn, align = GetCellAlign("H", tableObj, colObj, cellObj, cellH, childH)
-					f:SetPoint("LEFT", content, offsetH + align, 0)
-					if child:IsFullWidth() or alignFn == "fill" or childH > cellH then
-						f:SetPoint("RIGHT", content, "LEFT", offsetH + align + cellH, 0)
-					end
-
-					if child.DoLayout then
-						child:DoLayout()
-					end
-
-					rowV = math_max(rowV, (f:GetHeight() or 0) - GetCellDimension("V", laneV, rowStart[child], row - 1, spaceV))
-				end
-			end
-
-			laneV[row] = rowV
-
-			-- Vertical placement and sizing
-			for col=1,#cols do
-				local child = t[(row - 1) * #cols + col]
-				if child then
-					local colObj = cols[colStart[child]]
-					local cellObj = child:GetUserData("cell")
-					local offsetV = GetCellDimension("V", laneV, 1, rowStart[child] - 1, spaceV) + (rowStart[child] == 1 and 0 or spaceV)
-					local cellV = GetCellDimension("V", laneV, rowStart[child], row, spaceV)
-
-					local f = child.frame
-					local childV = f:GetHeight() or 0
-
-					local alignFn, align = GetCellAlign("V", tableObj, colObj, cellObj, cellV, childV)
-					if child:IsFullHeight() or alignFn == "fill" then
-						f:SetHeight(cellV)
-					end
-					f:SetPoint("TOP", content, 0, -(offsetV + align))
-				end
-			end
-		end
-
-		-- Calculate total height
-		local totalV = GetCellDimension("V", laneV, 1, #laneV, spaceV)
-
-		-- Cleanup
-		for _,v in pairs(layoutCache) do wipe(v) end
-
-		safecall(obj.LayoutFinished, obj, nil, totalV)
-		obj:ResumeLayout()
-	end)
+--- **AceGUI-3.0** provides access to numerous widgets which can be used to create GUIs.
+-- AceGUI is used by AceConfigDialog to create the option GUIs, but you can use it by itself
+-- to create any custom GUI. There are more extensive examples in the test suite in the Ace3
+-- stand-alone distribution.
+--
+-- **Note**: When using AceGUI-3.0 directly, please do not modify the frames of the widgets directly,
+-- as any "unknown" change to the widgets will cause addons that get your widget out of the widget pool
+-- to misbehave. If you think some part of a widget should be modifiable, please open a ticket, and we"ll
+-- implement a proper API to modify it.
+-- @usage
+-- local AceGUI = LibStub("AceGUI-3.0")
+-- -- Create a container frame
+-- local f = AceGUI:Create("Frame")
+-- f:SetCallback("OnClose",function(widget) AceGUI:Release(widget) end)
+-- f:SetTitle("AceGUI-3.0 Example")
+-- f:SetStatusText("Status Bar")
+-- f:SetLayout("Flow")
+-- -- Create a button
+-- local btn = AceGUI:Create("Button")
+-- btn:SetWidth(170)
+-- btn:SetText("Button !")
+-- btn:SetCallback("OnClick", function() print("Click!") end)
+-- -- Add the button to the container
+-- f:AddChild(btn)
+-- @class file
+-- @name AceGUI-3.0
+-- @release $Id: AceGUI-3.0.lua 1288 2022-09-25 14:19:00Z funkehdude $
+local ACEGUI_MAJOR, ACEGUI_MINOR = "AceGUI-3.0", 41
+local AceGUI, oldminor = LibStub:NewLibrary(ACEGUI_MAJOR, ACEGUI_MINOR)
+
+if not AceGUI then return end -- No upgrade needed
+
+-- Lua APIs
+local tinsert, wipe = table.insert, table.wipe
+local select, pairs, next, type = select, pairs, next, type
+local error, assert = error, assert
+local setmetatable, rawget = setmetatable, rawget
+local math_max, math_min, math_ceil = math.max, math.min, math.ceil
+
+-- WoW APIs
+local UIParent = UIParent
+
+AceGUI.WidgetRegistry = AceGUI.WidgetRegistry or {}
+AceGUI.LayoutRegistry = AceGUI.LayoutRegistry or {}
+AceGUI.WidgetBase = AceGUI.WidgetBase or {}
+AceGUI.WidgetContainerBase = AceGUI.WidgetContainerBase or {}
+AceGUI.WidgetVersions = AceGUI.WidgetVersions or {}
+AceGUI.tooltip = AceGUI.tooltip or CreateFrame("GameTooltip", "AceGUITooltip", UIParent, "GameTooltipTemplate")
+
+-- local upvalues
+local WidgetRegistry = AceGUI.WidgetRegistry
+local LayoutRegistry = AceGUI.LayoutRegistry
+local WidgetVersions = AceGUI.WidgetVersions
+
+--[[
+	 xpcall safecall implementation
+]]
+local xpcall = xpcall
+
+local function errorhandler(err)
+	return geterrorhandler()(err)
+end
+
+local function safecall(func, ...)
+	if func then
+		return xpcall(func, errorhandler, ...)
+	end
+end
+
+-- Recycling functions
+local newWidget, delWidget
+do
+	-- Version Upgrade in Minor 29
+	-- Internal Storage of the objects changed, from an array table
+	-- to a hash table, and additionally we introduced versioning on
+	-- the widgets which would discard all widgets from a pre-29 version
+	-- anyway, so we just clear the storage now, and don't try to
+	-- convert the storage tables to the new format.
+	-- This should generally not cause *many* widgets to end up in trash,
+	-- since once dialogs are opened, all addons should be loaded already
+	-- and AceGUI should be on the latest version available on the users
+	-- setup.
+	-- -- nevcairiel - Nov 2nd, 2009
+	if oldminor and oldminor < 29 and AceGUI.objPools then
+		AceGUI.objPools = nil
+	end
+
+	AceGUI.objPools = AceGUI.objPools or {}
+	local objPools = AceGUI.objPools
+	--Returns a new instance, if none are available either returns a new table or calls the given contructor
+	function newWidget(widgetType)
+		if not WidgetRegistry[widgetType] then
+			error("Attempt to instantiate unknown widget type", 2)
+		end
+
+		if not objPools[widgetType] then
+			objPools[widgetType] = {}
+		end
+
+		local newObj = next(objPools[widgetType])
+		if not newObj then
+			newObj = WidgetRegistry[widgetType]()
+			newObj.AceGUIWidgetVersion = WidgetVersions[widgetType]
+		else
+			objPools[widgetType][newObj] = nil
+			-- if the widget is older then the latest, don't even try to reuse it
+			-- just forget about it, and grab a new one.
+			if not newObj.AceGUIWidgetVersion or newObj.AceGUIWidgetVersion < WidgetVersions[widgetType] then
+				return newWidget(widgetType)
+			end
+		end
+		return newObj
+	end
+	-- Releases an instance to the Pool
+	function delWidget(obj,widgetType)
+		if not objPools[widgetType] then
+			objPools[widgetType] = {}
+		end
+		if objPools[widgetType][obj] then
+			error("Attempt to Release Widget that is already released", 2)
+		end
+		objPools[widgetType][obj] = true
+	end
+end
+
+
+-------------------
+-- API Functions --
+-------------------
+
+-- Gets a widget Object
+
+--- Create a new Widget of the given type.
+-- This function will instantiate a new widget (or use one from the widget pool), and call the
+-- OnAcquire function on it, before returning.
+-- @param type The type of the widget.
+-- @return The newly created widget.
+function AceGUI:Create(widgetType)
+	if WidgetRegistry[widgetType] then
+		local widget = newWidget(widgetType)
+
+		if rawget(widget, "Acquire") then
+			widget.OnAcquire = widget.Acquire
+			widget.Acquire = nil
+		elseif rawget(widget, "Aquire") then
+			widget.OnAcquire = widget.Aquire
+			widget.Aquire = nil
+		end
+
+		if rawget(widget, "Release") then
+			widget.OnRelease = rawget(widget, "Release")
+			widget.Release = nil
+		end
+
+		if widget.OnAcquire then
+			widget:OnAcquire()
+		else
+			error(("Widget type %s doesn't supply an OnAcquire Function"):format(widgetType))
+		end
+		-- Set the default Layout ("List")
+		safecall(widget.SetLayout, widget, "List")
+		safecall(widget.ResumeLayout, widget)
+		return widget
+	end
+end
+
+--- Releases a widget Object.
+-- This function calls OnRelease on the widget and places it back in the widget pool.
+-- Any data on the widget is being erased, and the widget will be hidden.\\
+-- If this widget is a Container-Widget, all of its Child-Widgets will be releases as well.
+-- @param widget The widget to release
+function AceGUI:Release(widget)
+	if widget.isQueuedForRelease then return end
+	widget.isQueuedForRelease = true
+	safecall(widget.PauseLayout, widget)
+	widget.frame:Hide()
+	widget:Fire("OnRelease")
+	safecall(widget.ReleaseChildren, widget)
+
+	if widget.OnRelease then
+		widget:OnRelease()
+--	else
+--		error(("Widget type %s doesn't supply an OnRelease Function"):format(widget.type))
+	end
+	for k in pairs(widget.userdata) do
+		widget.userdata[k] = nil
+	end
+	for k in pairs(widget.events) do
+		widget.events[k] = nil
+	end
+	widget.width = nil
+	widget.relWidth = nil
+	widget.height = nil
+	widget.relHeight = nil
+	widget.noAutoHeight = nil
+	widget.frame:ClearAllPoints()
+	widget.frame:Hide()
+	widget.frame:SetParent(UIParent)
+	widget.frame.width = nil
+	widget.frame.height = nil
+	if widget.content then
+		widget.content.width = nil
+		widget.content.height = nil
+	end
+	widget.isQueuedForRelease = nil
+	delWidget(widget, widget.type)
+end
+
+--- Check if a widget is currently in the process of being released
+-- This function check if this widget, or any of its parents (in which case it'll be released shortly as well)
+-- are currently being released. This allows addon to handle any callbacks accordingly.
+-- @param widget The widget to check
+function AceGUI:IsReleasing(widget)
+	if widget.isQueuedForRelease then
+		return true
+	end
+
+	if widget.parent and widget.parent.AceGUIWidgetVersion then
+		return AceGUI:IsReleasing(widget.parent)
+	end
+
+	return false
+end
+
+-----------
+-- Focus --
+-----------
+
+
+--- Called when a widget has taken focus.
+-- e.g. Dropdowns opening, Editboxes gaining kb focus
+-- @param widget The widget that should be focused
+function AceGUI:SetFocus(widget)
+	if self.FocusedWidget and self.FocusedWidget ~= widget then
+		safecall(self.FocusedWidget.ClearFocus, self.FocusedWidget)
+	end
+	self.FocusedWidget = widget
+end
+
+
+--- Called when something has happened that could cause widgets with focus to drop it
+-- e.g. titlebar of a frame being clicked
+function AceGUI:ClearFocus()
+	if self.FocusedWidget then
+		safecall(self.FocusedWidget.ClearFocus, self.FocusedWidget)
+		self.FocusedWidget = nil
+	end
+end
+
+-------------
+-- Widgets --
+-------------
+--[[
+	Widgets must provide the following functions
+		OnAcquire() - Called when the object is acquired, should set everything to a default hidden state
+
+	And the following members
+		frame - the frame or derivitive object that will be treated as the widget for size and anchoring purposes
+		type - the type of the object, same as the name given to :RegisterWidget()
+
+	Widgets contain a table called userdata, this is a safe place to store data associated with the wigdet
+	It will be cleared automatically when a widget is released
+	Placing values directly into a widget object should be avoided
+
+	If the Widget can act as a container for other Widgets the following
+		content - frame or derivitive that children will be anchored to
+
+	The Widget can supply the following Optional Members
+		:OnRelease() - Called when the object is Released, should remove any additional anchors and clear any data
+		:OnWidthSet(width) - Called when the width of the widget is changed
+		:OnHeightSet(height) - Called when the height of the widget is changed
+			Widgets should not use the OnSizeChanged events of thier frame or content members, use these methods instead
+			AceGUI already sets a handler to the event
+		:LayoutFinished(width, height) - called after a layout has finished, the width and height will be the width and height of the
+			area used for controls. These can be nil if the layout used the existing size to layout the controls.
+
+]]
+
+--------------------------
+-- Widget Base Template --
+--------------------------
+do
+	local WidgetBase = AceGUI.WidgetBase
+
+	WidgetBase.SetParent = function(self, parent)
+		local frame = self.frame
+		frame:SetParent(nil)
+		frame:SetParent(parent.content)
+		self.parent = parent
+	end
+
+	WidgetBase.SetCallback = function(self, name, func)
+		if type(func) == "function" then
+			self.events[name] = func
+		end
+	end
+
+	WidgetBase.Fire = function(self, name, ...)
+		if self.events[name] then
+			local success, ret = safecall(self.events[name], self, name, ...)
+			if success then
+				return ret
+			end
+		end
+	end
+
+	WidgetBase.SetWidth = function(self, width)
+		self.frame:SetWidth(width)
+		self.frame.width = width
+		if self.OnWidthSet then
+			self:OnWidthSet(width)
+		end
+	end
+
+	WidgetBase.SetRelativeWidth = function(self, width)
+		if width <= 0 or width > 1 then
+			error(":SetRelativeWidth(width): Invalid relative width.", 2)
+		end
+		self.relWidth = width
+		self.width = "relative"
+	end
+
+	WidgetBase.SetHeight = function(self, height)
+		self.frame:SetHeight(height)
+		self.frame.height = height
+		if self.OnHeightSet then
+			self:OnHeightSet(height)
+		end
+	end
+
+	--[[ WidgetBase.SetRelativeHeight = function(self, height)
+		if height <= 0 or height > 1 then
+			error(":SetRelativeHeight(height): Invalid relative height.", 2)
+		end
+		self.relHeight = height
+		self.height = "relative"
+	end ]]
+
+	WidgetBase.IsVisible = function(self)
+		return self.frame:IsVisible()
+	end
+
+	WidgetBase.IsShown= function(self)
+		return self.frame:IsShown()
+	end
+
+	WidgetBase.Release = function(self)
+		AceGUI:Release(self)
+	end
+
+	WidgetBase.IsReleasing = function(self)
+		return AceGUI:IsReleasing(self)
+	end
+
+	WidgetBase.SetPoint = function(self, ...)
+		return self.frame:SetPoint(...)
+	end
+
+	WidgetBase.ClearAllPoints = function(self)
+		return self.frame:ClearAllPoints()
+	end
+
+	WidgetBase.GetNumPoints = function(self)
+		return self.frame:GetNumPoints()
+	end
+
+	WidgetBase.GetPoint = function(self, ...)
+		return self.frame:GetPoint(...)
+	end
+
+	WidgetBase.GetUserDataTable = function(self)
+		return self.userdata
+	end
+
+	WidgetBase.SetUserData = function(self, key, value)
+		self.userdata[key] = value
+	end
+
+	WidgetBase.GetUserData = function(self, key)
+		return self.userdata[key]
+	end
+
+	WidgetBase.IsFullHeight = function(self)
+		return self.height == "fill"
+	end
+
+	WidgetBase.SetFullHeight = function(self, isFull)
+		if isFull then
+			self.height = "fill"
+		else
+			self.height = nil
+		end
+	end
+
+	WidgetBase.IsFullWidth = function(self)
+		return self.width == "fill"
+	end
+
+	WidgetBase.SetFullWidth = function(self, isFull)
+		if isFull then
+			self.width = "fill"
+		else
+			self.width = nil
+		end
+	end
+
+--	local function LayoutOnUpdate(this)
+--		this:SetScript("OnUpdate",nil)
+--		this.obj:PerformLayout()
+--	end
+
+	local WidgetContainerBase = AceGUI.WidgetContainerBase
+
+	WidgetContainerBase.PauseLayout = function(self)
+		self.LayoutPaused = true
+	end
+
+	WidgetContainerBase.ResumeLayout = function(self)
+		self.LayoutPaused = nil
+	end
+
+	WidgetContainerBase.PerformLayout = function(self)
+		if self.LayoutPaused then
+			return
+		end
+		safecall(self.LayoutFunc, self.content, self.children)
+	end
+
+	--call this function to layout, makes sure layed out objects get a frame to get sizes etc
+	WidgetContainerBase.DoLayout = function(self)
+		self:PerformLayout()
+--		if not self.parent then
+--			self.frame:SetScript("OnUpdate", LayoutOnUpdate)
+--		end
+	end
+
+	WidgetContainerBase.AddChild = function(self, child, beforeWidget)
+		if beforeWidget then
+			local siblingIndex = 1
+			for _, widget in pairs(self.children) do
+				if widget == beforeWidget then
+					break
+				end
+				siblingIndex = siblingIndex + 1
+			end
+			tinsert(self.children, siblingIndex, child)
+		else
+			tinsert(self.children, child)
+		end
+		child:SetParent(self)
+		child.frame:Show()
+		self:DoLayout()
+	end
+
+	WidgetContainerBase.AddChildren = function(self, ...)
+		for i = 1, select("#", ...) do
+			local child = select(i, ...)
+			tinsert(self.children, child)
+			child:SetParent(self)
+			child.frame:Show()
+		end
+		self:DoLayout()
+	end
+
+	WidgetContainerBase.ReleaseChildren = function(self)
+		local children = self.children
+		for i = 1,#children do
+			AceGUI:Release(children[i])
+			children[i] = nil
+		end
+	end
+
+	WidgetContainerBase.SetLayout = function(self, Layout)
+		self.LayoutFunc = AceGUI:GetLayout(Layout)
+	end
+
+	WidgetContainerBase.SetAutoAdjustHeight = function(self, adjust)
+		if adjust then
+			self.noAutoHeight = nil
+		else
+			self.noAutoHeight = true
+		end
+	end
+
+	local function FrameResize(this)
+		local self = this.obj
+		if this:GetWidth() and this:GetHeight() then
+			if self.OnWidthSet then
+				self:OnWidthSet(this:GetWidth())
+			end
+			if self.OnHeightSet then
+				self:OnHeightSet(this:GetHeight())
+			end
+		end
+	end
+
+	local function ContentResize(this)
+		if this:GetWidth() and this:GetHeight() then
+			this.width = this:GetWidth()
+			this.height = this:GetHeight()
+			this.obj:DoLayout()
+		end
+	end
+
+	setmetatable(WidgetContainerBase, {__index=WidgetBase})
+
+	--One of these function should be called on each Widget Instance as part of its creation process
+
+	--- Register a widget-class as a container for newly created widgets.
+	-- @param widget The widget class
+	function AceGUI:RegisterAsContainer(widget)
+		widget.children = {}
+		widget.userdata = {}
+		widget.events = {}
+		widget.base = WidgetContainerBase
+		widget.content.obj = widget
+		widget.frame.obj = widget
+		widget.content:SetScript("OnSizeChanged", ContentResize)
+		widget.frame:SetScript("OnSizeChanged", FrameResize)
+		setmetatable(widget, {__index = WidgetContainerBase})
+		widget:SetLayout("List")
+		return widget
+	end
+
+	--- Register a widget-class as a widget.
+	-- @param widget The widget class
+	function AceGUI:RegisterAsWidget(widget)
+		widget.userdata = {}
+		widget.events = {}
+		widget.base = WidgetBase
+		widget.frame.obj = widget
+		widget.frame:SetScript("OnSizeChanged", FrameResize)
+		setmetatable(widget, {__index = WidgetBase})
+		return widget
+	end
+end
+
+
+
+
+------------------
+-- Widget API   --
+------------------
+
+--- Registers a widget Constructor, this function returns a new instance of the Widget
+-- @param Name The name of the widget
+-- @param Constructor The widget constructor function
+-- @param Version The version of the widget
+function AceGUI:RegisterWidgetType(Name, Constructor, Version)
+	assert(type(Constructor) == "function")
+	assert(type(Version) == "number")
+
+	local oldVersion = WidgetVersions[Name]
+	if oldVersion and oldVersion >= Version then return end
+
+	WidgetVersions[Name] = Version
+	WidgetRegistry[Name] = Constructor
+end
+
+--- Registers a Layout Function
+-- @param Name The name of the layout
+-- @param LayoutFunc Reference to the layout function
+function AceGUI:RegisterLayout(Name, LayoutFunc)
+	assert(type(LayoutFunc) == "function")
+	if type(Name) == "string" then
+		Name = Name:upper()
+	end
+	LayoutRegistry[Name] = LayoutFunc
+end
+
+--- Get a Layout Function from the registry
+-- @param Name The name of the layout
+function AceGUI:GetLayout(Name)
+	if type(Name) == "string" then
+		Name = Name:upper()
+	end
+	return LayoutRegistry[Name]
+end
+
+AceGUI.counts = AceGUI.counts or {}
+
+--- A type-based counter to count the number of widgets created.
+-- This is used by widgets that require a named frame, e.g. when a Blizzard
+-- Template requires it.
+-- @param type The widget type
+function AceGUI:GetNextWidgetNum(widgetType)
+	if not self.counts[widgetType] then
+		self.counts[widgetType] = 0
+	end
+	self.counts[widgetType] = self.counts[widgetType] + 1
+	return self.counts[widgetType]
+end
+
+--- Return the number of created widgets for this type.
+-- In contrast to GetNextWidgetNum, the number is not incremented.
+-- @param widgetType The widget type
+function AceGUI:GetWidgetCount(widgetType)
+	return self.counts[widgetType] or 0
+end
+
+--- Return the version of the currently registered widget type.
+-- @param widgetType The widget type
+function AceGUI:GetWidgetVersion(widgetType)
+	return WidgetVersions[widgetType]
+end
+
+-------------
+-- Layouts --
+-------------
+
+--[[
+	A Layout is a func that takes 2 parameters
+		content - the frame that widgets will be placed inside
+		children - a table containing the widgets to layout
+]]
+
+-- Very simple Layout, Children are stacked on top of each other down the left side
+AceGUI:RegisterLayout("List",
+	function(content, children)
+		local height = 0
+		local width = content.width or content:GetWidth() or 0
+		for i = 1, #children do
+			local child = children[i]
+
+			local frame = child.frame
+			frame:ClearAllPoints()
+			frame:Show()
+			if i == 1 then
+				frame:SetPoint("TOPLEFT", content)
+			else
+				frame:SetPoint("TOPLEFT", children[i-1].frame, "BOTTOMLEFT")
+			end
+
+			if child.width == "fill" then
+				child:SetWidth(width)
+				frame:SetPoint("RIGHT", content)
+
+				if child.DoLayout then
+					child:DoLayout()
+				end
+			elseif child.width == "relative" then
+				child:SetWidth(width * child.relWidth)
+
+				if child.DoLayout then
+					child:DoLayout()
+				end
+			end
+
+			height = height + (frame.height or frame:GetHeight() or 0)
+		end
+		safecall(content.obj.LayoutFinished, content.obj, nil, height)
+	end)
+
+-- A single control fills the whole content area
+AceGUI:RegisterLayout("Fill",
+	function(content, children)
+		if children[1] then
+			children[1]:SetWidth(content:GetWidth() or 0)
+			children[1]:SetHeight(content:GetHeight() or 0)
+			children[1].frame:ClearAllPoints()
+			children[1].frame:SetAllPoints(content)
+			children[1].frame:Show()
+			safecall(content.obj.LayoutFinished, content.obj, nil, children[1].frame:GetHeight())
+		end
+	end)
+
+local layoutrecursionblock = nil
+local function safelayoutcall(object, func, ...)
+	layoutrecursionblock = true
+	object[func](object, ...)
+	layoutrecursionblock = nil
+end
+
+AceGUI:RegisterLayout("Flow",
+	function(content, children)
+		if layoutrecursionblock then return end
+		--used height so far
+		local height = 0
+		--width used in the current row
+		local usedwidth = 0
+		--height of the current row
+		local rowheight = 0
+		local rowoffset = 0
+
+		local width = content.width or content:GetWidth() or 0
+
+		--control at the start of the row
+		local rowstart
+		local rowstartoffset
+		local isfullheight
+
+		local frameoffset
+		local lastframeoffset
+		local oversize
+		for i = 1, #children do
+			local child = children[i]
+			oversize = nil
+			local frame = child.frame
+			local frameheight = frame.height or frame:GetHeight() or 0
+			local framewidth = frame.width or frame:GetWidth() or 0
+			lastframeoffset = frameoffset
+			-- HACK: Why did we set a frameoffset of (frameheight / 2) ?
+			-- That was moving all widgets half the widgets size down, is that intended?
+			-- Actually, it seems to be neccessary for many cases, we'll leave it in for now.
+			-- If widgets seem to anchor weirdly with this, provide a valid alignoffset for them.
+			-- TODO: Investigate moar!
+			frameoffset = child.alignoffset or (frameheight / 2)
+
+			if child.width == "relative" then
+				framewidth = width * child.relWidth
+			end
+
+			frame:Show()
+			frame:ClearAllPoints()
+			if i == 1 then
+				-- anchor the first control to the top left
+				frame:SetPoint("TOPLEFT", content)
+				rowheight = frameheight
+				rowoffset = frameoffset
+				rowstart = frame
+				rowstartoffset = frameoffset
+				usedwidth = framewidth
+				if usedwidth > width then
+					oversize = true
+				end
+			else
+				-- if there isn't available width for the control start a new row
+				-- if a control is "fill" it will be on a row of its own full width
+				if usedwidth == 0 or ((framewidth) + usedwidth > width) or child.width == "fill" then
+					if isfullheight then
+						-- a previous row has already filled the entire height, there's nothing we can usefully do anymore
+						-- (maybe error/warn about this?)
+						break
+					end
+					--anchor the previous row, we will now know its height and offset
+					rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -(height + (rowoffset - rowstartoffset) + 3))
+					height = height + rowheight + 3
+					--save this as the rowstart so we can anchor it after the row is complete and we have the max height and offset of controls in it
+					rowstart = frame
+					rowstartoffset = frameoffset
+					rowheight = frameheight
+					rowoffset = frameoffset
+					usedwidth = framewidth
+					if usedwidth > width then
+						oversize = true
+					end
+				-- put the control on the current row, adding it to the width and checking if the height needs to be increased
+				else
+					--handles cases where the new height is higher than either control because of the offsets
+					--math.max(rowheight-rowoffset+frameoffset, frameheight-frameoffset+rowoffset)
+
+					--offset is always the larger of the two offsets
+					rowoffset = math_max(rowoffset, frameoffset)
+					rowheight = math_max(rowheight, rowoffset + (frameheight / 2))
+
+					frame:SetPoint("TOPLEFT", children[i-1].frame, "TOPRIGHT", 0, frameoffset - lastframeoffset)
+					usedwidth = framewidth + usedwidth
+				end
+			end
+
+			if child.width == "fill" then
+				safelayoutcall(child, "SetWidth", width)
+				frame:SetPoint("RIGHT", content)
+
+				usedwidth = 0
+				rowstart = frame
+
+				if child.DoLayout then
+					child:DoLayout()
+				end
+				rowheight = frame.height or frame:GetHeight() or 0
+				rowoffset = child.alignoffset or (rowheight / 2)
+				rowstartoffset = rowoffset
+			elseif child.width == "relative" then
+				safelayoutcall(child, "SetWidth", width * child.relWidth)
+
+				if child.DoLayout then
+					child:DoLayout()
+				end
+			elseif oversize then
+				if width > 1 then
+					frame:SetPoint("RIGHT", content)
+				end
+			end
+
+			if child.height == "fill" then
+				frame:SetPoint("BOTTOM", content)
+				isfullheight = true
+			end
+		end
+
+		--anchor the last row, if its full height needs a special case since  its height has just been changed by the anchor
+		if isfullheight then
+			rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -height)
+		elseif rowstart then
+			rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -(height + (rowoffset - rowstartoffset) + 3))
+		end
+
+		height = height + rowheight + 3
+		safecall(content.obj.LayoutFinished, content.obj, nil, height)
+	end)
+
+-- Get alignment method and value. Possible alignment methods are a callback, a number, "start", "middle", "end", "fill" or "TOPLEFT", "BOTTOMRIGHT" etc.
+local GetCellAlign = function (dir, tableObj, colObj, cellObj, cell, child)
+	local fn = cellObj and (cellObj["align" .. dir] or cellObj.align)
+			or colObj and (colObj["align" .. dir] or colObj.align)
+			or tableObj["align" .. dir] or tableObj.align
+			or "CENTERLEFT"
+	local val
+	child, cell = child or 0, cell or 0
+
+	if type(fn) == "string" then
+		fn = fn:lower()
+		fn = dir == "V" and (fn:sub(1, 3) == "top" and "start" or fn:sub(1, 6) == "bottom" and "end" or fn:sub(1, 6) == "center" and "middle")
+		  or dir == "H" and (fn:sub(-4) == "left" and "start" or fn:sub(-5) == "right" and "end" or fn:sub(-6) == "center" and "middle")
+		  or fn
+		val = (fn == "start" or fn == "fill") and 0 or fn == "end" and cell - child or (cell - child) / 2
+	elseif type(fn) == "function" then
+		val = fn(child or 0, cell, dir)
+	else
+		val = fn
+	end
+
+	return fn, math_max(0, math_min(val, cell))
+end
+
+-- Get width or height for multiple cells combined
+local GetCellDimension = function (dir, laneDim, from, to, space)
+	local dim = 0
+	for cell=from,to do
+		dim = dim + (laneDim[cell] or 0)
+	end
+	return dim + math_max(0, to - from) * (space or 0)
+end
+
+--[[ Options
+============
+Container:
+ - columns ({col, col, ...}): Column settings. "col" can be a number (<= 0: content width, <1: rel. width, <10: weight, >=10: abs. width) or a table with column setting.
+ - space, spaceH, spaceV: Overall, horizontal and vertical spacing between cells.
+ - align, alignH, alignV: Overall, horizontal and vertical cell alignment. See GetCellAlign() for possible values.
+Columns:
+ - width: Fixed column width (nil or <=0: content width, <1: rel. width, >=1: abs. width).
+ - min or 1: Min width for content based width
+ - max or 2: Max width for content based width
+ - weight: Flexible column width. The leftover width after accounting for fixed-width columns is distributed to weighted columns according to their weights.
+ - align, alignH, alignV: Overwrites the container setting for alignment.
+Cell:
+ - colspan: Makes a cell span multiple columns.
+ - rowspan: Makes a cell span multiple rows.
+ - align, alignH, alignV: Overwrites the container and column setting for alignment.
+]]
+AceGUI:RegisterLayout("Table",
+	function (content, children)
+		local obj = content.obj
+		obj:PauseLayout()
+
+		local tableObj = obj:GetUserData("table")
+		local cols = tableObj.columns
+		local spaceH = tableObj.spaceH or tableObj.space or 0
+		local spaceV = tableObj.spaceV or tableObj.space or 0
+		local totalH = (content:GetWidth() or content.width or 0) - spaceH * (#cols - 1)
+
+		-- We need to reuse these because layout events can come in very frequently
+		local layoutCache = obj:GetUserData("layoutCache")
+		if not layoutCache then
+			layoutCache = {{}, {}, {}, {}, {}, {}}
+			obj:SetUserData("layoutCache", layoutCache)
+		end
+		local t, laneH, laneV, rowspans, rowStart, colStart = unpack(layoutCache)
+
+		-- Create the grid
+		local n, slotFound = 0
+		for i,child in ipairs(children) do
+			if child:IsShown() then
+				repeat
+					n = n + 1
+					local col = (n - 1) % #cols + 1
+					local row = math_ceil(n / #cols)
+					local rowspan = rowspans[col]
+					local cell = rowspan and rowspan.child or child
+					local cellObj = cell:GetUserData("cell")
+					slotFound = not rowspan
+
+					-- Rowspan
+					if not rowspan and cellObj and cellObj.rowspan then
+						rowspan = {child = child, from = row, to = row + cellObj.rowspan - 1}
+						rowspans[col] = rowspan
+					end
+					if rowspan and i == #children then
+						rowspan.to = row
+					end
+
+					-- Colspan
+					local colspan = math_max(0, math_min((cellObj and cellObj.colspan or 1) - 1, #cols - col))
+					n = n + colspan
+
+					-- Place the cell
+					if not rowspan or rowspan.to == row then
+						t[n] = cell
+						rowStart[cell] = rowspan and rowspan.from or row
+						colStart[cell] = col
+
+						if rowspan then
+							rowspans[col] = nil
+						end
+					end
+				until slotFound
+			end
+		end
+
+		local rows = math_ceil(n / #cols)
+
+		-- Determine fixed size cols and collect weights
+		local extantH, totalWeight = totalH, 0
+		for col,colObj in ipairs(cols) do
+			laneH[col] = 0
+
+			if type(colObj) == "number" then
+				colObj = {[colObj >= 1 and colObj < 10 and "weight" or "width"] = colObj}
+				cols[col] = colObj
+			end
+
+			if colObj.weight then
+				-- Weight
+				totalWeight = totalWeight + (colObj.weight or 1)
+			else
+				if not colObj.width or colObj.width <= 0 then
+					-- Content width
+					for row=1,rows do
+						local child = t[(row - 1) * #cols + col]
+						if child then
+							local f = child.frame
+							f:ClearAllPoints()
+							local childH = f:GetWidth() or 0
+
+							laneH[col] = math_max(laneH[col], childH - GetCellDimension("H", laneH, colStart[child], col - 1, spaceH))
+						end
+					end
+
+					laneH[col] = math_max(colObj.min or colObj[1] or 0, math_min(laneH[col], colObj.max or colObj[2] or laneH[col]))
+				else
+					-- Rel./Abs. width
+					laneH[col] = colObj.width < 1 and colObj.width * totalH or colObj.width
+				end
+				extantH = math_max(0, extantH - laneH[col])
+			end
+		end
+
+		-- Determine sizes based on weight
+		local scale = totalWeight > 0 and extantH / totalWeight or 0
+		for col,colObj in pairs(cols) do
+			if colObj.weight then
+				laneH[col] = scale * colObj.weight
+			end
+		end
+
+		-- Arrange children
+		for row=1,rows do
+			local rowV = 0
+
+			-- Horizontal placement and sizing
+			for col=1,#cols do
+				local child = t[(row - 1) * #cols + col]
+				if child then
+					local colObj = cols[colStart[child]]
+					local cellObj = child:GetUserData("cell")
+					local offsetH = GetCellDimension("H", laneH, 1, colStart[child] - 1, spaceH) + (colStart[child] == 1 and 0 or spaceH)
+					local cellH = GetCellDimension("H", laneH, colStart[child], col, spaceH)
+
+					local f = child.frame
+					f:ClearAllPoints()
+					local childH = f:GetWidth() or 0
+
+					local alignFn, align = GetCellAlign("H", tableObj, colObj, cellObj, cellH, childH)
+					f:SetPoint("LEFT", content, offsetH + align, 0)
+					if child:IsFullWidth() or alignFn == "fill" or childH > cellH then
+						f:SetPoint("RIGHT", content, "LEFT", offsetH + align + cellH, 0)
+					end
+
+					if child.DoLayout then
+						child:DoLayout()
+					end
+
+					rowV = math_max(rowV, (f:GetHeight() or 0) - GetCellDimension("V", laneV, rowStart[child], row - 1, spaceV))
+				end
+			end
+
+			laneV[row] = rowV
+
+			-- Vertical placement and sizing
+			for col=1,#cols do
+				local child = t[(row - 1) * #cols + col]
+				if child then
+					local colObj = cols[colStart[child]]
+					local cellObj = child:GetUserData("cell")
+					local offsetV = GetCellDimension("V", laneV, 1, rowStart[child] - 1, spaceV) + (rowStart[child] == 1 and 0 or spaceV)
+					local cellV = GetCellDimension("V", laneV, rowStart[child], row, spaceV)
+
+					local f = child.frame
+					local childV = f:GetHeight() or 0
+
+					local alignFn, align = GetCellAlign("V", tableObj, colObj, cellObj, cellV, childV)
+					if child:IsFullHeight() or alignFn == "fill" then
+						f:SetHeight(cellV)
+					end
+					f:SetPoint("TOP", content, 0, -(offsetV + align))
+				end
+			end
+		end
+
+		-- Calculate total height
+		local totalV = GetCellDimension("V", laneV, 1, #laneV, spaceV)
+
+		-- Cleanup
+		for _,v in pairs(layoutCache) do wipe(v) end
+
+		safecall(obj.LayoutFinished, obj, nil, totalV)
+		obj:ResumeLayout()
+	end)
diff --git a/Carbonite/Libs/AceGUI-3.0/AceGUI-3.0.xml b/Carbonite/Libs/AceGUI-3.0/AceGUI-3.0.xml
index ae22c90..b515077 100644
--- a/Carbonite/Libs/AceGUI-3.0/AceGUI-3.0.xml
+++ b/Carbonite/Libs/AceGUI-3.0/AceGUI-3.0.xml
@@ -1,28 +1,28 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceGUI-3.0.lua"/>
-	<!-- Container -->
-	<Script file="widgets\AceGUIContainer-BlizOptionsGroup.lua"/>
-	<Script file="widgets\AceGUIContainer-DropDownGroup.lua"/>
-	<Script file="widgets\AceGUIContainer-Frame.lua"/>
-	<Script file="widgets\AceGUIContainer-InlineGroup.lua"/>
-	<Script file="widgets\AceGUIContainer-ScrollFrame.lua"/>
-	<Script file="widgets\AceGUIContainer-SimpleGroup.lua"/>
-	<Script file="widgets\AceGUIContainer-TabGroup.lua"/>
-	<Script file="widgets\AceGUIContainer-TreeGroup.lua"/>
-	<Script file="widgets\AceGUIContainer-Window.lua"/>
-	<!-- Widgets -->
-	<Script file="widgets\AceGUIWidget-Button.lua"/>
-	<Script file="widgets\AceGUIWidget-CheckBox.lua"/>
-	<Script file="widgets\AceGUIWidget-ColorPicker.lua"/>
-	<Script file="widgets\AceGUIWidget-DropDown.lua"/>
-	<Script file="widgets\AceGUIWidget-DropDown-Items.lua"/>
-	<Script file="widgets\AceGUIWidget-EditBox.lua"/>
-	<Script file="widgets\AceGUIWidget-Heading.lua"/>
-	<Script file="widgets\AceGUIWidget-Icon.lua"/>
-	<Script file="widgets\AceGUIWidget-InteractiveLabel.lua"/>
-	<Script file="widgets\AceGUIWidget-Keybinding.lua"/>
-	<Script file="widgets\AceGUIWidget-Label.lua"/>
-	<Script file="widgets\AceGUIWidget-MultiLineEditBox.lua"/>
-	<Script file="widgets\AceGUIWidget-Slider.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceGUI-3.0.lua"/>
+	<!-- Container -->
+	<Script file="widgets\AceGUIContainer-BlizOptionsGroup.lua"/>
+	<Script file="widgets\AceGUIContainer-DropDownGroup.lua"/>
+	<Script file="widgets\AceGUIContainer-Frame.lua"/>
+	<Script file="widgets\AceGUIContainer-InlineGroup.lua"/>
+	<Script file="widgets\AceGUIContainer-ScrollFrame.lua"/>
+	<Script file="widgets\AceGUIContainer-SimpleGroup.lua"/>
+	<Script file="widgets\AceGUIContainer-TabGroup.lua"/>
+	<Script file="widgets\AceGUIContainer-TreeGroup.lua"/>
+	<Script file="widgets\AceGUIContainer-Window.lua"/>
+	<!-- Widgets -->
+	<Script file="widgets\AceGUIWidget-Button.lua"/>
+	<Script file="widgets\AceGUIWidget-CheckBox.lua"/>
+	<Script file="widgets\AceGUIWidget-ColorPicker.lua"/>
+	<Script file="widgets\AceGUIWidget-DropDown.lua"/>
+	<Script file="widgets\AceGUIWidget-DropDown-Items.lua"/>
+	<Script file="widgets\AceGUIWidget-EditBox.lua"/>
+	<Script file="widgets\AceGUIWidget-Heading.lua"/>
+	<Script file="widgets\AceGUIWidget-Icon.lua"/>
+	<Script file="widgets\AceGUIWidget-InteractiveLabel.lua"/>
+	<Script file="widgets\AceGUIWidget-Keybinding.lua"/>
+	<Script file="widgets\AceGUIWidget-Label.lua"/>
+	<Script file="widgets\AceGUIWidget-MultiLineEditBox.lua"/>
+	<Script file="widgets\AceGUIWidget-Slider.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-BlizOptionsGroup.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-BlizOptionsGroup.lua
index bf1eae7..d95db58 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-BlizOptionsGroup.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-BlizOptionsGroup.lua
@@ -1,143 +1,143 @@
---[[-----------------------------------------------------------------------------
-BlizOptionsGroup Container
-Simple container widget for the integration of AceGUI into the Blizzard Interface Options
--------------------------------------------------------------------------------]]
-local Type, Version = "BlizOptionsGroup", 26
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs = pairs
-
--- WoW APIs
-local CreateFrame = CreateFrame
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-
-local function OnShow(frame)
-	frame.obj:Fire("OnShow")
-end
-
-local function OnHide(frame)
-	frame.obj:Fire("OnHide")
-end
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-
-local function okay(frame)
-	frame.obj:Fire("okay")
-end
-
-local function cancel(frame)
-	frame.obj:Fire("cancel")
-end
-
-local function default(frame)
-	frame.obj:Fire("default")
-end
-
-local function refresh(frame)
-	frame.obj:Fire("refresh")
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetName()
-		self:SetTitle()
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["OnWidthSet"] = function(self, width)
-		local content = self.content
-		local contentwidth = width - 63
-		if contentwidth < 0 then
-			contentwidth = 0
-		end
-		content:SetWidth(contentwidth)
-		content.width = contentwidth
-	end,
-
-	["OnHeightSet"] = function(self, height)
-		local content = self.content
-		local contentheight = height - 26
-		if contentheight < 0 then
-			contentheight = 0
-		end
-		content:SetHeight(contentheight)
-		content.height = contentheight
-	end,
-
-	["SetName"] = function(self, name, parent)
-		self.frame.name = name
-		self.frame.parent = parent
-	end,
-
-	["SetTitle"] = function(self, title)
-		local content = self.content
-		content:ClearAllPoints()
-		if not title or title == "" then
-			content:SetPoint("TOPLEFT", 10, -10)
-			self.label:SetText("")
-		else
-			content:SetPoint("TOPLEFT", 10, -40)
-			self.label:SetText(title)
-		end
-		content:SetPoint("BOTTOMRIGHT", -10, 10)
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local frame = CreateFrame("Frame", nil, InterfaceOptionsFramePanelContainer)
-	frame:Hide()
-
-	-- support functions for the Blizzard Interface Options
-	frame.okay = okay
-	frame.cancel = cancel
-	frame.default = default
-	frame.refresh = refresh
-
-	-- 10.0 support function aliases (cancel has been removed)
-	frame.OnCommit = okay
-	frame.OnDefault = default
-	frame.OnRefresh = refresh
-
-	frame:SetScript("OnHide", OnHide)
-	frame:SetScript("OnShow", OnShow)
-
-	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
-	label:SetPoint("TOPLEFT", 10, -15)
-	label:SetPoint("BOTTOMRIGHT", frame, "TOPRIGHT", 10, -45)
-	label:SetJustifyH("LEFT")
-	label:SetJustifyV("TOP")
-
-	--Container Support
-	local content = CreateFrame("Frame", nil, frame)
-	content:SetPoint("TOPLEFT", 10, -10)
-	content:SetPoint("BOTTOMRIGHT", -10, 10)
-
-	local widget = {
-		label   = label,
-		frame   = frame,
-		content = content,
-		type    = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	return AceGUI:RegisterAsContainer(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+BlizOptionsGroup Container
+Simple container widget for the integration of AceGUI into the Blizzard Interface Options
+-------------------------------------------------------------------------------]]
+local Type, Version = "BlizOptionsGroup", 26
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs = pairs
+
+-- WoW APIs
+local CreateFrame = CreateFrame
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+
+local function OnShow(frame)
+	frame.obj:Fire("OnShow")
+end
+
+local function OnHide(frame)
+	frame.obj:Fire("OnHide")
+end
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+
+local function okay(frame)
+	frame.obj:Fire("okay")
+end
+
+local function cancel(frame)
+	frame.obj:Fire("cancel")
+end
+
+local function default(frame)
+	frame.obj:Fire("default")
+end
+
+local function refresh(frame)
+	frame.obj:Fire("refresh")
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetName()
+		self:SetTitle()
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["OnWidthSet"] = function(self, width)
+		local content = self.content
+		local contentwidth = width - 63
+		if contentwidth < 0 then
+			contentwidth = 0
+		end
+		content:SetWidth(contentwidth)
+		content.width = contentwidth
+	end,
+
+	["OnHeightSet"] = function(self, height)
+		local content = self.content
+		local contentheight = height - 26
+		if contentheight < 0 then
+			contentheight = 0
+		end
+		content:SetHeight(contentheight)
+		content.height = contentheight
+	end,
+
+	["SetName"] = function(self, name, parent)
+		self.frame.name = name
+		self.frame.parent = parent
+	end,
+
+	["SetTitle"] = function(self, title)
+		local content = self.content
+		content:ClearAllPoints()
+		if not title or title == "" then
+			content:SetPoint("TOPLEFT", 10, -10)
+			self.label:SetText("")
+		else
+			content:SetPoint("TOPLEFT", 10, -40)
+			self.label:SetText(title)
+		end
+		content:SetPoint("BOTTOMRIGHT", -10, 10)
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local frame = CreateFrame("Frame", nil, InterfaceOptionsFramePanelContainer)
+	frame:Hide()
+
+	-- support functions for the Blizzard Interface Options
+	frame.okay = okay
+	frame.cancel = cancel
+	frame.default = default
+	frame.refresh = refresh
+
+	-- 10.0 support function aliases (cancel has been removed)
+	frame.OnCommit = okay
+	frame.OnDefault = default
+	frame.OnRefresh = refresh
+
+	frame:SetScript("OnHide", OnHide)
+	frame:SetScript("OnShow", OnShow)
+
+	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
+	label:SetPoint("TOPLEFT", 10, -15)
+	label:SetPoint("BOTTOMRIGHT", frame, "TOPRIGHT", 10, -45)
+	label:SetJustifyH("LEFT")
+	label:SetJustifyV("TOP")
+
+	--Container Support
+	local content = CreateFrame("Frame", nil, frame)
+	content:SetPoint("TOPLEFT", 10, -10)
+	content:SetPoint("BOTTOMRIGHT", -10, 10)
+
+	local widget = {
+		label   = label,
+		frame   = frame,
+		content = content,
+		type    = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	return AceGUI:RegisterAsContainer(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-DropDownGroup.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-DropDownGroup.lua
index 2322e3d..cd83755 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-DropDownGroup.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-DropDownGroup.lua
@@ -1,157 +1,157 @@
---[[-----------------------------------------------------------------------------
-DropdownGroup Container
-Container controlled by a dropdown on the top.
--------------------------------------------------------------------------------]]
-local Type, Version = "DropdownGroup", 22
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local assert, pairs, type = assert, pairs, type
-
--- WoW APIs
-local CreateFrame = CreateFrame
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function SelectedGroup(self, event, value)
-	local group = self.parentgroup
-	local status = group.status or group.localstatus
-	status.selected = value
-	self.parentgroup:Fire("OnGroupSelected", value)
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self.dropdown:SetText("")
-		self:SetDropdownWidth(200)
-		self:SetTitle("")
-	end,
-
-	["OnRelease"] = function(self)
-		self.dropdown.list = nil
-		self.status = nil
-		for k in pairs(self.localstatus) do
-			self.localstatus[k] = nil
-		end
-	end,
-
-	["SetTitle"] = function(self, title)
-		self.titletext:SetText(title)
-		self.dropdown.frame:ClearAllPoints()
-		if title and title ~= "" then
-			self.dropdown.frame:SetPoint("TOPRIGHT", -2, 0)
-		else
-			self.dropdown.frame:SetPoint("TOPLEFT", -1, 0)
-		end
-	end,
-
-	["SetGroupList"] = function(self,list,order)
-		self.dropdown:SetList(list,order)
-	end,
-
-	["SetStatusTable"] = function(self, status)
-		assert(type(status) == "table")
-		self.status = status
-	end,
-
-	["SetGroup"] = function(self,group)
-		self.dropdown:SetValue(group)
-		local status = self.status or self.localstatus
-		status.selected = group
-		self:Fire("OnGroupSelected", group)
-	end,
-
-	["OnWidthSet"] = function(self, width)
-		local content = self.content
-		local contentwidth = width - 26
-		if contentwidth < 0 then
-			contentwidth = 0
-		end
-		content:SetWidth(contentwidth)
-		content.width = contentwidth
-	end,
-
-	["OnHeightSet"] = function(self, height)
-		local content = self.content
-		local contentheight = height - 63
-		if contentheight < 0 then
-			contentheight = 0
-		end
-		content:SetHeight(contentheight)
-		content.height = contentheight
-	end,
-
-	["LayoutFinished"] = function(self, width, height)
-		self:SetHeight((height or 0) + 63)
-	end,
-
-	["SetDropdownWidth"] = function(self, width)
-		self.dropdown:SetWidth(width)
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local PaneBackdrop  = {
-	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
-	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
-	tile = true, tileSize = 16, edgeSize = 16,
-	insets = { left = 3, right = 3, top = 5, bottom = 3 }
-}
-
-local function Constructor()
-	local frame = CreateFrame("Frame")
-	frame:SetHeight(100)
-	frame:SetWidth(100)
-	frame:SetFrameStrata("FULLSCREEN_DIALOG")
-
-	local titletext = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
-	titletext:SetPoint("TOPLEFT", 4, -5)
-	titletext:SetPoint("TOPRIGHT", -4, -5)
-	titletext:SetJustifyH("LEFT")
-	titletext:SetHeight(18)
-
-	local dropdown = AceGUI:Create("Dropdown")
-	dropdown.frame:SetParent(frame)
-	dropdown.frame:SetFrameLevel(dropdown.frame:GetFrameLevel() + 2)
-	dropdown:SetCallback("OnValueChanged", SelectedGroup)
-	dropdown.frame:SetPoint("TOPLEFT", -1, 0)
-	dropdown.frame:Show()
-	dropdown:SetLabel("")
-
-	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
-	border:SetPoint("TOPLEFT", 0, -26)
-	border:SetPoint("BOTTOMRIGHT", 0, 3)
-	border:SetBackdrop(PaneBackdrop)
-	border:SetBackdropColor(0.1,0.1,0.1,0.5)
-	border:SetBackdropBorderColor(0.4,0.4,0.4)
-
-	--Container Support
-	local content = CreateFrame("Frame", nil, border)
-	content:SetPoint("TOPLEFT", 10, -10)
-	content:SetPoint("BOTTOMRIGHT", -10, 10)
-
-	local widget = {
-		frame       = frame,
-		localstatus = {},
-		titletext   = titletext,
-		dropdown    = dropdown,
-		border      = border,
-		content     = content,
-		type        = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-	dropdown.parentgroup = widget
-
-	return AceGUI:RegisterAsContainer(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+DropdownGroup Container
+Container controlled by a dropdown on the top.
+-------------------------------------------------------------------------------]]
+local Type, Version = "DropdownGroup", 22
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local assert, pairs, type = assert, pairs, type
+
+-- WoW APIs
+local CreateFrame = CreateFrame
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function SelectedGroup(self, event, value)
+	local group = self.parentgroup
+	local status = group.status or group.localstatus
+	status.selected = value
+	self.parentgroup:Fire("OnGroupSelected", value)
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self.dropdown:SetText("")
+		self:SetDropdownWidth(200)
+		self:SetTitle("")
+	end,
+
+	["OnRelease"] = function(self)
+		self.dropdown.list = nil
+		self.status = nil
+		for k in pairs(self.localstatus) do
+			self.localstatus[k] = nil
+		end
+	end,
+
+	["SetTitle"] = function(self, title)
+		self.titletext:SetText(title)
+		self.dropdown.frame:ClearAllPoints()
+		if title and title ~= "" then
+			self.dropdown.frame:SetPoint("TOPRIGHT", -2, 0)
+		else
+			self.dropdown.frame:SetPoint("TOPLEFT", -1, 0)
+		end
+	end,
+
+	["SetGroupList"] = function(self,list,order)
+		self.dropdown:SetList(list,order)
+	end,
+
+	["SetStatusTable"] = function(self, status)
+		assert(type(status) == "table")
+		self.status = status
+	end,
+
+	["SetGroup"] = function(self,group)
+		self.dropdown:SetValue(group)
+		local status = self.status or self.localstatus
+		status.selected = group
+		self:Fire("OnGroupSelected", group)
+	end,
+
+	["OnWidthSet"] = function(self, width)
+		local content = self.content
+		local contentwidth = width - 26
+		if contentwidth < 0 then
+			contentwidth = 0
+		end
+		content:SetWidth(contentwidth)
+		content.width = contentwidth
+	end,
+
+	["OnHeightSet"] = function(self, height)
+		local content = self.content
+		local contentheight = height - 63
+		if contentheight < 0 then
+			contentheight = 0
+		end
+		content:SetHeight(contentheight)
+		content.height = contentheight
+	end,
+
+	["LayoutFinished"] = function(self, width, height)
+		self:SetHeight((height or 0) + 63)
+	end,
+
+	["SetDropdownWidth"] = function(self, width)
+		self.dropdown:SetWidth(width)
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local PaneBackdrop  = {
+	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
+	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
+	tile = true, tileSize = 16, edgeSize = 16,
+	insets = { left = 3, right = 3, top = 5, bottom = 3 }
+}
+
+local function Constructor()
+	local frame = CreateFrame("Frame")
+	frame:SetHeight(100)
+	frame:SetWidth(100)
+	frame:SetFrameStrata("FULLSCREEN_DIALOG")
+
+	local titletext = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
+	titletext:SetPoint("TOPLEFT", 4, -5)
+	titletext:SetPoint("TOPRIGHT", -4, -5)
+	titletext:SetJustifyH("LEFT")
+	titletext:SetHeight(18)
+
+	local dropdown = AceGUI:Create("Dropdown")
+	dropdown.frame:SetParent(frame)
+	dropdown.frame:SetFrameLevel(dropdown.frame:GetFrameLevel() + 2)
+	dropdown:SetCallback("OnValueChanged", SelectedGroup)
+	dropdown.frame:SetPoint("TOPLEFT", -1, 0)
+	dropdown.frame:Show()
+	dropdown:SetLabel("")
+
+	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
+	border:SetPoint("TOPLEFT", 0, -26)
+	border:SetPoint("BOTTOMRIGHT", 0, 3)
+	border:SetBackdrop(PaneBackdrop)
+	border:SetBackdropColor(0.1,0.1,0.1,0.5)
+	border:SetBackdropBorderColor(0.4,0.4,0.4)
+
+	--Container Support
+	local content = CreateFrame("Frame", nil, border)
+	content:SetPoint("TOPLEFT", 10, -10)
+	content:SetPoint("BOTTOMRIGHT", -10, 10)
+
+	local widget = {
+		frame       = frame,
+		localstatus = {},
+		titletext   = titletext,
+		dropdown    = dropdown,
+		border      = border,
+		content     = content,
+		type        = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+	dropdown.parentgroup = widget
+
+	return AceGUI:RegisterAsContainer(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-Frame.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-Frame.lua
index ca90890..39a1004 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-Frame.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-Frame.lua
@@ -1,318 +1,318 @@
---[[-----------------------------------------------------------------------------
-Frame Container
--------------------------------------------------------------------------------]]
-local Type, Version = "Frame", 30
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs, assert, type = pairs, assert, type
-local wipe = table.wipe
-
--- WoW APIs
-local PlaySound = PlaySound
-local CreateFrame, UIParent = CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Button_OnClick(frame)
-	PlaySound(799) -- SOUNDKIT.GS_TITLE_OPTION_EXIT
-	frame.obj:Hide()
-end
-
-local function Frame_OnShow(frame)
-	frame.obj:Fire("OnShow")
-end
-
-local function Frame_OnClose(frame)
-	frame.obj:Fire("OnClose")
-end
-
-local function Frame_OnMouseDown(frame)
-	AceGUI:ClearFocus()
-end
-
-local function Title_OnMouseDown(frame)
-	frame:GetParent():StartMoving()
-	AceGUI:ClearFocus()
-end
-
-local function MoverSizer_OnMouseUp(mover)
-	local frame = mover:GetParent()
-	frame:StopMovingOrSizing()
-	local self = frame.obj
-	local status = self.status or self.localstatus
-	status.width = frame:GetWidth()
-	status.height = frame:GetHeight()
-	status.top = frame:GetTop()
-	status.left = frame:GetLeft()
-end
-
-local function SizerSE_OnMouseDown(frame)
-	frame:GetParent():StartSizing("BOTTOMRIGHT")
-	AceGUI:ClearFocus()
-end
-
-local function SizerS_OnMouseDown(frame)
-	frame:GetParent():StartSizing("BOTTOM")
-	AceGUI:ClearFocus()
-end
-
-local function SizerE_OnMouseDown(frame)
-	frame:GetParent():StartSizing("RIGHT")
-	AceGUI:ClearFocus()
-end
-
-local function StatusBar_OnEnter(frame)
-	frame.obj:Fire("OnEnterStatusBar")
-end
-
-local function StatusBar_OnLeave(frame)
-	frame.obj:Fire("OnLeaveStatusBar")
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self.frame:SetParent(UIParent)
-		self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
-		self.frame:SetFrameLevel(100) -- Lots of room to draw under it
-		self:SetTitle()
-		self:SetStatusText()
-		self:ApplyStatus()
-		self:Show()
-        self:EnableResize(true)
-	end,
-
-	["OnRelease"] = function(self)
-		self.status = nil
-		wipe(self.localstatus)
-	end,
-
-	["OnWidthSet"] = function(self, width)
-		local content = self.content
-		local contentwidth = width - 34
-		if contentwidth < 0 then
-			contentwidth = 0
-		end
-		content:SetWidth(contentwidth)
-		content.width = contentwidth
-	end,
-
-	["OnHeightSet"] = function(self, height)
-		local content = self.content
-		local contentheight = height - 57
-		if contentheight < 0 then
-			contentheight = 0
-		end
-		content:SetHeight(contentheight)
-		content.height = contentheight
-	end,
-
-	["SetTitle"] = function(self, title)
-		self.titletext:SetText(title)
-		self.titlebg:SetWidth((self.titletext:GetWidth() or 0) + 10)
-	end,
-
-	["SetStatusText"] = function(self, text)
-		self.statustext:SetText(text)
-	end,
-
-	["Hide"] = function(self)
-		self.frame:Hide()
-	end,
-
-	["Show"] = function(self)
-		self.frame:Show()
-	end,
-
-	["EnableResize"] = function(self, state)
-		local func = state and "Show" or "Hide"
-		self.sizer_se[func](self.sizer_se)
-		self.sizer_s[func](self.sizer_s)
-		self.sizer_e[func](self.sizer_e)
-	end,
-
-	-- called to set an external table to store status in
-	["SetStatusTable"] = function(self, status)
-		assert(type(status) == "table")
-		self.status = status
-		self:ApplyStatus()
-	end,
-
-	["ApplyStatus"] = function(self)
-		local status = self.status or self.localstatus
-		local frame = self.frame
-		self:SetWidth(status.width or 700)
-		self:SetHeight(status.height or 500)
-		frame:ClearAllPoints()
-		if status.top and status.left then
-			frame:SetPoint("TOP", UIParent, "BOTTOM", 0, status.top)
-			frame:SetPoint("LEFT", UIParent, "LEFT", status.left, 0)
-		else
-			frame:SetPoint("CENTER")
-		end
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local FrameBackdrop = {
-	bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
-	edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
-	tile = true, tileSize = 32, edgeSize = 32,
-	insets = { left = 8, right = 8, top = 8, bottom = 8 }
-}
-
-local PaneBackdrop  = {
-	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
-	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
-	tile = true, tileSize = 16, edgeSize = 16,
-	insets = { left = 3, right = 3, top = 5, bottom = 3 }
-}
-
-local function Constructor()
-	local frame = CreateFrame("Frame", nil, UIParent, "BackdropTemplate")
-	frame:Hide()
-
-	frame:EnableMouse(true)
-	frame:SetMovable(true)
-	frame:SetResizable(true)
-	frame:SetFrameStrata("FULLSCREEN_DIALOG")
-	frame:SetFrameLevel(100) -- Lots of room to draw under it
-	frame:SetBackdrop(FrameBackdrop)
-	frame:SetBackdropColor(0, 0, 0, 1)
-	if frame.SetResizeBounds then -- WoW 10.0
-		frame:SetResizeBounds(400, 200)
-	else
-		frame:SetMinResize(400, 200)
-	end
-	frame:SetToplevel(true)
-	frame:SetScript("OnShow", Frame_OnShow)
-	frame:SetScript("OnHide", Frame_OnClose)
-	frame:SetScript("OnMouseDown", Frame_OnMouseDown)
-
-	local closebutton = CreateFrame("Button", nil, frame, "UIPanelButtonTemplate")
-	closebutton:SetScript("OnClick", Button_OnClick)
-	closebutton:SetPoint("BOTTOMRIGHT", -27, 17)
-	closebutton:SetHeight(20)
-	closebutton:SetWidth(100)
-	closebutton:SetText(CLOSE)
-
-	local statusbg = CreateFrame("Button", nil, frame, "BackdropTemplate")
-	statusbg:SetPoint("BOTTOMLEFT", 15, 15)
-	statusbg:SetPoint("BOTTOMRIGHT", -132, 15)
-	statusbg:SetHeight(24)
-	statusbg:SetBackdrop(PaneBackdrop)
-	statusbg:SetBackdropColor(0.1,0.1,0.1)
-	statusbg:SetBackdropBorderColor(0.4,0.4,0.4)
-	statusbg:SetScript("OnEnter", StatusBar_OnEnter)
-	statusbg:SetScript("OnLeave", StatusBar_OnLeave)
-
-	local statustext = statusbg:CreateFontString(nil, "OVERLAY", "GameFontNormal")
-	statustext:SetPoint("TOPLEFT", 7, -2)
-	statustext:SetPoint("BOTTOMRIGHT", -7, 2)
-	statustext:SetHeight(20)
-	statustext:SetJustifyH("LEFT")
-	statustext:SetText("")
-
-	local titlebg = frame:CreateTexture(nil, "OVERLAY")
-	titlebg:SetTexture(131080) -- Interface\\DialogFrame\\UI-DialogBox-Header
-	titlebg:SetTexCoord(0.31, 0.67, 0, 0.63)
-	titlebg:SetPoint("TOP", 0, 12)
-	titlebg:SetWidth(100)
-	titlebg:SetHeight(40)
-
-	local title = CreateFrame("Frame", nil, frame)
-	title:EnableMouse(true)
-	title:SetScript("OnMouseDown", Title_OnMouseDown)
-	title:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
-	title:SetAllPoints(titlebg)
-
-	local titletext = title:CreateFontString(nil, "OVERLAY", "GameFontNormal")
-	titletext:SetPoint("TOP", titlebg, "TOP", 0, -14)
-
-	local titlebg_l = frame:CreateTexture(nil, "OVERLAY")
-	titlebg_l:SetTexture(131080) -- Interface\\DialogFrame\\UI-DialogBox-Header
-	titlebg_l:SetTexCoord(0.21, 0.31, 0, 0.63)
-	titlebg_l:SetPoint("RIGHT", titlebg, "LEFT")
-	titlebg_l:SetWidth(30)
-	titlebg_l:SetHeight(40)
-
-	local titlebg_r = frame:CreateTexture(nil, "OVERLAY")
-	titlebg_r:SetTexture(131080) -- Interface\\DialogFrame\\UI-DialogBox-Header
-	titlebg_r:SetTexCoord(0.67, 0.77, 0, 0.63)
-	titlebg_r:SetPoint("LEFT", titlebg, "RIGHT")
-	titlebg_r:SetWidth(30)
-	titlebg_r:SetHeight(40)
-
-	local sizer_se = CreateFrame("Frame", nil, frame)
-	sizer_se:SetPoint("BOTTOMRIGHT")
-	sizer_se:SetWidth(25)
-	sizer_se:SetHeight(25)
-	sizer_se:EnableMouse()
-	sizer_se:SetScript("OnMouseDown",SizerSE_OnMouseDown)
-	sizer_se:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
-
-	local line1 = sizer_se:CreateTexture(nil, "BACKGROUND")
-	line1:SetWidth(14)
-	line1:SetHeight(14)
-	line1:SetPoint("BOTTOMRIGHT", -8, 8)
-	line1:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
-	local x = 0.1 * 14/17
-	line1:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)
-
-	local line2 = sizer_se:CreateTexture(nil, "BACKGROUND")
-	line2:SetWidth(8)
-	line2:SetHeight(8)
-	line2:SetPoint("BOTTOMRIGHT", -8, 8)
-	line2:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
-	x = 0.1 * 8/17
-	line2:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)
-
-	local sizer_s = CreateFrame("Frame", nil, frame)
-	sizer_s:SetPoint("BOTTOMRIGHT", -25, 0)
-	sizer_s:SetPoint("BOTTOMLEFT")
-	sizer_s:SetHeight(25)
-	sizer_s:EnableMouse(true)
-	sizer_s:SetScript("OnMouseDown", SizerS_OnMouseDown)
-	sizer_s:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
-
-	local sizer_e = CreateFrame("Frame", nil, frame)
-	sizer_e:SetPoint("BOTTOMRIGHT", 0, 25)
-	sizer_e:SetPoint("TOPRIGHT")
-	sizer_e:SetWidth(25)
-	sizer_e:EnableMouse(true)
-	sizer_e:SetScript("OnMouseDown", SizerE_OnMouseDown)
-	sizer_e:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
-
-	--Container Support
-	local content = CreateFrame("Frame", nil, frame)
-	content:SetPoint("TOPLEFT", 17, -27)
-	content:SetPoint("BOTTOMRIGHT", -17, 40)
-
-	local widget = {
-		localstatus = {},
-		titletext   = titletext,
-		statustext  = statustext,
-		titlebg     = titlebg,
-		sizer_se    = sizer_se,
-		sizer_s     = sizer_s,
-		sizer_e     = sizer_e,
-		content     = content,
-		frame       = frame,
-		type        = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-	closebutton.obj, statusbg.obj = widget, widget
-
-	return AceGUI:RegisterAsContainer(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+Frame Container
+-------------------------------------------------------------------------------]]
+local Type, Version = "Frame", 30
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs, assert, type = pairs, assert, type
+local wipe = table.wipe
+
+-- WoW APIs
+local PlaySound = PlaySound
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Button_OnClick(frame)
+	PlaySound(799) -- SOUNDKIT.GS_TITLE_OPTION_EXIT
+	frame.obj:Hide()
+end
+
+local function Frame_OnShow(frame)
+	frame.obj:Fire("OnShow")
+end
+
+local function Frame_OnClose(frame)
+	frame.obj:Fire("OnClose")
+end
+
+local function Frame_OnMouseDown(frame)
+	AceGUI:ClearFocus()
+end
+
+local function Title_OnMouseDown(frame)
+	frame:GetParent():StartMoving()
+	AceGUI:ClearFocus()
+end
+
+local function MoverSizer_OnMouseUp(mover)
+	local frame = mover:GetParent()
+	frame:StopMovingOrSizing()
+	local self = frame.obj
+	local status = self.status or self.localstatus
+	status.width = frame:GetWidth()
+	status.height = frame:GetHeight()
+	status.top = frame:GetTop()
+	status.left = frame:GetLeft()
+end
+
+local function SizerSE_OnMouseDown(frame)
+	frame:GetParent():StartSizing("BOTTOMRIGHT")
+	AceGUI:ClearFocus()
+end
+
+local function SizerS_OnMouseDown(frame)
+	frame:GetParent():StartSizing("BOTTOM")
+	AceGUI:ClearFocus()
+end
+
+local function SizerE_OnMouseDown(frame)
+	frame:GetParent():StartSizing("RIGHT")
+	AceGUI:ClearFocus()
+end
+
+local function StatusBar_OnEnter(frame)
+	frame.obj:Fire("OnEnterStatusBar")
+end
+
+local function StatusBar_OnLeave(frame)
+	frame.obj:Fire("OnLeaveStatusBar")
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self.frame:SetParent(UIParent)
+		self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
+		self.frame:SetFrameLevel(100) -- Lots of room to draw under it
+		self:SetTitle()
+		self:SetStatusText()
+		self:ApplyStatus()
+		self:Show()
+        self:EnableResize(true)
+	end,
+
+	["OnRelease"] = function(self)
+		self.status = nil
+		wipe(self.localstatus)
+	end,
+
+	["OnWidthSet"] = function(self, width)
+		local content = self.content
+		local contentwidth = width - 34
+		if contentwidth < 0 then
+			contentwidth = 0
+		end
+		content:SetWidth(contentwidth)
+		content.width = contentwidth
+	end,
+
+	["OnHeightSet"] = function(self, height)
+		local content = self.content
+		local contentheight = height - 57
+		if contentheight < 0 then
+			contentheight = 0
+		end
+		content:SetHeight(contentheight)
+		content.height = contentheight
+	end,
+
+	["SetTitle"] = function(self, title)
+		self.titletext:SetText(title)
+		self.titlebg:SetWidth((self.titletext:GetWidth() or 0) + 10)
+	end,
+
+	["SetStatusText"] = function(self, text)
+		self.statustext:SetText(text)
+	end,
+
+	["Hide"] = function(self)
+		self.frame:Hide()
+	end,
+
+	["Show"] = function(self)
+		self.frame:Show()
+	end,
+
+	["EnableResize"] = function(self, state)
+		local func = state and "Show" or "Hide"
+		self.sizer_se[func](self.sizer_se)
+		self.sizer_s[func](self.sizer_s)
+		self.sizer_e[func](self.sizer_e)
+	end,
+
+	-- called to set an external table to store status in
+	["SetStatusTable"] = function(self, status)
+		assert(type(status) == "table")
+		self.status = status
+		self:ApplyStatus()
+	end,
+
+	["ApplyStatus"] = function(self)
+		local status = self.status or self.localstatus
+		local frame = self.frame
+		self:SetWidth(status.width or 700)
+		self:SetHeight(status.height or 500)
+		frame:ClearAllPoints()
+		if status.top and status.left then
+			frame:SetPoint("TOP", UIParent, "BOTTOM", 0, status.top)
+			frame:SetPoint("LEFT", UIParent, "LEFT", status.left, 0)
+		else
+			frame:SetPoint("CENTER")
+		end
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local FrameBackdrop = {
+	bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
+	edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
+	tile = true, tileSize = 32, edgeSize = 32,
+	insets = { left = 8, right = 8, top = 8, bottom = 8 }
+}
+
+local PaneBackdrop  = {
+	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
+	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
+	tile = true, tileSize = 16, edgeSize = 16,
+	insets = { left = 3, right = 3, top = 5, bottom = 3 }
+}
+
+local function Constructor()
+	local frame = CreateFrame("Frame", nil, UIParent, "BackdropTemplate")
+	frame:Hide()
+
+	frame:EnableMouse(true)
+	frame:SetMovable(true)
+	frame:SetResizable(true)
+	frame:SetFrameStrata("FULLSCREEN_DIALOG")
+	frame:SetFrameLevel(100) -- Lots of room to draw under it
+	frame:SetBackdrop(FrameBackdrop)
+	frame:SetBackdropColor(0, 0, 0, 1)
+	if frame.SetResizeBounds then -- WoW 10.0
+		frame:SetResizeBounds(400, 200)
+	else
+		frame:SetMinResize(400, 200)
+	end
+	frame:SetToplevel(true)
+	frame:SetScript("OnShow", Frame_OnShow)
+	frame:SetScript("OnHide", Frame_OnClose)
+	frame:SetScript("OnMouseDown", Frame_OnMouseDown)
+
+	local closebutton = CreateFrame("Button", nil, frame, "UIPanelButtonTemplate")
+	closebutton:SetScript("OnClick", Button_OnClick)
+	closebutton:SetPoint("BOTTOMRIGHT", -27, 17)
+	closebutton:SetHeight(20)
+	closebutton:SetWidth(100)
+	closebutton:SetText(CLOSE)
+
+	local statusbg = CreateFrame("Button", nil, frame, "BackdropTemplate")
+	statusbg:SetPoint("BOTTOMLEFT", 15, 15)
+	statusbg:SetPoint("BOTTOMRIGHT", -132, 15)
+	statusbg:SetHeight(24)
+	statusbg:SetBackdrop(PaneBackdrop)
+	statusbg:SetBackdropColor(0.1,0.1,0.1)
+	statusbg:SetBackdropBorderColor(0.4,0.4,0.4)
+	statusbg:SetScript("OnEnter", StatusBar_OnEnter)
+	statusbg:SetScript("OnLeave", StatusBar_OnLeave)
+
+	local statustext = statusbg:CreateFontString(nil, "OVERLAY", "GameFontNormal")
+	statustext:SetPoint("TOPLEFT", 7, -2)
+	statustext:SetPoint("BOTTOMRIGHT", -7, 2)
+	statustext:SetHeight(20)
+	statustext:SetJustifyH("LEFT")
+	statustext:SetText("")
+
+	local titlebg = frame:CreateTexture(nil, "OVERLAY")
+	titlebg:SetTexture(131080) -- Interface\\DialogFrame\\UI-DialogBox-Header
+	titlebg:SetTexCoord(0.31, 0.67, 0, 0.63)
+	titlebg:SetPoint("TOP", 0, 12)
+	titlebg:SetWidth(100)
+	titlebg:SetHeight(40)
+
+	local title = CreateFrame("Frame", nil, frame)
+	title:EnableMouse(true)
+	title:SetScript("OnMouseDown", Title_OnMouseDown)
+	title:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
+	title:SetAllPoints(titlebg)
+
+	local titletext = title:CreateFontString(nil, "OVERLAY", "GameFontNormal")
+	titletext:SetPoint("TOP", titlebg, "TOP", 0, -14)
+
+	local titlebg_l = frame:CreateTexture(nil, "OVERLAY")
+	titlebg_l:SetTexture(131080) -- Interface\\DialogFrame\\UI-DialogBox-Header
+	titlebg_l:SetTexCoord(0.21, 0.31, 0, 0.63)
+	titlebg_l:SetPoint("RIGHT", titlebg, "LEFT")
+	titlebg_l:SetWidth(30)
+	titlebg_l:SetHeight(40)
+
+	local titlebg_r = frame:CreateTexture(nil, "OVERLAY")
+	titlebg_r:SetTexture(131080) -- Interface\\DialogFrame\\UI-DialogBox-Header
+	titlebg_r:SetTexCoord(0.67, 0.77, 0, 0.63)
+	titlebg_r:SetPoint("LEFT", titlebg, "RIGHT")
+	titlebg_r:SetWidth(30)
+	titlebg_r:SetHeight(40)
+
+	local sizer_se = CreateFrame("Frame", nil, frame)
+	sizer_se:SetPoint("BOTTOMRIGHT")
+	sizer_se:SetWidth(25)
+	sizer_se:SetHeight(25)
+	sizer_se:EnableMouse()
+	sizer_se:SetScript("OnMouseDown",SizerSE_OnMouseDown)
+	sizer_se:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
+
+	local line1 = sizer_se:CreateTexture(nil, "BACKGROUND")
+	line1:SetWidth(14)
+	line1:SetHeight(14)
+	line1:SetPoint("BOTTOMRIGHT", -8, 8)
+	line1:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
+	local x = 0.1 * 14/17
+	line1:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)
+
+	local line2 = sizer_se:CreateTexture(nil, "BACKGROUND")
+	line2:SetWidth(8)
+	line2:SetHeight(8)
+	line2:SetPoint("BOTTOMRIGHT", -8, 8)
+	line2:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
+	x = 0.1 * 8/17
+	line2:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)
+
+	local sizer_s = CreateFrame("Frame", nil, frame)
+	sizer_s:SetPoint("BOTTOMRIGHT", -25, 0)
+	sizer_s:SetPoint("BOTTOMLEFT")
+	sizer_s:SetHeight(25)
+	sizer_s:EnableMouse(true)
+	sizer_s:SetScript("OnMouseDown", SizerS_OnMouseDown)
+	sizer_s:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
+
+	local sizer_e = CreateFrame("Frame", nil, frame)
+	sizer_e:SetPoint("BOTTOMRIGHT", 0, 25)
+	sizer_e:SetPoint("TOPRIGHT")
+	sizer_e:SetWidth(25)
+	sizer_e:EnableMouse(true)
+	sizer_e:SetScript("OnMouseDown", SizerE_OnMouseDown)
+	sizer_e:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
+
+	--Container Support
+	local content = CreateFrame("Frame", nil, frame)
+	content:SetPoint("TOPLEFT", 17, -27)
+	content:SetPoint("BOTTOMRIGHT", -17, 40)
+
+	local widget = {
+		localstatus = {},
+		titletext   = titletext,
+		statustext  = statustext,
+		titlebg     = titlebg,
+		sizer_se    = sizer_se,
+		sizer_s     = sizer_s,
+		sizer_e     = sizer_e,
+		content     = content,
+		frame       = frame,
+		type        = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+	closebutton.obj, statusbg.obj = widget, widget
+
+	return AceGUI:RegisterAsContainer(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-InlineGroup.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-InlineGroup.lua
index 04b4d5d..1676ae4 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-InlineGroup.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-InlineGroup.lua
@@ -1,103 +1,103 @@
---[[-----------------------------------------------------------------------------
-InlineGroup Container
-Simple container widget that creates a visible "box" with an optional title.
--------------------------------------------------------------------------------]]
-local Type, Version = "InlineGroup", 22
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs = pairs
-
--- WoW APIs
-local CreateFrame, UIParent = CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetWidth(300)
-		self:SetHeight(100)
-		self:SetTitle("")
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["SetTitle"] = function(self,title)
-		self.titletext:SetText(title)
-	end,
-
-
-	["LayoutFinished"] = function(self, width, height)
-		if self.noAutoHeight then return end
-		self:SetHeight((height or 0) + 40)
-	end,
-
-	["OnWidthSet"] = function(self, width)
-		local content = self.content
-		local contentwidth = width - 20
-		if contentwidth < 0 then
-			contentwidth = 0
-		end
-		content:SetWidth(contentwidth)
-		content.width = contentwidth
-	end,
-
-	["OnHeightSet"] = function(self, height)
-		local content = self.content
-		local contentheight = height - 20
-		if contentheight < 0 then
-			contentheight = 0
-		end
-		content:SetHeight(contentheight)
-		content.height = contentheight
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local PaneBackdrop  = {
-	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
-	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
-	tile = true, tileSize = 16, edgeSize = 16,
-	insets = { left = 3, right = 3, top = 5, bottom = 3 }
-}
-
-local function Constructor()
-	local frame = CreateFrame("Frame", nil, UIParent)
-	frame:SetFrameStrata("FULLSCREEN_DIALOG")
-
-	local titletext = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
-	titletext:SetPoint("TOPLEFT", 14, 0)
-	titletext:SetPoint("TOPRIGHT", -14, 0)
-	titletext:SetJustifyH("LEFT")
-	titletext:SetHeight(18)
-
-	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
-	border:SetPoint("TOPLEFT", 0, -17)
-	border:SetPoint("BOTTOMRIGHT", -1, 3)
-	border:SetBackdrop(PaneBackdrop)
-	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
-	border:SetBackdropBorderColor(0.4, 0.4, 0.4)
-
-	--Container Support
-	local content = CreateFrame("Frame", nil, border)
-	content:SetPoint("TOPLEFT", 10, -10)
-	content:SetPoint("BOTTOMRIGHT", -10, 10)
-
-	local widget = {
-		frame     = frame,
-		content   = content,
-		titletext = titletext,
-		type      = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	return AceGUI:RegisterAsContainer(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+InlineGroup Container
+Simple container widget that creates a visible "box" with an optional title.
+-------------------------------------------------------------------------------]]
+local Type, Version = "InlineGroup", 22
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs = pairs
+
+-- WoW APIs
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetWidth(300)
+		self:SetHeight(100)
+		self:SetTitle("")
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["SetTitle"] = function(self,title)
+		self.titletext:SetText(title)
+	end,
+
+
+	["LayoutFinished"] = function(self, width, height)
+		if self.noAutoHeight then return end
+		self:SetHeight((height or 0) + 40)
+	end,
+
+	["OnWidthSet"] = function(self, width)
+		local content = self.content
+		local contentwidth = width - 20
+		if contentwidth < 0 then
+			contentwidth = 0
+		end
+		content:SetWidth(contentwidth)
+		content.width = contentwidth
+	end,
+
+	["OnHeightSet"] = function(self, height)
+		local content = self.content
+		local contentheight = height - 20
+		if contentheight < 0 then
+			contentheight = 0
+		end
+		content:SetHeight(contentheight)
+		content.height = contentheight
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local PaneBackdrop  = {
+	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
+	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
+	tile = true, tileSize = 16, edgeSize = 16,
+	insets = { left = 3, right = 3, top = 5, bottom = 3 }
+}
+
+local function Constructor()
+	local frame = CreateFrame("Frame", nil, UIParent)
+	frame:SetFrameStrata("FULLSCREEN_DIALOG")
+
+	local titletext = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
+	titletext:SetPoint("TOPLEFT", 14, 0)
+	titletext:SetPoint("TOPRIGHT", -14, 0)
+	titletext:SetJustifyH("LEFT")
+	titletext:SetHeight(18)
+
+	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
+	border:SetPoint("TOPLEFT", 0, -17)
+	border:SetPoint("BOTTOMRIGHT", -1, 3)
+	border:SetBackdrop(PaneBackdrop)
+	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
+	border:SetBackdropBorderColor(0.4, 0.4, 0.4)
+
+	--Container Support
+	local content = CreateFrame("Frame", nil, border)
+	content:SetPoint("TOPLEFT", 10, -10)
+	content:SetPoint("BOTTOMRIGHT", -10, 10)
+
+	local widget = {
+		frame     = frame,
+		content   = content,
+		titletext = titletext,
+		type      = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	return AceGUI:RegisterAsContainer(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-ScrollFrame.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-ScrollFrame.lua
index be6052f..d110d03 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-ScrollFrame.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-ScrollFrame.lua
@@ -1,215 +1,215 @@
---[[-----------------------------------------------------------------------------
-ScrollFrame Container
-Plain container that scrolls its content and doesn't grow in height.
--------------------------------------------------------------------------------]]
-local Type, Version = "ScrollFrame", 26
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs, assert, type = pairs, assert, type
-local min, max, floor = math.min, math.max, math.floor
-
--- WoW APIs
-local CreateFrame, UIParent = CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-local function FixScrollOnUpdate(frame)
-	frame:SetScript("OnUpdate", nil)
-	frame.obj:FixScroll()
-end
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function ScrollFrame_OnMouseWheel(frame, value)
-	frame.obj:MoveScroll(value)
-end
-
-local function ScrollFrame_OnSizeChanged(frame)
-	frame:SetScript("OnUpdate", FixScrollOnUpdate)
-end
-
-local function ScrollBar_OnScrollValueChanged(frame, value)
-	frame.obj:SetScroll(value)
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetScroll(0)
-		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
-	end,
-
-	["OnRelease"] = function(self)
-		self.status = nil
-		for k in pairs(self.localstatus) do
-			self.localstatus[k] = nil
-		end
-		self.scrollframe:SetPoint("BOTTOMRIGHT")
-		self.scrollbar:Hide()
-		self.scrollBarShown = nil
-		self.content.height, self.content.width, self.content.original_width = nil, nil, nil
-	end,
-
-	["SetScroll"] = function(self, value)
-		local status = self.status or self.localstatus
-		local viewheight = self.scrollframe:GetHeight()
-		local height = self.content:GetHeight()
-		local offset
-
-		if viewheight > height then
-			offset = 0
-		else
-			offset = floor((height - viewheight) / 1000.0 * value)
-		end
-		self.content:ClearAllPoints()
-		self.content:SetPoint("TOPLEFT", 0, offset)
-		self.content:SetPoint("TOPRIGHT", 0, offset)
-		status.offset = offset
-		status.scrollvalue = value
-	end,
-
-	["MoveScroll"] = function(self, value)
-		local status = self.status or self.localstatus
-		local height, viewheight = self.scrollframe:GetHeight(), self.content:GetHeight()
-
-		if self.scrollBarShown then
-			local diff = height - viewheight
-			local delta = 1
-			if value < 0 then
-				delta = -1
-			end
-			self.scrollbar:SetValue(min(max(status.scrollvalue + delta*(1000/(diff/45)),0), 1000))
-		end
-	end,
-
-	["FixScroll"] = function(self)
-		if self.updateLock then return end
-		self.updateLock = true
-		local status = self.status or self.localstatus
-		local height, viewheight = self.scrollframe:GetHeight(), self.content:GetHeight()
-		local offset = status.offset or 0
-		-- Give us a margin of error of 2 pixels to stop some conditions that i would blame on floating point inaccuracys
-		-- No-one is going to miss 2 pixels at the bottom of the frame, anyhow!
-		if viewheight < height + 2 then
-			if self.scrollBarShown then
-				self.scrollBarShown = nil
-				self.scrollbar:Hide()
-				self.scrollbar:SetValue(0)
-				self.scrollframe:SetPoint("BOTTOMRIGHT")
-				if self.content.original_width then
-					self.content.width = self.content.original_width
-				end
-				self:DoLayout()
-			end
-		else
-			if not self.scrollBarShown then
-				self.scrollBarShown = true
-				self.scrollbar:Show()
-				self.scrollframe:SetPoint("BOTTOMRIGHT", -20, 0)
-				if self.content.original_width then
-					self.content.width = self.content.original_width - 20
-				end
-				self:DoLayout()
-			end
-			local value = (offset / (viewheight - height) * 1000)
-			if value > 1000 then value = 1000 end
-			self.scrollbar:SetValue(value)
-			self:SetScroll(value)
-			if value < 1000 then
-				self.content:ClearAllPoints()
-				self.content:SetPoint("TOPLEFT", 0, offset)
-				self.content:SetPoint("TOPRIGHT", 0, offset)
-				status.offset = offset
-			end
-		end
-		self.updateLock = nil
-	end,
-
-	["LayoutFinished"] = function(self, width, height)
-		self.content:SetHeight(height or 0 + 20)
-
-		-- update the scrollframe
-		self:FixScroll()
-
-		-- schedule another update when everything has "settled"
-		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
-	end,
-
-	["SetStatusTable"] = function(self, status)
-		assert(type(status) == "table")
-		self.status = status
-		if not status.scrollvalue then
-			status.scrollvalue = 0
-		end
-	end,
-
-	["OnWidthSet"] = function(self, width)
-		local content = self.content
-		content.width = width - (self.scrollBarShown and 20 or 0)
-		content.original_width = width
-	end,
-
-	["OnHeightSet"] = function(self, height)
-		local content = self.content
-		content.height = height
-	end
-}
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local frame = CreateFrame("Frame", nil, UIParent)
-	local num = AceGUI:GetNextWidgetNum(Type)
-
-	local scrollframe = CreateFrame("ScrollFrame", nil, frame)
-	scrollframe:SetPoint("TOPLEFT")
-	scrollframe:SetPoint("BOTTOMRIGHT")
-	scrollframe:EnableMouseWheel(true)
-	scrollframe:SetScript("OnMouseWheel", ScrollFrame_OnMouseWheel)
-	scrollframe:SetScript("OnSizeChanged", ScrollFrame_OnSizeChanged)
-
-	local scrollbar = CreateFrame("Slider", ("AceConfigDialogScrollFrame%dScrollBar"):format(num), scrollframe, "UIPanelScrollBarTemplate")
-	scrollbar:SetPoint("TOPLEFT", scrollframe, "TOPRIGHT", 4, -16)
-	scrollbar:SetPoint("BOTTOMLEFT", scrollframe, "BOTTOMRIGHT", 4, 16)
-	scrollbar:SetMinMaxValues(0, 1000)
-	scrollbar:SetValueStep(1)
-	scrollbar:SetValue(0)
-	scrollbar:SetWidth(16)
-	scrollbar:Hide()
-	-- set the script as the last step, so it doesn't fire yet
-	scrollbar:SetScript("OnValueChanged", ScrollBar_OnScrollValueChanged)
-
-	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
-	scrollbg:SetAllPoints(scrollbar)
-	scrollbg:SetColorTexture(0, 0, 0, 0.4)
-
-	--Container Support
-	local content = CreateFrame("Frame", nil, scrollframe)
-	content:SetPoint("TOPLEFT")
-	content:SetPoint("TOPRIGHT")
-	content:SetHeight(400)
-	scrollframe:SetScrollChild(content)
-
-	local widget = {
-		localstatus = { scrollvalue = 0 },
-		scrollframe = scrollframe,
-		scrollbar   = scrollbar,
-		content     = content,
-		frame       = frame,
-		type        = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-	scrollframe.obj, scrollbar.obj = widget, widget
-
-	return AceGUI:RegisterAsContainer(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+ScrollFrame Container
+Plain container that scrolls its content and doesn't grow in height.
+-------------------------------------------------------------------------------]]
+local Type, Version = "ScrollFrame", 26
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs, assert, type = pairs, assert, type
+local min, max, floor = math.min, math.max, math.floor
+
+-- WoW APIs
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+local function FixScrollOnUpdate(frame)
+	frame:SetScript("OnUpdate", nil)
+	frame.obj:FixScroll()
+end
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function ScrollFrame_OnMouseWheel(frame, value)
+	frame.obj:MoveScroll(value)
+end
+
+local function ScrollFrame_OnSizeChanged(frame)
+	frame:SetScript("OnUpdate", FixScrollOnUpdate)
+end
+
+local function ScrollBar_OnScrollValueChanged(frame, value)
+	frame.obj:SetScroll(value)
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetScroll(0)
+		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
+	end,
+
+	["OnRelease"] = function(self)
+		self.status = nil
+		for k in pairs(self.localstatus) do
+			self.localstatus[k] = nil
+		end
+		self.scrollframe:SetPoint("BOTTOMRIGHT")
+		self.scrollbar:Hide()
+		self.scrollBarShown = nil
+		self.content.height, self.content.width, self.content.original_width = nil, nil, nil
+	end,
+
+	["SetScroll"] = function(self, value)
+		local status = self.status or self.localstatus
+		local viewheight = self.scrollframe:GetHeight()
+		local height = self.content:GetHeight()
+		local offset
+
+		if viewheight > height then
+			offset = 0
+		else
+			offset = floor((height - viewheight) / 1000.0 * value)
+		end
+		self.content:ClearAllPoints()
+		self.content:SetPoint("TOPLEFT", 0, offset)
+		self.content:SetPoint("TOPRIGHT", 0, offset)
+		status.offset = offset
+		status.scrollvalue = value
+	end,
+
+	["MoveScroll"] = function(self, value)
+		local status = self.status or self.localstatus
+		local height, viewheight = self.scrollframe:GetHeight(), self.content:GetHeight()
+
+		if self.scrollBarShown then
+			local diff = height - viewheight
+			local delta = 1
+			if value < 0 then
+				delta = -1
+			end
+			self.scrollbar:SetValue(min(max(status.scrollvalue + delta*(1000/(diff/45)),0), 1000))
+		end
+	end,
+
+	["FixScroll"] = function(self)
+		if self.updateLock then return end
+		self.updateLock = true
+		local status = self.status or self.localstatus
+		local height, viewheight = self.scrollframe:GetHeight(), self.content:GetHeight()
+		local offset = status.offset or 0
+		-- Give us a margin of error of 2 pixels to stop some conditions that i would blame on floating point inaccuracys
+		-- No-one is going to miss 2 pixels at the bottom of the frame, anyhow!
+		if viewheight < height + 2 then
+			if self.scrollBarShown then
+				self.scrollBarShown = nil
+				self.scrollbar:Hide()
+				self.scrollbar:SetValue(0)
+				self.scrollframe:SetPoint("BOTTOMRIGHT")
+				if self.content.original_width then
+					self.content.width = self.content.original_width
+				end
+				self:DoLayout()
+			end
+		else
+			if not self.scrollBarShown then
+				self.scrollBarShown = true
+				self.scrollbar:Show()
+				self.scrollframe:SetPoint("BOTTOMRIGHT", -20, 0)
+				if self.content.original_width then
+					self.content.width = self.content.original_width - 20
+				end
+				self:DoLayout()
+			end
+			local value = (offset / (viewheight - height) * 1000)
+			if value > 1000 then value = 1000 end
+			self.scrollbar:SetValue(value)
+			self:SetScroll(value)
+			if value < 1000 then
+				self.content:ClearAllPoints()
+				self.content:SetPoint("TOPLEFT", 0, offset)
+				self.content:SetPoint("TOPRIGHT", 0, offset)
+				status.offset = offset
+			end
+		end
+		self.updateLock = nil
+	end,
+
+	["LayoutFinished"] = function(self, width, height)
+		self.content:SetHeight(height or 0 + 20)
+
+		-- update the scrollframe
+		self:FixScroll()
+
+		-- schedule another update when everything has "settled"
+		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
+	end,
+
+	["SetStatusTable"] = function(self, status)
+		assert(type(status) == "table")
+		self.status = status
+		if not status.scrollvalue then
+			status.scrollvalue = 0
+		end
+	end,
+
+	["OnWidthSet"] = function(self, width)
+		local content = self.content
+		content.width = width - (self.scrollBarShown and 20 or 0)
+		content.original_width = width
+	end,
+
+	["OnHeightSet"] = function(self, height)
+		local content = self.content
+		content.height = height
+	end
+}
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local frame = CreateFrame("Frame", nil, UIParent)
+	local num = AceGUI:GetNextWidgetNum(Type)
+
+	local scrollframe = CreateFrame("ScrollFrame", nil, frame)
+	scrollframe:SetPoint("TOPLEFT")
+	scrollframe:SetPoint("BOTTOMRIGHT")
+	scrollframe:EnableMouseWheel(true)
+	scrollframe:SetScript("OnMouseWheel", ScrollFrame_OnMouseWheel)
+	scrollframe:SetScript("OnSizeChanged", ScrollFrame_OnSizeChanged)
+
+	local scrollbar = CreateFrame("Slider", ("AceConfigDialogScrollFrame%dScrollBar"):format(num), scrollframe, "UIPanelScrollBarTemplate")
+	scrollbar:SetPoint("TOPLEFT", scrollframe, "TOPRIGHT", 4, -16)
+	scrollbar:SetPoint("BOTTOMLEFT", scrollframe, "BOTTOMRIGHT", 4, 16)
+	scrollbar:SetMinMaxValues(0, 1000)
+	scrollbar:SetValueStep(1)
+	scrollbar:SetValue(0)
+	scrollbar:SetWidth(16)
+	scrollbar:Hide()
+	-- set the script as the last step, so it doesn't fire yet
+	scrollbar:SetScript("OnValueChanged", ScrollBar_OnScrollValueChanged)
+
+	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
+	scrollbg:SetAllPoints(scrollbar)
+	scrollbg:SetColorTexture(0, 0, 0, 0.4)
+
+	--Container Support
+	local content = CreateFrame("Frame", nil, scrollframe)
+	content:SetPoint("TOPLEFT")
+	content:SetPoint("TOPRIGHT")
+	content:SetHeight(400)
+	scrollframe:SetScrollChild(content)
+
+	local widget = {
+		localstatus = { scrollvalue = 0 },
+		scrollframe = scrollframe,
+		scrollbar   = scrollbar,
+		content     = content,
+		frame       = frame,
+		type        = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+	scrollframe.obj, scrollbar.obj = widget, widget
+
+	return AceGUI:RegisterAsContainer(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-SimpleGroup.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-SimpleGroup.lua
index 6e23abc..57512c3 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-SimpleGroup.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-SimpleGroup.lua
@@ -1,69 +1,69 @@
---[[-----------------------------------------------------------------------------
-SimpleGroup Container
-Simple container widget that just groups widgets.
--------------------------------------------------------------------------------]]
-local Type, Version = "SimpleGroup", 20
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs = pairs
-
--- WoW APIs
-local CreateFrame, UIParent = CreateFrame, UIParent
-
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetWidth(300)
-		self:SetHeight(100)
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["LayoutFinished"] = function(self, width, height)
-		if self.noAutoHeight then return end
-		self:SetHeight(height or 0)
-	end,
-
-	["OnWidthSet"] = function(self, width)
-		local content = self.content
-		content:SetWidth(width)
-		content.width = width
-	end,
-
-	["OnHeightSet"] = function(self, height)
-		local content = self.content
-		content:SetHeight(height)
-		content.height = height
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local frame = CreateFrame("Frame", nil, UIParent)
-	frame:SetFrameStrata("FULLSCREEN_DIALOG")
-
-	--Container Support
-	local content = CreateFrame("Frame", nil, frame)
-	content:SetPoint("TOPLEFT")
-	content:SetPoint("BOTTOMRIGHT")
-
-	local widget = {
-		frame     = frame,
-		content   = content,
-		type      = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	return AceGUI:RegisterAsContainer(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+SimpleGroup Container
+Simple container widget that just groups widgets.
+-------------------------------------------------------------------------------]]
+local Type, Version = "SimpleGroup", 20
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs = pairs
+
+-- WoW APIs
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetWidth(300)
+		self:SetHeight(100)
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["LayoutFinished"] = function(self, width, height)
+		if self.noAutoHeight then return end
+		self:SetHeight(height or 0)
+	end,
+
+	["OnWidthSet"] = function(self, width)
+		local content = self.content
+		content:SetWidth(width)
+		content.width = width
+	end,
+
+	["OnHeightSet"] = function(self, height)
+		local content = self.content
+		content:SetHeight(height)
+		content.height = height
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local frame = CreateFrame("Frame", nil, UIParent)
+	frame:SetFrameStrata("FULLSCREEN_DIALOG")
+
+	--Container Support
+	local content = CreateFrame("Frame", nil, frame)
+	content:SetPoint("TOPLEFT")
+	content:SetPoint("BOTTOMRIGHT")
+
+	local widget = {
+		frame     = frame,
+		content   = content,
+		type      = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	return AceGUI:RegisterAsContainer(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-TabGroup.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-TabGroup.lua
index 8a5756f..8e46876 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-TabGroup.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-TabGroup.lua
@@ -1,535 +1,535 @@
---[[-----------------------------------------------------------------------------
-TabGroup Container
-Container that uses tabs on top to switch between groups.
--------------------------------------------------------------------------------]]
-local Type, Version = "TabGroup", 38
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs, ipairs, assert, type, wipe = pairs, ipairs, assert, type, table.wipe
-
--- WoW APIs
-local PlaySound = PlaySound
-local CreateFrame, UIParent = CreateFrame, UIParent
-local _G = _G
-
--- local upvalue storage used by BuildTabs
-local widths = {}
-local rowwidths = {}
-local rowends = {}
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-
-local function PanelTemplates_TabResize(tab, padding, absoluteSize, minWidth, maxWidth, absoluteTextSize)
-	local tabName = tab:GetName();
-
-	local buttonMiddle = tab.Middle or tab.middleTexture or _G[tabName.."Middle"];
-	local buttonMiddleDisabled = tab.MiddleDisabled or (tabName and _G[tabName.."MiddleDisabled"]);
-	local left = tab.Left or tab.leftTexture or _G[tabName.."Left"];
-	local sideWidths = 2 * left:GetWidth();
-	local tabText = tab.Text or _G[tab:GetName().."Text"];
-	local highlightTexture = tab.HighlightTexture or (tabName and _G[tabName.."HighlightTexture"]);
-
-	local width, tabWidth;
-	local textWidth;
-	if ( absoluteTextSize ) then
-		textWidth = absoluteTextSize;
-	else
-		tabText:SetWidth(0);
-		textWidth = tabText:GetWidth();
-	end
-	-- If there's an absolute size specified then use it
-	if ( absoluteSize ) then
-		if ( absoluteSize < sideWidths) then
-			width = 1;
-			tabWidth = sideWidths
-		else
-			width = absoluteSize - sideWidths;
-			tabWidth = absoluteSize
-		end
-		tabText:SetWidth(width);
-	else
-		-- Otherwise try to use padding
-		if ( padding ) then
-			width = textWidth + padding;
-		else
-			width = textWidth + 24;
-		end
-		-- If greater than the maxWidth then cap it
-		if ( maxWidth and width > maxWidth ) then
-			if ( padding ) then
-				width = maxWidth + padding;
-			else
-				width = maxWidth + 24;
-			end
-			tabText:SetWidth(width);
-		else
-			tabText:SetWidth(0);
-		end
-		if (minWidth and width < minWidth) then
-			width = minWidth;
-		end
-		tabWidth = width + sideWidths;
-	end
-
-	if ( buttonMiddle ) then
-		buttonMiddle:SetWidth(width);
-	end
-	if ( buttonMiddleDisabled ) then
-		buttonMiddleDisabled:SetWidth(width);
-	end
-
-	tab:SetWidth(tabWidth);
-
-	if ( highlightTexture ) then
-		highlightTexture:SetWidth(tabWidth);
-	end
-end
-
-local function PanelTemplates_DeselectTab(tab)
-	local name = tab:GetName();
-
-	local left = tab.Left or _G[name.."Left"];
-	local middle = tab.Middle or _G[name.."Middle"];
-	local right = tab.Right or _G[name.."Right"];
-	left:Show();
-	middle:Show();
-	right:Show();
-	--tab:UnlockHighlight();
-	tab:Enable();
-	local text = tab.Text or _G[name.."Text"];
-	text:SetPoint("CENTER", tab, "CENTER", (tab.deselectedTextX or 0), (tab.deselectedTextY or 2));
-
-	local leftDisabled = tab.LeftDisabled or _G[name.."LeftDisabled"];
-	local middleDisabled = tab.MiddleDisabled or _G[name.."MiddleDisabled"];
-	local rightDisabled = tab.RightDisabled or _G[name.."RightDisabled"];
-	leftDisabled:Hide();
-	middleDisabled:Hide();
-	rightDisabled:Hide();
-end
-
-local function PanelTemplates_SelectTab(tab)
-	local name = tab:GetName();
-
-	local left = tab.Left or _G[name.."Left"];
-	local middle = tab.Middle or _G[name.."Middle"];
-	local right = tab.Right or _G[name.."Right"];
-	left:Hide();
-	middle:Hide();
-	right:Hide();
-	--tab:LockHighlight();
-	tab:Disable();
-	tab:SetDisabledFontObject(GameFontHighlightSmall);
-	local text = tab.Text or _G[name.."Text"];
-	text:SetPoint("CENTER", tab, "CENTER", (tab.selectedTextX or 0), (tab.selectedTextY or -3));
-
-	local leftDisabled = tab.LeftDisabled or _G[name.."LeftDisabled"];
-	local middleDisabled = tab.MiddleDisabled or _G[name.."MiddleDisabled"];
-	local rightDisabled = tab.RightDisabled or _G[name.."RightDisabled"];
-	leftDisabled:Show();
-	middleDisabled:Show();
-	rightDisabled:Show();
-
-	if GameTooltip:IsOwned(tab) then
-		GameTooltip:Hide();
-	end
-end
-
-local function PanelTemplates_SetDisabledTabState(tab)
-	local name = tab:GetName();
-	local left = tab.Left or _G[name.."Left"];
-	local middle = tab.Middle or _G[name.."Middle"];
-	local right = tab.Right or _G[name.."Right"];
-	left:Show();
-	middle:Show();
-	right:Show();
-	--tab:UnlockHighlight();
-	tab:Disable();
-	tab.text = tab:GetText();
-	-- Gray out text
-	tab:SetDisabledFontObject(GameFontDisableSmall);
-	local leftDisabled = tab.LeftDisabled or _G[name.."LeftDisabled"];
-	local middleDisabled = tab.MiddleDisabled or _G[name.."MiddleDisabled"];
-	local rightDisabled = tab.RightDisabled or _G[name.."RightDisabled"];
-	leftDisabled:Hide();
-	middleDisabled:Hide();
-	rightDisabled:Hide();
-end
-
-local function UpdateTabLook(frame)
-	if frame.disabled then
-		PanelTemplates_SetDisabledTabState(frame)
-	elseif frame.selected then
-		PanelTemplates_SelectTab(frame)
-	else
-		PanelTemplates_DeselectTab(frame)
-	end
-end
-
-local function Tab_SetText(frame, text)
-	frame:_SetText(text)
-	local width = frame.obj.frame.width or frame.obj.frame:GetWidth() or 0
-	PanelTemplates_TabResize(frame, 0, nil, nil, width, frame:GetFontString():GetStringWidth())
-end
-
-local function Tab_SetSelected(frame, selected)
-	frame.selected = selected
-	UpdateTabLook(frame)
-end
-
-local function Tab_SetDisabled(frame, disabled)
-	frame.disabled = disabled
-	UpdateTabLook(frame)
-end
-
-local function BuildTabsOnUpdate(frame)
-	local self = frame.obj
-	self:BuildTabs()
-	frame:SetScript("OnUpdate", nil)
-end
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Tab_OnClick(frame)
-	if not (frame.selected or frame.disabled) then
-		PlaySound(841) -- SOUNDKIT.IG_CHARACTER_INFO_TAB
-		frame.obj:SelectTab(frame.value)
-	end
-end
-
-local function Tab_OnEnter(frame)
-	local self = frame.obj
-	self:Fire("OnTabEnter", self.tabs[frame.id].value, frame)
-end
-
-local function Tab_OnLeave(frame)
-	local self = frame.obj
-	self:Fire("OnTabLeave", self.tabs[frame.id].value, frame)
-end
-
-local function Tab_OnShow(frame)
-	_G[frame:GetName().."HighlightTexture"]:SetWidth(frame:GetTextWidth() + 30)
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetTitle()
-	end,
-
-	["OnRelease"] = function(self)
-		self.status = nil
-		for k in pairs(self.localstatus) do
-			self.localstatus[k] = nil
-		end
-		self.tablist = nil
-		for _, tab in pairs(self.tabs) do
-			tab:Hide()
-		end
-	end,
-
-	["CreateTab"] = function(self, id)
-		local tabname = ("AceGUITabGroup%dTab%d"):format(self.num, id)
-		local tab = CreateFrame("Button", tabname, self.border)
-		tab:SetSize(115, 24)
-		tab.deselectedTextY = -3
-		tab.selectedTextY = -2
-
-		tab.LeftDisabled = tab:CreateTexture(tabname .. "LeftDisabled", "BORDER")
-		tab.LeftDisabled:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-ActiveTab")
-		tab.LeftDisabled:SetSize(20, 24)
-		tab.LeftDisabled:SetPoint("BOTTOMLEFT", 0, -3)
-		tab.LeftDisabled:SetTexCoord(0, 0.15625, 0, 1.0)
-
-		tab.MiddleDisabled = tab:CreateTexture(tabname .. "MiddleDisabled", "BORDER")
-		tab.MiddleDisabled:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-ActiveTab")
-		tab.MiddleDisabled:SetSize(88, 24)
-		tab.MiddleDisabled:SetPoint("LEFT", tab.LeftDisabled, "RIGHT")
-		tab.MiddleDisabled:SetTexCoord(0.15625, 0.84375, 0, 1.0)
-
-		tab.RightDisabled = tab:CreateTexture(tabname .. "RightDisabled", "BORDER")
-		tab.RightDisabled:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-ActiveTab")
-		tab.RightDisabled:SetSize(20, 24)
-		tab.RightDisabled:SetPoint("LEFT", tab.MiddleDisabled, "RIGHT")
-		tab.RightDisabled:SetTexCoord(0.84375, 1.0, 0, 1.0)
-
-		tab.Left = tab:CreateTexture(tabname .. "Left", "BORDER")
-		tab.Left:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-InActiveTab")
-		tab.Left:SetSize(20, 24)
-		tab.Left:SetPoint("TOPLEFT")
-		tab.Left:SetTexCoord(0, 0.15625, 0, 1.0)
-
-		tab.Middle = tab:CreateTexture(tabname .. "Middle", "BORDER")
-		tab.Middle:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-InActiveTab")
-		tab.Middle:SetSize(88, 24)
-		tab.Middle:SetPoint("LEFT", tab.Left, "RIGHT")
-		tab.Middle:SetTexCoord(0.15625, 0.84375, 0, 1.0)
-
-		tab.Right = tab:CreateTexture(tabname .. "Right", "BORDER")
-		tab.Right:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-InActiveTab")
-		tab.Right:SetSize(20, 24)
-		tab.Right:SetPoint("LEFT", tab.Middle, "RIGHT")
-		tab.Right:SetTexCoord(0.84375, 1.0, 0, 1.0)
-
-		tab.Text = tab:CreateFontString(tabname .. "Text")
-		tab:SetFontString(tab.Text)
-
-		tab:SetNormalFontObject(GameFontNormalSmall)
-		tab:SetHighlightFontObject(GameFontHighlightSmall)
-		tab:SetDisabledFontObject(GameFontHighlightSmall)
-		tab:SetHighlightTexture("Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight", "ADD")
-		tab.HighlightTexture = tab:GetHighlightTexture()
-		tab.HighlightTexture:ClearAllPoints()
-		tab.HighlightTexture:SetPoint("LEFT", tab, "LEFT", 10, -4)
-		tab.HighlightTexture:SetPoint("RIGHT", tab, "RIGHT", -10, -4)
-		_G[tabname .. "HighlightTexture"] = tab.HighlightTexture
-
-		tab.obj = self
-		tab.id = id
-
-		tab.text = tab.Text -- compat
-		tab.text:ClearAllPoints()
-		tab.text:SetPoint("LEFT", 14, -3)
-		tab.text:SetPoint("RIGHT", -12, -3)
-
-		tab:SetScript("OnClick", Tab_OnClick)
-		tab:SetScript("OnEnter", Tab_OnEnter)
-		tab:SetScript("OnLeave", Tab_OnLeave)
-		tab:SetScript("OnShow", Tab_OnShow)
-
-		tab._SetText = tab.SetText
-		tab.SetText = Tab_SetText
-		tab.SetSelected = Tab_SetSelected
-		tab.SetDisabled = Tab_SetDisabled
-
-		return tab
-	end,
-
-	["SetTitle"] = function(self, text)
-		self.titletext:SetText(text or "")
-		if text and text ~= "" then
-			self.alignoffset = 25
-		else
-			self.alignoffset = 18
-		end
-		self:BuildTabs()
-	end,
-
-	["SetStatusTable"] = function(self, status)
-		assert(type(status) == "table")
-		self.status = status
-	end,
-
-	["SelectTab"] = function(self, value)
-		local status = self.status or self.localstatus
-		local found
-		for i, v in ipairs(self.tabs) do
-			if v.value == value then
-				v:SetSelected(true)
-				found = true
-			else
-				v:SetSelected(false)
-			end
-		end
-		status.selected = value
-		if found then
-			self:Fire("OnGroupSelected",value)
-		end
-	end,
-
-	["SetTabs"] = function(self, tabs)
-		self.tablist = tabs
-		self:BuildTabs()
-	end,
-
-
-	["BuildTabs"] = function(self)
-		local hastitle = (self.titletext:GetText() and self.titletext:GetText() ~= "")
-		local tablist = self.tablist
-		local tabs = self.tabs
-
-		if not tablist then return end
-
-		local width = self.frame.width or self.frame:GetWidth() or 0
-
-		wipe(widths)
-		wipe(rowwidths)
-		wipe(rowends)
-
-		--Place Text into tabs and get thier initial width
-		for i, v in ipairs(tablist) do
-			local tab = tabs[i]
-			if not tab then
-				tab = self:CreateTab(i)
-				tabs[i] = tab
-			end
-
-			tab:Show()
-			tab:SetText(v.text)
-			tab:SetDisabled(v.disabled)
-			tab.value = v.value
-
-			widths[i] = tab:GetWidth() - 6 --tabs are anchored 10 pixels from the right side of the previous one to reduce spacing, but add a fixed 4px padding for the text
-		end
-
-		for i = (#tablist)+1, #tabs, 1 do
-			tabs[i]:Hide()
-		end
-
-		--First pass, find the minimum number of rows needed to hold all tabs and the initial tab layout
-		local numtabs = #tablist
-		local numrows = 1
-		local usedwidth = 0
-
-		for i = 1, #tablist do
-			--If this is not the first tab of a row and there isn't room for it
-			if usedwidth ~= 0 and (width - usedwidth - widths[i]) < 0 then
-				rowwidths[numrows] = usedwidth + 10 --first tab in each row takes up an extra 10px
-				rowends[numrows] = i - 1
-				numrows = numrows + 1
-				usedwidth = 0
-			end
-			usedwidth = usedwidth + widths[i]
-		end
-		rowwidths[numrows] = usedwidth + 10 --first tab in each row takes up an extra 10px
-		rowends[numrows] = #tablist
-
-		--Fix for single tabs being left on the last row, move a tab from the row above if applicable
-		if numrows > 1 then
-			--if the last row has only one tab
-			if rowends[numrows-1] == numtabs-1 then
-				--if there are more than 2 tabs in the 2nd last row
-				if (numrows == 2 and rowends[numrows-1] > 2) or (rowends[numrows] - rowends[numrows-1] > 2) then
-					--move 1 tab from the second last row to the last, if there is enough space
-					if (rowwidths[numrows] + widths[numtabs-1]) <= width then
-						rowends[numrows-1] = rowends[numrows-1] - 1
-						rowwidths[numrows] = rowwidths[numrows] + widths[numtabs-1]
-						rowwidths[numrows-1] = rowwidths[numrows-1] - widths[numtabs-1]
-					end
-				end
-			end
-		end
-
-		--anchor the rows as defined and resize tabs to fill thier row
-		local starttab = 1
-		for row, endtab in ipairs(rowends) do
-			local first = true
-			for tabno = starttab, endtab do
-				local tab = tabs[tabno]
-				tab:ClearAllPoints()
-				if first then
-					tab:SetPoint("TOPLEFT", self.frame, "TOPLEFT", 0, -(hastitle and 14 or 7)-(row-1)*20 )
-					first = false
-				else
-					tab:SetPoint("LEFT", tabs[tabno-1], "RIGHT", -10, 0)
-				end
-			end
-
-			-- equal padding for each tab to fill the available width,
-			-- if the used space is above 75% already
-			-- the 18 pixel is the typical width of a scrollbar, so we can have a tab group inside a scrolling frame,
-			-- and not have the tabs jump around funny when switching between tabs that need scrolling and those that don't
-			local padding = 0
-			if not (numrows == 1 and rowwidths[1] < width*0.75 - 18) then
-				padding = (width - rowwidths[row]) / (endtab - starttab+1)
-			end
-
-			for i = starttab, endtab do
-				PanelTemplates_TabResize(tabs[i], padding + 4, nil, nil, width, tabs[i]:GetFontString():GetStringWidth())
-			end
-			starttab = endtab + 1
-		end
-
-		self.borderoffset = (hastitle and 17 or 10)+((numrows)*20)
-		self.border:SetPoint("TOPLEFT", 1, -self.borderoffset)
-	end,
-
-	["OnWidthSet"] = function(self, width)
-		local content = self.content
-		local contentwidth = width - 60
-		if contentwidth < 0 then
-			contentwidth = 0
-		end
-		content:SetWidth(contentwidth)
-		content.width = contentwidth
-		self:BuildTabs(self)
-		self.frame:SetScript("OnUpdate", BuildTabsOnUpdate)
-	end,
-
-	["OnHeightSet"] = function(self, height)
-		local content = self.content
-		local contentheight = height - (self.borderoffset + 23)
-		if contentheight < 0 then
-			contentheight = 0
-		end
-		content:SetHeight(contentheight)
-		content.height = contentheight
-	end,
-
-	["LayoutFinished"] = function(self, width, height)
-		if self.noAutoHeight then return end
-		self:SetHeight((height or 0) + (self.borderoffset + 23))
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local PaneBackdrop  = {
-	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
-	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
-	tile = true, tileSize = 16, edgeSize = 16,
-	insets = { left = 3, right = 3, top = 5, bottom = 3 }
-}
-
-local function Constructor()
-	local num = AceGUI:GetNextWidgetNum(Type)
-	local frame = CreateFrame("Frame",nil,UIParent)
-	frame:SetHeight(100)
-	frame:SetWidth(100)
-	frame:SetFrameStrata("FULLSCREEN_DIALOG")
-
-	local titletext = frame:CreateFontString(nil,"OVERLAY","GameFontNormal")
-	titletext:SetPoint("TOPLEFT", 14, 0)
-	titletext:SetPoint("TOPRIGHT", -14, 0)
-	titletext:SetJustifyH("LEFT")
-	titletext:SetHeight(18)
-	titletext:SetText("")
-
-	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
-	border:SetPoint("TOPLEFT", 1, -27)
-	border:SetPoint("BOTTOMRIGHT", -1, 3)
-	border:SetBackdrop(PaneBackdrop)
-	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
-	border:SetBackdropBorderColor(0.4, 0.4, 0.4)
-
-	local content = CreateFrame("Frame", nil, border)
-	content:SetPoint("TOPLEFT", 10, -7)
-	content:SetPoint("BOTTOMRIGHT", -10, 7)
-
-	local widget = {
-		num          = num,
-		frame        = frame,
-		localstatus  = {},
-		alignoffset  = 18,
-		titletext    = titletext,
-		border       = border,
-		borderoffset = 27,
-		tabs         = {},
-		content      = content,
-		type         = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	return AceGUI:RegisterAsContainer(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+TabGroup Container
+Container that uses tabs on top to switch between groups.
+-------------------------------------------------------------------------------]]
+local Type, Version = "TabGroup", 38
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs, ipairs, assert, type, wipe = pairs, ipairs, assert, type, table.wipe
+
+-- WoW APIs
+local PlaySound = PlaySound
+local CreateFrame, UIParent = CreateFrame, UIParent
+local _G = _G
+
+-- local upvalue storage used by BuildTabs
+local widths = {}
+local rowwidths = {}
+local rowends = {}
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+
+local function PanelTemplates_TabResize(tab, padding, absoluteSize, minWidth, maxWidth, absoluteTextSize)
+	local tabName = tab:GetName();
+
+	local buttonMiddle = tab.Middle or tab.middleTexture or _G[tabName.."Middle"];
+	local buttonMiddleDisabled = tab.MiddleDisabled or (tabName and _G[tabName.."MiddleDisabled"]);
+	local left = tab.Left or tab.leftTexture or _G[tabName.."Left"];
+	local sideWidths = 2 * left:GetWidth();
+	local tabText = tab.Text or _G[tab:GetName().."Text"];
+	local highlightTexture = tab.HighlightTexture or (tabName and _G[tabName.."HighlightTexture"]);
+
+	local width, tabWidth;
+	local textWidth;
+	if ( absoluteTextSize ) then
+		textWidth = absoluteTextSize;
+	else
+		tabText:SetWidth(0);
+		textWidth = tabText:GetWidth();
+	end
+	-- If there's an absolute size specified then use it
+	if ( absoluteSize ) then
+		if ( absoluteSize < sideWidths) then
+			width = 1;
+			tabWidth = sideWidths
+		else
+			width = absoluteSize - sideWidths;
+			tabWidth = absoluteSize
+		end
+		tabText:SetWidth(width);
+	else
+		-- Otherwise try to use padding
+		if ( padding ) then
+			width = textWidth + padding;
+		else
+			width = textWidth + 24;
+		end
+		-- If greater than the maxWidth then cap it
+		if ( maxWidth and width > maxWidth ) then
+			if ( padding ) then
+				width = maxWidth + padding;
+			else
+				width = maxWidth + 24;
+			end
+			tabText:SetWidth(width);
+		else
+			tabText:SetWidth(0);
+		end
+		if (minWidth and width < minWidth) then
+			width = minWidth;
+		end
+		tabWidth = width + sideWidths;
+	end
+
+	if ( buttonMiddle ) then
+		buttonMiddle:SetWidth(width);
+	end
+	if ( buttonMiddleDisabled ) then
+		buttonMiddleDisabled:SetWidth(width);
+	end
+
+	tab:SetWidth(tabWidth);
+
+	if ( highlightTexture ) then
+		highlightTexture:SetWidth(tabWidth);
+	end
+end
+
+local function PanelTemplates_DeselectTab(tab)
+	local name = tab:GetName();
+
+	local left = tab.Left or _G[name.."Left"];
+	local middle = tab.Middle or _G[name.."Middle"];
+	local right = tab.Right or _G[name.."Right"];
+	left:Show();
+	middle:Show();
+	right:Show();
+	--tab:UnlockHighlight();
+	tab:Enable();
+	local text = tab.Text or _G[name.."Text"];
+	text:SetPoint("CENTER", tab, "CENTER", (tab.deselectedTextX or 0), (tab.deselectedTextY or 2));
+
+	local leftDisabled = tab.LeftDisabled or _G[name.."LeftDisabled"];
+	local middleDisabled = tab.MiddleDisabled or _G[name.."MiddleDisabled"];
+	local rightDisabled = tab.RightDisabled or _G[name.."RightDisabled"];
+	leftDisabled:Hide();
+	middleDisabled:Hide();
+	rightDisabled:Hide();
+end
+
+local function PanelTemplates_SelectTab(tab)
+	local name = tab:GetName();
+
+	local left = tab.Left or _G[name.."Left"];
+	local middle = tab.Middle or _G[name.."Middle"];
+	local right = tab.Right or _G[name.."Right"];
+	left:Hide();
+	middle:Hide();
+	right:Hide();
+	--tab:LockHighlight();
+	tab:Disable();
+	tab:SetDisabledFontObject(GameFontHighlightSmall);
+	local text = tab.Text or _G[name.."Text"];
+	text:SetPoint("CENTER", tab, "CENTER", (tab.selectedTextX or 0), (tab.selectedTextY or -3));
+
+	local leftDisabled = tab.LeftDisabled or _G[name.."LeftDisabled"];
+	local middleDisabled = tab.MiddleDisabled or _G[name.."MiddleDisabled"];
+	local rightDisabled = tab.RightDisabled or _G[name.."RightDisabled"];
+	leftDisabled:Show();
+	middleDisabled:Show();
+	rightDisabled:Show();
+
+	if GameTooltip:IsOwned(tab) then
+		GameTooltip:Hide();
+	end
+end
+
+local function PanelTemplates_SetDisabledTabState(tab)
+	local name = tab:GetName();
+	local left = tab.Left or _G[name.."Left"];
+	local middle = tab.Middle or _G[name.."Middle"];
+	local right = tab.Right or _G[name.."Right"];
+	left:Show();
+	middle:Show();
+	right:Show();
+	--tab:UnlockHighlight();
+	tab:Disable();
+	tab.text = tab:GetText();
+	-- Gray out text
+	tab:SetDisabledFontObject(GameFontDisableSmall);
+	local leftDisabled = tab.LeftDisabled or _G[name.."LeftDisabled"];
+	local middleDisabled = tab.MiddleDisabled or _G[name.."MiddleDisabled"];
+	local rightDisabled = tab.RightDisabled or _G[name.."RightDisabled"];
+	leftDisabled:Hide();
+	middleDisabled:Hide();
+	rightDisabled:Hide();
+end
+
+local function UpdateTabLook(frame)
+	if frame.disabled then
+		PanelTemplates_SetDisabledTabState(frame)
+	elseif frame.selected then
+		PanelTemplates_SelectTab(frame)
+	else
+		PanelTemplates_DeselectTab(frame)
+	end
+end
+
+local function Tab_SetText(frame, text)
+	frame:_SetText(text)
+	local width = frame.obj.frame.width or frame.obj.frame:GetWidth() or 0
+	PanelTemplates_TabResize(frame, 0, nil, nil, width, frame:GetFontString():GetStringWidth())
+end
+
+local function Tab_SetSelected(frame, selected)
+	frame.selected = selected
+	UpdateTabLook(frame)
+end
+
+local function Tab_SetDisabled(frame, disabled)
+	frame.disabled = disabled
+	UpdateTabLook(frame)
+end
+
+local function BuildTabsOnUpdate(frame)
+	local self = frame.obj
+	self:BuildTabs()
+	frame:SetScript("OnUpdate", nil)
+end
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Tab_OnClick(frame)
+	if not (frame.selected or frame.disabled) then
+		PlaySound(841) -- SOUNDKIT.IG_CHARACTER_INFO_TAB
+		frame.obj:SelectTab(frame.value)
+	end
+end
+
+local function Tab_OnEnter(frame)
+	local self = frame.obj
+	self:Fire("OnTabEnter", self.tabs[frame.id].value, frame)
+end
+
+local function Tab_OnLeave(frame)
+	local self = frame.obj
+	self:Fire("OnTabLeave", self.tabs[frame.id].value, frame)
+end
+
+local function Tab_OnShow(frame)
+	_G[frame:GetName().."HighlightTexture"]:SetWidth(frame:GetTextWidth() + 30)
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetTitle()
+	end,
+
+	["OnRelease"] = function(self)
+		self.status = nil
+		for k in pairs(self.localstatus) do
+			self.localstatus[k] = nil
+		end
+		self.tablist = nil
+		for _, tab in pairs(self.tabs) do
+			tab:Hide()
+		end
+	end,
+
+	["CreateTab"] = function(self, id)
+		local tabname = ("AceGUITabGroup%dTab%d"):format(self.num, id)
+		local tab = CreateFrame("Button", tabname, self.border)
+		tab:SetSize(115, 24)
+		tab.deselectedTextY = -3
+		tab.selectedTextY = -2
+
+		tab.LeftDisabled = tab:CreateTexture(tabname .. "LeftDisabled", "BORDER")
+		tab.LeftDisabled:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-ActiveTab")
+		tab.LeftDisabled:SetSize(20, 24)
+		tab.LeftDisabled:SetPoint("BOTTOMLEFT", 0, -3)
+		tab.LeftDisabled:SetTexCoord(0, 0.15625, 0, 1.0)
+
+		tab.MiddleDisabled = tab:CreateTexture(tabname .. "MiddleDisabled", "BORDER")
+		tab.MiddleDisabled:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-ActiveTab")
+		tab.MiddleDisabled:SetSize(88, 24)
+		tab.MiddleDisabled:SetPoint("LEFT", tab.LeftDisabled, "RIGHT")
+		tab.MiddleDisabled:SetTexCoord(0.15625, 0.84375, 0, 1.0)
+
+		tab.RightDisabled = tab:CreateTexture(tabname .. "RightDisabled", "BORDER")
+		tab.RightDisabled:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-ActiveTab")
+		tab.RightDisabled:SetSize(20, 24)
+		tab.RightDisabled:SetPoint("LEFT", tab.MiddleDisabled, "RIGHT")
+		tab.RightDisabled:SetTexCoord(0.84375, 1.0, 0, 1.0)
+
+		tab.Left = tab:CreateTexture(tabname .. "Left", "BORDER")
+		tab.Left:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-InActiveTab")
+		tab.Left:SetSize(20, 24)
+		tab.Left:SetPoint("TOPLEFT")
+		tab.Left:SetTexCoord(0, 0.15625, 0, 1.0)
+
+		tab.Middle = tab:CreateTexture(tabname .. "Middle", "BORDER")
+		tab.Middle:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-InActiveTab")
+		tab.Middle:SetSize(88, 24)
+		tab.Middle:SetPoint("LEFT", tab.Left, "RIGHT")
+		tab.Middle:SetTexCoord(0.15625, 0.84375, 0, 1.0)
+
+		tab.Right = tab:CreateTexture(tabname .. "Right", "BORDER")
+		tab.Right:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-InActiveTab")
+		tab.Right:SetSize(20, 24)
+		tab.Right:SetPoint("LEFT", tab.Middle, "RIGHT")
+		tab.Right:SetTexCoord(0.84375, 1.0, 0, 1.0)
+
+		tab.Text = tab:CreateFontString(tabname .. "Text")
+		tab:SetFontString(tab.Text)
+
+		tab:SetNormalFontObject(GameFontNormalSmall)
+		tab:SetHighlightFontObject(GameFontHighlightSmall)
+		tab:SetDisabledFontObject(GameFontHighlightSmall)
+		tab:SetHighlightTexture("Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight", "ADD")
+		tab.HighlightTexture = tab:GetHighlightTexture()
+		tab.HighlightTexture:ClearAllPoints()
+		tab.HighlightTexture:SetPoint("LEFT", tab, "LEFT", 10, -4)
+		tab.HighlightTexture:SetPoint("RIGHT", tab, "RIGHT", -10, -4)
+		_G[tabname .. "HighlightTexture"] = tab.HighlightTexture
+
+		tab.obj = self
+		tab.id = id
+
+		tab.text = tab.Text -- compat
+		tab.text:ClearAllPoints()
+		tab.text:SetPoint("LEFT", 14, -3)
+		tab.text:SetPoint("RIGHT", -12, -3)
+
+		tab:SetScript("OnClick", Tab_OnClick)
+		tab:SetScript("OnEnter", Tab_OnEnter)
+		tab:SetScript("OnLeave", Tab_OnLeave)
+		tab:SetScript("OnShow", Tab_OnShow)
+
+		tab._SetText = tab.SetText
+		tab.SetText = Tab_SetText
+		tab.SetSelected = Tab_SetSelected
+		tab.SetDisabled = Tab_SetDisabled
+
+		return tab
+	end,
+
+	["SetTitle"] = function(self, text)
+		self.titletext:SetText(text or "")
+		if text and text ~= "" then
+			self.alignoffset = 25
+		else
+			self.alignoffset = 18
+		end
+		self:BuildTabs()
+	end,
+
+	["SetStatusTable"] = function(self, status)
+		assert(type(status) == "table")
+		self.status = status
+	end,
+
+	["SelectTab"] = function(self, value)
+		local status = self.status or self.localstatus
+		local found
+		for i, v in ipairs(self.tabs) do
+			if v.value == value then
+				v:SetSelected(true)
+				found = true
+			else
+				v:SetSelected(false)
+			end
+		end
+		status.selected = value
+		if found then
+			self:Fire("OnGroupSelected",value)
+		end
+	end,
+
+	["SetTabs"] = function(self, tabs)
+		self.tablist = tabs
+		self:BuildTabs()
+	end,
+
+
+	["BuildTabs"] = function(self)
+		local hastitle = (self.titletext:GetText() and self.titletext:GetText() ~= "")
+		local tablist = self.tablist
+		local tabs = self.tabs
+
+		if not tablist then return end
+
+		local width = self.frame.width or self.frame:GetWidth() or 0
+
+		wipe(widths)
+		wipe(rowwidths)
+		wipe(rowends)
+
+		--Place Text into tabs and get thier initial width
+		for i, v in ipairs(tablist) do
+			local tab = tabs[i]
+			if not tab then
+				tab = self:CreateTab(i)
+				tabs[i] = tab
+			end
+
+			tab:Show()
+			tab:SetText(v.text)
+			tab:SetDisabled(v.disabled)
+			tab.value = v.value
+
+			widths[i] = tab:GetWidth() - 6 --tabs are anchored 10 pixels from the right side of the previous one to reduce spacing, but add a fixed 4px padding for the text
+		end
+
+		for i = (#tablist)+1, #tabs, 1 do
+			tabs[i]:Hide()
+		end
+
+		--First pass, find the minimum number of rows needed to hold all tabs and the initial tab layout
+		local numtabs = #tablist
+		local numrows = 1
+		local usedwidth = 0
+
+		for i = 1, #tablist do
+			--If this is not the first tab of a row and there isn't room for it
+			if usedwidth ~= 0 and (width - usedwidth - widths[i]) < 0 then
+				rowwidths[numrows] = usedwidth + 10 --first tab in each row takes up an extra 10px
+				rowends[numrows] = i - 1
+				numrows = numrows + 1
+				usedwidth = 0
+			end
+			usedwidth = usedwidth + widths[i]
+		end
+		rowwidths[numrows] = usedwidth + 10 --first tab in each row takes up an extra 10px
+		rowends[numrows] = #tablist
+
+		--Fix for single tabs being left on the last row, move a tab from the row above if applicable
+		if numrows > 1 then
+			--if the last row has only one tab
+			if rowends[numrows-1] == numtabs-1 then
+				--if there are more than 2 tabs in the 2nd last row
+				if (numrows == 2 and rowends[numrows-1] > 2) or (rowends[numrows] - rowends[numrows-1] > 2) then
+					--move 1 tab from the second last row to the last, if there is enough space
+					if (rowwidths[numrows] + widths[numtabs-1]) <= width then
+						rowends[numrows-1] = rowends[numrows-1] - 1
+						rowwidths[numrows] = rowwidths[numrows] + widths[numtabs-1]
+						rowwidths[numrows-1] = rowwidths[numrows-1] - widths[numtabs-1]
+					end
+				end
+			end
+		end
+
+		--anchor the rows as defined and resize tabs to fill thier row
+		local starttab = 1
+		for row, endtab in ipairs(rowends) do
+			local first = true
+			for tabno = starttab, endtab do
+				local tab = tabs[tabno]
+				tab:ClearAllPoints()
+				if first then
+					tab:SetPoint("TOPLEFT", self.frame, "TOPLEFT", 0, -(hastitle and 14 or 7)-(row-1)*20 )
+					first = false
+				else
+					tab:SetPoint("LEFT", tabs[tabno-1], "RIGHT", -10, 0)
+				end
+			end
+
+			-- equal padding for each tab to fill the available width,
+			-- if the used space is above 75% already
+			-- the 18 pixel is the typical width of a scrollbar, so we can have a tab group inside a scrolling frame,
+			-- and not have the tabs jump around funny when switching between tabs that need scrolling and those that don't
+			local padding = 0
+			if not (numrows == 1 and rowwidths[1] < width*0.75 - 18) then
+				padding = (width - rowwidths[row]) / (endtab - starttab+1)
+			end
+
+			for i = starttab, endtab do
+				PanelTemplates_TabResize(tabs[i], padding + 4, nil, nil, width, tabs[i]:GetFontString():GetStringWidth())
+			end
+			starttab = endtab + 1
+		end
+
+		self.borderoffset = (hastitle and 17 or 10)+((numrows)*20)
+		self.border:SetPoint("TOPLEFT", 1, -self.borderoffset)
+	end,
+
+	["OnWidthSet"] = function(self, width)
+		local content = self.content
+		local contentwidth = width - 60
+		if contentwidth < 0 then
+			contentwidth = 0
+		end
+		content:SetWidth(contentwidth)
+		content.width = contentwidth
+		self:BuildTabs(self)
+		self.frame:SetScript("OnUpdate", BuildTabsOnUpdate)
+	end,
+
+	["OnHeightSet"] = function(self, height)
+		local content = self.content
+		local contentheight = height - (self.borderoffset + 23)
+		if contentheight < 0 then
+			contentheight = 0
+		end
+		content:SetHeight(contentheight)
+		content.height = contentheight
+	end,
+
+	["LayoutFinished"] = function(self, width, height)
+		if self.noAutoHeight then return end
+		self:SetHeight((height or 0) + (self.borderoffset + 23))
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local PaneBackdrop  = {
+	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
+	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
+	tile = true, tileSize = 16, edgeSize = 16,
+	insets = { left = 3, right = 3, top = 5, bottom = 3 }
+}
+
+local function Constructor()
+	local num = AceGUI:GetNextWidgetNum(Type)
+	local frame = CreateFrame("Frame",nil,UIParent)
+	frame:SetHeight(100)
+	frame:SetWidth(100)
+	frame:SetFrameStrata("FULLSCREEN_DIALOG")
+
+	local titletext = frame:CreateFontString(nil,"OVERLAY","GameFontNormal")
+	titletext:SetPoint("TOPLEFT", 14, 0)
+	titletext:SetPoint("TOPRIGHT", -14, 0)
+	titletext:SetJustifyH("LEFT")
+	titletext:SetHeight(18)
+	titletext:SetText("")
+
+	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
+	border:SetPoint("TOPLEFT", 1, -27)
+	border:SetPoint("BOTTOMRIGHT", -1, 3)
+	border:SetBackdrop(PaneBackdrop)
+	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
+	border:SetBackdropBorderColor(0.4, 0.4, 0.4)
+
+	local content = CreateFrame("Frame", nil, border)
+	content:SetPoint("TOPLEFT", 10, -7)
+	content:SetPoint("BOTTOMRIGHT", -10, 7)
+
+	local widget = {
+		num          = num,
+		frame        = frame,
+		localstatus  = {},
+		alignoffset  = 18,
+		titletext    = titletext,
+		border       = border,
+		borderoffset = 27,
+		tabs         = {},
+		content      = content,
+		type         = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	return AceGUI:RegisterAsContainer(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-TreeGroup.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-TreeGroup.lua
index ca9b2df..89f387a 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-TreeGroup.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-TreeGroup.lua
@@ -1,719 +1,719 @@
---[[-----------------------------------------------------------------------------
-TreeGroup Container
-Container that uses a tree control to switch between groups.
--------------------------------------------------------------------------------]]
-local Type, Version = "TreeGroup", 47
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local next, pairs, ipairs, assert, type = next, pairs, ipairs, assert, type
-local math_min, math_max, floor = math.min, math.max, math.floor
-local select, tremove, unpack, tconcat = select, table.remove, unpack, table.concat
-
--- WoW APIs
-local CreateFrame, UIParent = CreateFrame, UIParent
-
--- Recycling functions
-local new, del
-do
-	local pool = setmetatable({},{__mode='k'})
-	function new()
-		local t = next(pool)
-		if t then
-			pool[t] = nil
-			return t
-		else
-			return {}
-		end
-	end
-	function del(t)
-		for k in pairs(t) do
-			t[k] = nil
-		end
-		pool[t] = true
-	end
-end
-
-local DEFAULT_TREE_WIDTH = 175
-local DEFAULT_TREE_SIZABLE = true
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-local function GetButtonUniqueValue(line)
-	local parent = line.parent
-	if parent and parent.value then
-		return GetButtonUniqueValue(parent).."\001"..line.value
-	else
-		return line.value
-	end
-end
-
-local function UpdateButton(button, treeline, selected, canExpand, isExpanded)
-	local self = button.obj
-	local toggle = button.toggle
-	local text = treeline.text or ""
-	local icon = treeline.icon
-	local iconCoords = treeline.iconCoords
-	local level = treeline.level
-	local value = treeline.value
-	local uniquevalue = treeline.uniquevalue
-	local disabled = treeline.disabled
-
-	button.treeline = treeline
-	button.value = value
-	button.uniquevalue = uniquevalue
-	if selected then
-		button:LockHighlight()
-		button.selected = true
-	else
-		button:UnlockHighlight()
-		button.selected = false
-	end
-	button.level = level
-	if ( level == 1 ) then
-		button:SetNormalFontObject("GameFontNormal")
-		button:SetHighlightFontObject("GameFontHighlight")
-		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8, 2)
-	else
-		button:SetNormalFontObject("GameFontHighlightSmall")
-		button:SetHighlightFontObject("GameFontHighlightSmall")
-		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8 * level, 2)
-	end
-
-	if disabled then
-		button:EnableMouse(false)
-		button.text:SetText("|cff808080"..text..FONT_COLOR_CODE_CLOSE)
-	else
-		button.text:SetText(text)
-		button:EnableMouse(true)
-	end
-
-	if icon then
-		button.icon:SetTexture(icon)
-		button.icon:SetPoint("LEFT", 8 * level, (level == 1) and 0 or 1)
-	else
-		button.icon:SetTexture(nil)
-	end
-
-	if iconCoords then
-		button.icon:SetTexCoord(unpack(iconCoords))
-	else
-		button.icon:SetTexCoord(0, 1, 0, 1)
-	end
-
-	if canExpand then
-		if not isExpanded then
-			toggle:SetNormalTexture(130838) -- Interface\\Buttons\\UI-PlusButton-UP
-			toggle:SetPushedTexture(130836) -- Interface\\Buttons\\UI-PlusButton-DOWN
-		else
-			toggle:SetNormalTexture(130821) -- Interface\\Buttons\\UI-MinusButton-UP
-			toggle:SetPushedTexture(130820) -- Interface\\Buttons\\UI-MinusButton-DOWN
-		end
-		toggle:Show()
-	else
-		toggle:Hide()
-	end
-end
-
-local function ShouldDisplayLevel(tree)
-	local result = false
-	for k, v in ipairs(tree) do
-		if v.children == nil and v.visible ~= false then
-			result = true
-		elseif v.children then
-			result = result or ShouldDisplayLevel(v.children)
-		end
-		if result then return result end
-	end
-	return false
-end
-
-local function addLine(self, v, tree, level, parent)
-	local line = new()
-	line.value = v.value
-	line.text = v.text
-	line.icon = v.icon
-	line.iconCoords = v.iconCoords
-	line.disabled = v.disabled
-	line.tree = tree
-	line.level = level
-	line.parent = parent
-	line.visible = v.visible
-	line.uniquevalue = GetButtonUniqueValue(line)
-	if v.children then
-		line.hasChildren = true
-	else
-		line.hasChildren = nil
-	end
-	self.lines[#self.lines+1] = line
-	return line
-end
-
---fire an update after one frame to catch the treeframes height
-local function FirstFrameUpdate(frame)
-	local self = frame.obj
-	frame:SetScript("OnUpdate", nil)
-	self:RefreshTree(nil, true)
-end
-
-local function BuildUniqueValue(...)
-	local n = select('#', ...)
-	if n == 1 then
-		return ...
-	else
-		return (...).."\001"..BuildUniqueValue(select(2,...))
-	end
-end
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Expand_OnClick(frame)
-	local button = frame.button
-	local self = button.obj
-	local status = (self.status or self.localstatus).groups
-	status[button.uniquevalue] = not status[button.uniquevalue]
-	self:RefreshTree()
-end
-
-local function Button_OnClick(frame)
-	local self = frame.obj
-	self:Fire("OnClick", frame.uniquevalue, frame.selected)
-	if not frame.selected then
-		self:SetSelected(frame.uniquevalue)
-		frame.selected = true
-		frame:LockHighlight()
-		self:RefreshTree()
-	end
-	AceGUI:ClearFocus()
-end
-
-local function Button_OnDoubleClick(button)
-	local self = button.obj
-	local status = (self.status or self.localstatus).groups
-	status[button.uniquevalue] = not status[button.uniquevalue]
-	self:RefreshTree()
-end
-
-local function Button_OnEnter(frame)
-	local self = frame.obj
-	self:Fire("OnButtonEnter", frame.uniquevalue, frame)
-
-	if self.enabletooltips then
-		local tooltip = AceGUI.tooltip
-		tooltip:SetOwner(frame, "ANCHOR_NONE")
-		tooltip:ClearAllPoints()
-		tooltip:SetPoint("LEFT",frame,"RIGHT")
-		tooltip:SetText(frame.text:GetText() or "", 1, .82, 0, true)
-
-		tooltip:Show()
-	end
-end
-
-local function Button_OnLeave(frame)
-	local self = frame.obj
-	self:Fire("OnButtonLeave", frame.uniquevalue, frame)
-
-	if self.enabletooltips then
-		AceGUI.tooltip:Hide()
-	end
-end
-
-local function OnScrollValueChanged(frame, value)
-	if frame.obj.noupdate then return end
-	local self = frame.obj
-	local status = self.status or self.localstatus
-	status.scrollvalue = floor(value + 0.5)
-	self:RefreshTree()
-	AceGUI:ClearFocus()
-end
-
-local function Tree_OnSizeChanged(frame)
-	frame.obj:RefreshTree()
-end
-
-local function Tree_OnMouseWheel(frame, delta)
-	local self = frame.obj
-	if self.showscroll then
-		local scrollbar = self.scrollbar
-		local min, max = scrollbar:GetMinMaxValues()
-		local value = scrollbar:GetValue()
-		local newvalue = math_min(max,math_max(min,value - delta))
-		if value ~= newvalue then
-			scrollbar:SetValue(newvalue)
-		end
-	end
-end
-
-local function Dragger_OnLeave(frame)
-	frame:SetBackdropColor(1, 1, 1, 0)
-end
-
-local function Dragger_OnEnter(frame)
-	frame:SetBackdropColor(1, 1, 1, 0.8)
-end
-
-local function Dragger_OnMouseDown(frame)
-	local treeframe = frame:GetParent()
-	treeframe:StartSizing("RIGHT")
-end
-
-local function Dragger_OnMouseUp(frame)
-	local treeframe = frame:GetParent()
-	local self = treeframe.obj
-	local treeframeParent = treeframe:GetParent()
-	treeframe:StopMovingOrSizing()
-	--treeframe:SetScript("OnUpdate", nil)
-	treeframe:SetUserPlaced(false)
-	--Without this :GetHeight will get stuck on the current height, causing the tree contents to not resize
-	treeframe:SetHeight(0)
-	treeframe:ClearAllPoints()
-	treeframe:SetPoint("TOPLEFT", treeframeParent, "TOPLEFT",0,0)
-	treeframe:SetPoint("BOTTOMLEFT", treeframeParent, "BOTTOMLEFT",0,0)
-
-	local status = self.status or self.localstatus
-	status.treewidth = treeframe:GetWidth()
-
-	treeframe.obj:Fire("OnTreeResize",treeframe:GetWidth())
-	-- recalculate the content width
-	treeframe.obj:OnWidthSet(status.fullwidth)
-	-- update the layout of the content
-	treeframe.obj:DoLayout()
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetTreeWidth(DEFAULT_TREE_WIDTH, DEFAULT_TREE_SIZABLE)
-		self:EnableButtonTooltips(true)
-		self.frame:SetScript("OnUpdate", FirstFrameUpdate)
-	end,
-
-	["OnRelease"] = function(self)
-		self.status = nil
-		self.tree = nil
-		self.frame:SetScript("OnUpdate", nil)
-		for k, v in pairs(self.localstatus) do
-			if k == "groups" then
-				for k2 in pairs(v) do
-					v[k2] = nil
-				end
-			else
-				self.localstatus[k] = nil
-			end
-		end
-		self.localstatus.scrollvalue = 0
-		self.localstatus.treewidth = DEFAULT_TREE_WIDTH
-		self.localstatus.treesizable = DEFAULT_TREE_SIZABLE
-	end,
-
-	["EnableButtonTooltips"] = function(self, enable)
-		self.enabletooltips = enable
-	end,
-
-	["CreateButton"] = function(self)
-		local num = AceGUI:GetNextWidgetNum("TreeGroupButton")
-		local button = CreateFrame("Button", ("AceGUI30TreeButton%d"):format(num), self.treeframe, "OptionsListButtonTemplate")
-		button.obj = self
-
-		local icon = button:CreateTexture(nil, "OVERLAY")
-		icon:SetWidth(14)
-		icon:SetHeight(14)
-		button.icon = icon
-
-		button:SetScript("OnClick",Button_OnClick)
-		button:SetScript("OnDoubleClick", Button_OnDoubleClick)
-		button:SetScript("OnEnter",Button_OnEnter)
-		button:SetScript("OnLeave",Button_OnLeave)
-
-		button.toggle.button = button
-		button.toggle:SetScript("OnClick",Expand_OnClick)
-
-		button.text:SetHeight(14) -- Prevents text wrapping
-
-		return button
-	end,
-
-	["SetStatusTable"] = function(self, status)
-		assert(type(status) == "table")
-		self.status = status
-		if not status.groups then
-			status.groups = {}
-		end
-		if not status.scrollvalue then
-			status.scrollvalue = 0
-		end
-		if not status.treewidth then
-			status.treewidth = DEFAULT_TREE_WIDTH
-		end
-		if status.treesizable == nil then
-			status.treesizable = DEFAULT_TREE_SIZABLE
-		end
-		self:SetTreeWidth(status.treewidth,status.treesizable)
-		self:RefreshTree()
-	end,
-
-	--sets the tree to be displayed
-	["SetTree"] = function(self, tree, filter)
-		self.filter = filter
-		if tree then
-			assert(type(tree) == "table")
-		end
-		self.tree = tree
-		self:RefreshTree()
-	end,
-
-	["BuildLevel"] = function(self, tree, level, parent)
-		local groups = (self.status or self.localstatus).groups
-
-		for i, v in ipairs(tree) do
-			if v.children then
-				if not self.filter or ShouldDisplayLevel(v.children) then
-					local line = addLine(self, v, tree, level, parent)
-					if groups[line.uniquevalue] then
-						self:BuildLevel(v.children, level+1, line)
-					end
-				end
-			elseif v.visible ~= false or not self.filter then
-				addLine(self, v, tree, level, parent)
-			end
-		end
-	end,
-
-	["RefreshTree"] = function(self,scrollToSelection,fromOnUpdate)
-		local buttons = self.buttons
-		local lines = self.lines
-
-		for i, v in ipairs(buttons) do
-			v:Hide()
-		end
-		while lines[1] do
-			local t = tremove(lines)
-			for k in pairs(t) do
-				t[k] = nil
-			end
-			del(t)
-		end
-
-		if not self.tree then return end
-		--Build the list of visible entries from the tree and status tables
-		local status = self.status or self.localstatus
-		local groupstatus = status.groups
-		local tree = self.tree
-
-		local treeframe = self.treeframe
-
-		status.scrollToSelection = status.scrollToSelection or scrollToSelection	-- needs to be cached in case the control hasn't been drawn yet (code bails out below)
-
-		self:BuildLevel(tree, 1)
-
-		local numlines = #lines
-
-		local maxlines = (floor(((self.treeframe:GetHeight()or 0) - 20 ) / 18))
-		if maxlines <= 0 then return end
-
-		if self.frame:GetParent() == UIParent and not fromOnUpdate then
-			self.frame:SetScript("OnUpdate", FirstFrameUpdate)
-			return
-		end
-
-		local first, last
-
-		scrollToSelection = status.scrollToSelection
-		status.scrollToSelection = nil
-
-		if numlines <= maxlines then
-			--the whole tree fits in the frame
-			status.scrollvalue = 0
-			self:ShowScroll(false)
-			first, last = 1, numlines
-		else
-			self:ShowScroll(true)
-			--scrolling will be needed
-			self.noupdate = true
-			self.scrollbar:SetMinMaxValues(0, numlines - maxlines)
-			--check if we are scrolled down too far
-			if numlines - status.scrollvalue < maxlines then
-				status.scrollvalue = numlines - maxlines
-			end
-			self.noupdate = nil
-			first, last = status.scrollvalue+1, status.scrollvalue + maxlines
-			--show selection?
-			if scrollToSelection and status.selected then
-				local show
-				for i,line in ipairs(lines) do	-- find the line number
-					if line.uniquevalue==status.selected then
-						show=i
-					end
-				end
-				if not show then
-					-- selection was deleted or something?
-				elseif show>=first and show<=last then
-					-- all good
-				else
-					-- scrolling needed!
-					if show<first then
-						status.scrollvalue = show-1
-					else
-						status.scrollvalue = show-maxlines
-					end
-					first, last = status.scrollvalue+1, status.scrollvalue + maxlines
-				end
-			end
-			if self.scrollbar:GetValue() ~= status.scrollvalue then
-				self.scrollbar:SetValue(status.scrollvalue)
-			end
-		end
-
-		local buttonnum = 1
-		for i = first, last do
-			local line = lines[i]
-			local button = buttons[buttonnum]
-			if not button then
-				button = self:CreateButton()
-
-				buttons[buttonnum] = button
-				button:SetParent(treeframe)
-				button:SetFrameLevel(treeframe:GetFrameLevel()+1)
-				button:ClearAllPoints()
-				if buttonnum == 1 then
-					if self.showscroll then
-						button:SetPoint("TOPRIGHT", -22, -10)
-						button:SetPoint("TOPLEFT", 0, -10)
-					else
-						button:SetPoint("TOPRIGHT", 0, -10)
-						button:SetPoint("TOPLEFT", 0, -10)
-					end
-				else
-					button:SetPoint("TOPRIGHT", buttons[buttonnum-1], "BOTTOMRIGHT",0,0)
-					button:SetPoint("TOPLEFT", buttons[buttonnum-1], "BOTTOMLEFT",0,0)
-				end
-			end
-
-			UpdateButton(button, line, status.selected == line.uniquevalue, line.hasChildren, groupstatus[line.uniquevalue] )
-			button:Show()
-			buttonnum = buttonnum + 1
-		end
-
-	end,
-
-	["SetSelected"] = function(self, value)
-		local status = self.status or self.localstatus
-		if status.selected ~= value then
-			status.selected = value
-			self:Fire("OnGroupSelected", value)
-		end
-	end,
-
-	["Select"] = function(self, uniquevalue, ...)
-		self.filter = false
-		local status = self.status or self.localstatus
-		local groups = status.groups
-		local path = {...}
-		for i = 1, #path do
-			groups[tconcat(path, "\001", 1, i)] = true
-		end
-		status.selected = uniquevalue
-		self:RefreshTree(true)
-		self:Fire("OnGroupSelected", uniquevalue)
-	end,
-
-	["SelectByPath"] = function(self, ...)
-		self:Select(BuildUniqueValue(...), ...)
-	end,
-
-	["SelectByValue"] = function(self, uniquevalue)
-		self:Select(uniquevalue, ("\001"):split(uniquevalue))
-	end,
-
-	["ShowScroll"] = function(self, show)
-		self.showscroll = show
-		if show then
-			self.scrollbar:Show()
-			if self.buttons[1] then
-				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe,"TOPRIGHT",-22,-10)
-			end
-		else
-			self.scrollbar:Hide()
-			if self.buttons[1] then
-				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe,"TOPRIGHT",0,-10)
-			end
-		end
-	end,
-
-	["OnWidthSet"] = function(self, width)
-		local content = self.content
-		local treeframe = self.treeframe
-		local status = self.status or self.localstatus
-		status.fullwidth = width
-
-		local contentwidth = width - status.treewidth - 20
-		if contentwidth < 0 then
-			contentwidth = 0
-		end
-		content:SetWidth(contentwidth)
-		content.width = contentwidth
-
-		local maxtreewidth = math_min(400, width - 50)
-
-		if maxtreewidth > 100 and status.treewidth > maxtreewidth then
-			self:SetTreeWidth(maxtreewidth, status.treesizable)
-		end
-		if treeframe.SetResizeBounds then
-			treeframe:SetResizeBounds(100, 1, maxtreewidth, 1600)
-		else
-			treeframe:SetMaxResize(maxtreewidth, 1600)
-		end
-	end,
-
-	["OnHeightSet"] = function(self, height)
-		local content = self.content
-		local contentheight = height - 20
-		if contentheight < 0 then
-			contentheight = 0
-		end
-		content:SetHeight(contentheight)
-		content.height = contentheight
-	end,
-
-	["SetTreeWidth"] = function(self, treewidth, resizable)
-		if not resizable then
-			if type(treewidth) == 'number' then
-				resizable = false
-			elseif type(treewidth) == 'boolean' then
-				resizable = treewidth
-				treewidth = DEFAULT_TREE_WIDTH
-			else
-				resizable = false
-				treewidth = DEFAULT_TREE_WIDTH
-			end
-		end
-		self.treeframe:SetWidth(treewidth)
-		self.dragger:EnableMouse(resizable)
-
-		local status = self.status or self.localstatus
-		status.treewidth = treewidth
-		status.treesizable = resizable
-
-		-- recalculate the content width
-		if status.fullwidth then
-			self:OnWidthSet(status.fullwidth)
-		end
-	end,
-
-	["GetTreeWidth"] = function(self)
-		local status = self.status or self.localstatus
-		return status.treewidth or DEFAULT_TREE_WIDTH
-	end,
-
-	["LayoutFinished"] = function(self, width, height)
-		if self.noAutoHeight then return end
-		self:SetHeight((height or 0) + 20)
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local PaneBackdrop  = {
-	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
-	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
-	tile = true, tileSize = 16, edgeSize = 16,
-	insets = { left = 3, right = 3, top = 5, bottom = 3 }
-}
-
-local DraggerBackdrop  = {
-	bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
-	edgeFile = nil,
-	tile = true, tileSize = 16, edgeSize = 1,
-	insets = { left = 3, right = 3, top = 7, bottom = 7 }
-}
-
-local function Constructor()
-	local num = AceGUI:GetNextWidgetNum(Type)
-	local frame = CreateFrame("Frame", nil, UIParent)
-
-	local treeframe = CreateFrame("Frame", nil, frame, "BackdropTemplate")
-	treeframe:SetPoint("TOPLEFT")
-	treeframe:SetPoint("BOTTOMLEFT")
-	treeframe:SetWidth(DEFAULT_TREE_WIDTH)
-	treeframe:EnableMouseWheel(true)
-	treeframe:SetBackdrop(PaneBackdrop)
-	treeframe:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
-	treeframe:SetBackdropBorderColor(0.4, 0.4, 0.4)
-	treeframe:SetResizable(true)
-	if treeframe.SetResizeBounds then -- WoW 10.0
-		treeframe:SetResizeBounds(100, 1, 400, 1600)
-	else
-		treeframe:SetMinResize(100, 1)
-		treeframe:SetMaxResize(400, 1600)
-	end
-	treeframe:SetScript("OnUpdate", FirstFrameUpdate)
-	treeframe:SetScript("OnSizeChanged", Tree_OnSizeChanged)
-	treeframe:SetScript("OnMouseWheel", Tree_OnMouseWheel)
-
-	local dragger = CreateFrame("Frame", nil, treeframe, "BackdropTemplate")
-	dragger:SetWidth(8)
-	dragger:SetPoint("TOP", treeframe, "TOPRIGHT")
-	dragger:SetPoint("BOTTOM", treeframe, "BOTTOMRIGHT")
-	dragger:SetBackdrop(DraggerBackdrop)
-	dragger:SetBackdropColor(1, 1, 1, 0)
-	dragger:SetScript("OnEnter", Dragger_OnEnter)
-	dragger:SetScript("OnLeave", Dragger_OnLeave)
-	dragger:SetScript("OnMouseDown", Dragger_OnMouseDown)
-	dragger:SetScript("OnMouseUp", Dragger_OnMouseUp)
-
-	local scrollbar = CreateFrame("Slider", ("AceConfigDialogTreeGroup%dScrollBar"):format(num), treeframe, "UIPanelScrollBarTemplate")
-	scrollbar:SetScript("OnValueChanged", nil)
-	scrollbar:SetPoint("TOPRIGHT", -10, -26)
-	scrollbar:SetPoint("BOTTOMRIGHT", -10, 26)
-	scrollbar:SetMinMaxValues(0,0)
-	scrollbar:SetValueStep(1)
-	scrollbar:SetValue(0)
-	scrollbar:SetWidth(16)
-	scrollbar:SetScript("OnValueChanged", OnScrollValueChanged)
-
-	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
-	scrollbg:SetAllPoints(scrollbar)
-	scrollbg:SetColorTexture(0,0,0,0.4)
-
-	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
-	border:SetPoint("TOPLEFT", treeframe, "TOPRIGHT")
-	border:SetPoint("BOTTOMRIGHT")
-	border:SetBackdrop(PaneBackdrop)
-	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
-	border:SetBackdropBorderColor(0.4, 0.4, 0.4)
-
-	--Container Support
-	local content = CreateFrame("Frame", nil, border)
-	content:SetPoint("TOPLEFT", 10, -10)
-	content:SetPoint("BOTTOMRIGHT", -10, 10)
-
-	local widget = {
-		frame        = frame,
-		lines        = {},
-		levels       = {},
-		buttons      = {},
-		hasChildren  = {},
-		localstatus  = { groups = {}, scrollvalue = 0 },
-		filter       = false,
-		treeframe    = treeframe,
-		dragger      = dragger,
-		scrollbar    = scrollbar,
-		border       = border,
-		content      = content,
-		type         = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-	treeframe.obj, dragger.obj, scrollbar.obj = widget, widget, widget
-
-	return AceGUI:RegisterAsContainer(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+TreeGroup Container
+Container that uses a tree control to switch between groups.
+-------------------------------------------------------------------------------]]
+local Type, Version = "TreeGroup", 47
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local next, pairs, ipairs, assert, type = next, pairs, ipairs, assert, type
+local math_min, math_max, floor = math.min, math.max, math.floor
+local select, tremove, unpack, tconcat = select, table.remove, unpack, table.concat
+
+-- WoW APIs
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+-- Recycling functions
+local new, del
+do
+	local pool = setmetatable({},{__mode='k'})
+	function new()
+		local t = next(pool)
+		if t then
+			pool[t] = nil
+			return t
+		else
+			return {}
+		end
+	end
+	function del(t)
+		for k in pairs(t) do
+			t[k] = nil
+		end
+		pool[t] = true
+	end
+end
+
+local DEFAULT_TREE_WIDTH = 175
+local DEFAULT_TREE_SIZABLE = true
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+local function GetButtonUniqueValue(line)
+	local parent = line.parent
+	if parent and parent.value then
+		return GetButtonUniqueValue(parent).."\001"..line.value
+	else
+		return line.value
+	end
+end
+
+local function UpdateButton(button, treeline, selected, canExpand, isExpanded)
+	local self = button.obj
+	local toggle = button.toggle
+	local text = treeline.text or ""
+	local icon = treeline.icon
+	local iconCoords = treeline.iconCoords
+	local level = treeline.level
+	local value = treeline.value
+	local uniquevalue = treeline.uniquevalue
+	local disabled = treeline.disabled
+
+	button.treeline = treeline
+	button.value = value
+	button.uniquevalue = uniquevalue
+	if selected then
+		button:LockHighlight()
+		button.selected = true
+	else
+		button:UnlockHighlight()
+		button.selected = false
+	end
+	button.level = level
+	if ( level == 1 ) then
+		button:SetNormalFontObject("GameFontNormal")
+		button:SetHighlightFontObject("GameFontHighlight")
+		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8, 2)
+	else
+		button:SetNormalFontObject("GameFontHighlightSmall")
+		button:SetHighlightFontObject("GameFontHighlightSmall")
+		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8 * level, 2)
+	end
+
+	if disabled then
+		button:EnableMouse(false)
+		button.text:SetText("|cff808080"..text..FONT_COLOR_CODE_CLOSE)
+	else
+		button.text:SetText(text)
+		button:EnableMouse(true)
+	end
+
+	if icon then
+		button.icon:SetTexture(icon)
+		button.icon:SetPoint("LEFT", 8 * level, (level == 1) and 0 or 1)
+	else
+		button.icon:SetTexture(nil)
+	end
+
+	if iconCoords then
+		button.icon:SetTexCoord(unpack(iconCoords))
+	else
+		button.icon:SetTexCoord(0, 1, 0, 1)
+	end
+
+	if canExpand then
+		if not isExpanded then
+			toggle:SetNormalTexture(130838) -- Interface\\Buttons\\UI-PlusButton-UP
+			toggle:SetPushedTexture(130836) -- Interface\\Buttons\\UI-PlusButton-DOWN
+		else
+			toggle:SetNormalTexture(130821) -- Interface\\Buttons\\UI-MinusButton-UP
+			toggle:SetPushedTexture(130820) -- Interface\\Buttons\\UI-MinusButton-DOWN
+		end
+		toggle:Show()
+	else
+		toggle:Hide()
+	end
+end
+
+local function ShouldDisplayLevel(tree)
+	local result = false
+	for k, v in ipairs(tree) do
+		if v.children == nil and v.visible ~= false then
+			result = true
+		elseif v.children then
+			result = result or ShouldDisplayLevel(v.children)
+		end
+		if result then return result end
+	end
+	return false
+end
+
+local function addLine(self, v, tree, level, parent)
+	local line = new()
+	line.value = v.value
+	line.text = v.text
+	line.icon = v.icon
+	line.iconCoords = v.iconCoords
+	line.disabled = v.disabled
+	line.tree = tree
+	line.level = level
+	line.parent = parent
+	line.visible = v.visible
+	line.uniquevalue = GetButtonUniqueValue(line)
+	if v.children then
+		line.hasChildren = true
+	else
+		line.hasChildren = nil
+	end
+	self.lines[#self.lines+1] = line
+	return line
+end
+
+--fire an update after one frame to catch the treeframes height
+local function FirstFrameUpdate(frame)
+	local self = frame.obj
+	frame:SetScript("OnUpdate", nil)
+	self:RefreshTree(nil, true)
+end
+
+local function BuildUniqueValue(...)
+	local n = select('#', ...)
+	if n == 1 then
+		return ...
+	else
+		return (...).."\001"..BuildUniqueValue(select(2,...))
+	end
+end
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Expand_OnClick(frame)
+	local button = frame.button
+	local self = button.obj
+	local status = (self.status or self.localstatus).groups
+	status[button.uniquevalue] = not status[button.uniquevalue]
+	self:RefreshTree()
+end
+
+local function Button_OnClick(frame)
+	local self = frame.obj
+	self:Fire("OnClick", frame.uniquevalue, frame.selected)
+	if not frame.selected then
+		self:SetSelected(frame.uniquevalue)
+		frame.selected = true
+		frame:LockHighlight()
+		self:RefreshTree()
+	end
+	AceGUI:ClearFocus()
+end
+
+local function Button_OnDoubleClick(button)
+	local self = button.obj
+	local status = (self.status or self.localstatus).groups
+	status[button.uniquevalue] = not status[button.uniquevalue]
+	self:RefreshTree()
+end
+
+local function Button_OnEnter(frame)
+	local self = frame.obj
+	self:Fire("OnButtonEnter", frame.uniquevalue, frame)
+
+	if self.enabletooltips then
+		local tooltip = AceGUI.tooltip
+		tooltip:SetOwner(frame, "ANCHOR_NONE")
+		tooltip:ClearAllPoints()
+		tooltip:SetPoint("LEFT",frame,"RIGHT")
+		tooltip:SetText(frame.text:GetText() or "", 1, .82, 0, true)
+
+		tooltip:Show()
+	end
+end
+
+local function Button_OnLeave(frame)
+	local self = frame.obj
+	self:Fire("OnButtonLeave", frame.uniquevalue, frame)
+
+	if self.enabletooltips then
+		AceGUI.tooltip:Hide()
+	end
+end
+
+local function OnScrollValueChanged(frame, value)
+	if frame.obj.noupdate then return end
+	local self = frame.obj
+	local status = self.status or self.localstatus
+	status.scrollvalue = floor(value + 0.5)
+	self:RefreshTree()
+	AceGUI:ClearFocus()
+end
+
+local function Tree_OnSizeChanged(frame)
+	frame.obj:RefreshTree()
+end
+
+local function Tree_OnMouseWheel(frame, delta)
+	local self = frame.obj
+	if self.showscroll then
+		local scrollbar = self.scrollbar
+		local min, max = scrollbar:GetMinMaxValues()
+		local value = scrollbar:GetValue()
+		local newvalue = math_min(max,math_max(min,value - delta))
+		if value ~= newvalue then
+			scrollbar:SetValue(newvalue)
+		end
+	end
+end
+
+local function Dragger_OnLeave(frame)
+	frame:SetBackdropColor(1, 1, 1, 0)
+end
+
+local function Dragger_OnEnter(frame)
+	frame:SetBackdropColor(1, 1, 1, 0.8)
+end
+
+local function Dragger_OnMouseDown(frame)
+	local treeframe = frame:GetParent()
+	treeframe:StartSizing("RIGHT")
+end
+
+local function Dragger_OnMouseUp(frame)
+	local treeframe = frame:GetParent()
+	local self = treeframe.obj
+	local treeframeParent = treeframe:GetParent()
+	treeframe:StopMovingOrSizing()
+	--treeframe:SetScript("OnUpdate", nil)
+	treeframe:SetUserPlaced(false)
+	--Without this :GetHeight will get stuck on the current height, causing the tree contents to not resize
+	treeframe:SetHeight(0)
+	treeframe:ClearAllPoints()
+	treeframe:SetPoint("TOPLEFT", treeframeParent, "TOPLEFT",0,0)
+	treeframe:SetPoint("BOTTOMLEFT", treeframeParent, "BOTTOMLEFT",0,0)
+
+	local status = self.status or self.localstatus
+	status.treewidth = treeframe:GetWidth()
+
+	treeframe.obj:Fire("OnTreeResize",treeframe:GetWidth())
+	-- recalculate the content width
+	treeframe.obj:OnWidthSet(status.fullwidth)
+	-- update the layout of the content
+	treeframe.obj:DoLayout()
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetTreeWidth(DEFAULT_TREE_WIDTH, DEFAULT_TREE_SIZABLE)
+		self:EnableButtonTooltips(true)
+		self.frame:SetScript("OnUpdate", FirstFrameUpdate)
+	end,
+
+	["OnRelease"] = function(self)
+		self.status = nil
+		self.tree = nil
+		self.frame:SetScript("OnUpdate", nil)
+		for k, v in pairs(self.localstatus) do
+			if k == "groups" then
+				for k2 in pairs(v) do
+					v[k2] = nil
+				end
+			else
+				self.localstatus[k] = nil
+			end
+		end
+		self.localstatus.scrollvalue = 0
+		self.localstatus.treewidth = DEFAULT_TREE_WIDTH
+		self.localstatus.treesizable = DEFAULT_TREE_SIZABLE
+	end,
+
+	["EnableButtonTooltips"] = function(self, enable)
+		self.enabletooltips = enable
+	end,
+
+	["CreateButton"] = function(self)
+		local num = AceGUI:GetNextWidgetNum("TreeGroupButton")
+		local button = CreateFrame("Button", ("AceGUI30TreeButton%d"):format(num), self.treeframe, "OptionsListButtonTemplate")
+		button.obj = self
+
+		local icon = button:CreateTexture(nil, "OVERLAY")
+		icon:SetWidth(14)
+		icon:SetHeight(14)
+		button.icon = icon
+
+		button:SetScript("OnClick",Button_OnClick)
+		button:SetScript("OnDoubleClick", Button_OnDoubleClick)
+		button:SetScript("OnEnter",Button_OnEnter)
+		button:SetScript("OnLeave",Button_OnLeave)
+
+		button.toggle.button = button
+		button.toggle:SetScript("OnClick",Expand_OnClick)
+
+		button.text:SetHeight(14) -- Prevents text wrapping
+
+		return button
+	end,
+
+	["SetStatusTable"] = function(self, status)
+		assert(type(status) == "table")
+		self.status = status
+		if not status.groups then
+			status.groups = {}
+		end
+		if not status.scrollvalue then
+			status.scrollvalue = 0
+		end
+		if not status.treewidth then
+			status.treewidth = DEFAULT_TREE_WIDTH
+		end
+		if status.treesizable == nil then
+			status.treesizable = DEFAULT_TREE_SIZABLE
+		end
+		self:SetTreeWidth(status.treewidth,status.treesizable)
+		self:RefreshTree()
+	end,
+
+	--sets the tree to be displayed
+	["SetTree"] = function(self, tree, filter)
+		self.filter = filter
+		if tree then
+			assert(type(tree) == "table")
+		end
+		self.tree = tree
+		self:RefreshTree()
+	end,
+
+	["BuildLevel"] = function(self, tree, level, parent)
+		local groups = (self.status or self.localstatus).groups
+
+		for i, v in ipairs(tree) do
+			if v.children then
+				if not self.filter or ShouldDisplayLevel(v.children) then
+					local line = addLine(self, v, tree, level, parent)
+					if groups[line.uniquevalue] then
+						self:BuildLevel(v.children, level+1, line)
+					end
+				end
+			elseif v.visible ~= false or not self.filter then
+				addLine(self, v, tree, level, parent)
+			end
+		end
+	end,
+
+	["RefreshTree"] = function(self,scrollToSelection,fromOnUpdate)
+		local buttons = self.buttons
+		local lines = self.lines
+
+		for i, v in ipairs(buttons) do
+			v:Hide()
+		end
+		while lines[1] do
+			local t = tremove(lines)
+			for k in pairs(t) do
+				t[k] = nil
+			end
+			del(t)
+		end
+
+		if not self.tree then return end
+		--Build the list of visible entries from the tree and status tables
+		local status = self.status or self.localstatus
+		local groupstatus = status.groups
+		local tree = self.tree
+
+		local treeframe = self.treeframe
+
+		status.scrollToSelection = status.scrollToSelection or scrollToSelection	-- needs to be cached in case the control hasn't been drawn yet (code bails out below)
+
+		self:BuildLevel(tree, 1)
+
+		local numlines = #lines
+
+		local maxlines = (floor(((self.treeframe:GetHeight()or 0) - 20 ) / 18))
+		if maxlines <= 0 then return end
+
+		if self.frame:GetParent() == UIParent and not fromOnUpdate then
+			self.frame:SetScript("OnUpdate", FirstFrameUpdate)
+			return
+		end
+
+		local first, last
+
+		scrollToSelection = status.scrollToSelection
+		status.scrollToSelection = nil
+
+		if numlines <= maxlines then
+			--the whole tree fits in the frame
+			status.scrollvalue = 0
+			self:ShowScroll(false)
+			first, last = 1, numlines
+		else
+			self:ShowScroll(true)
+			--scrolling will be needed
+			self.noupdate = true
+			self.scrollbar:SetMinMaxValues(0, numlines - maxlines)
+			--check if we are scrolled down too far
+			if numlines - status.scrollvalue < maxlines then
+				status.scrollvalue = numlines - maxlines
+			end
+			self.noupdate = nil
+			first, last = status.scrollvalue+1, status.scrollvalue + maxlines
+			--show selection?
+			if scrollToSelection and status.selected then
+				local show
+				for i,line in ipairs(lines) do	-- find the line number
+					if line.uniquevalue==status.selected then
+						show=i
+					end
+				end
+				if not show then
+					-- selection was deleted or something?
+				elseif show>=first and show<=last then
+					-- all good
+				else
+					-- scrolling needed!
+					if show<first then
+						status.scrollvalue = show-1
+					else
+						status.scrollvalue = show-maxlines
+					end
+					first, last = status.scrollvalue+1, status.scrollvalue + maxlines
+				end
+			end
+			if self.scrollbar:GetValue() ~= status.scrollvalue then
+				self.scrollbar:SetValue(status.scrollvalue)
+			end
+		end
+
+		local buttonnum = 1
+		for i = first, last do
+			local line = lines[i]
+			local button = buttons[buttonnum]
+			if not button then
+				button = self:CreateButton()
+
+				buttons[buttonnum] = button
+				button:SetParent(treeframe)
+				button:SetFrameLevel(treeframe:GetFrameLevel()+1)
+				button:ClearAllPoints()
+				if buttonnum == 1 then
+					if self.showscroll then
+						button:SetPoint("TOPRIGHT", -22, -10)
+						button:SetPoint("TOPLEFT", 0, -10)
+					else
+						button:SetPoint("TOPRIGHT", 0, -10)
+						button:SetPoint("TOPLEFT", 0, -10)
+					end
+				else
+					button:SetPoint("TOPRIGHT", buttons[buttonnum-1], "BOTTOMRIGHT",0,0)
+					button:SetPoint("TOPLEFT", buttons[buttonnum-1], "BOTTOMLEFT",0,0)
+				end
+			end
+
+			UpdateButton(button, line, status.selected == line.uniquevalue, line.hasChildren, groupstatus[line.uniquevalue] )
+			button:Show()
+			buttonnum = buttonnum + 1
+		end
+
+	end,
+
+	["SetSelected"] = function(self, value)
+		local status = self.status or self.localstatus
+		if status.selected ~= value then
+			status.selected = value
+			self:Fire("OnGroupSelected", value)
+		end
+	end,
+
+	["Select"] = function(self, uniquevalue, ...)
+		self.filter = false
+		local status = self.status or self.localstatus
+		local groups = status.groups
+		local path = {...}
+		for i = 1, #path do
+			groups[tconcat(path, "\001", 1, i)] = true
+		end
+		status.selected = uniquevalue
+		self:RefreshTree(true)
+		self:Fire("OnGroupSelected", uniquevalue)
+	end,
+
+	["SelectByPath"] = function(self, ...)
+		self:Select(BuildUniqueValue(...), ...)
+	end,
+
+	["SelectByValue"] = function(self, uniquevalue)
+		self:Select(uniquevalue, ("\001"):split(uniquevalue))
+	end,
+
+	["ShowScroll"] = function(self, show)
+		self.showscroll = show
+		if show then
+			self.scrollbar:Show()
+			if self.buttons[1] then
+				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe,"TOPRIGHT",-22,-10)
+			end
+		else
+			self.scrollbar:Hide()
+			if self.buttons[1] then
+				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe,"TOPRIGHT",0,-10)
+			end
+		end
+	end,
+
+	["OnWidthSet"] = function(self, width)
+		local content = self.content
+		local treeframe = self.treeframe
+		local status = self.status or self.localstatus
+		status.fullwidth = width
+
+		local contentwidth = width - status.treewidth - 20
+		if contentwidth < 0 then
+			contentwidth = 0
+		end
+		content:SetWidth(contentwidth)
+		content.width = contentwidth
+
+		local maxtreewidth = math_min(400, width - 50)
+
+		if maxtreewidth > 100 and status.treewidth > maxtreewidth then
+			self:SetTreeWidth(maxtreewidth, status.treesizable)
+		end
+		if treeframe.SetResizeBounds then
+			treeframe:SetResizeBounds(100, 1, maxtreewidth, 1600)
+		else
+			treeframe:SetMaxResize(maxtreewidth, 1600)
+		end
+	end,
+
+	["OnHeightSet"] = function(self, height)
+		local content = self.content
+		local contentheight = height - 20
+		if contentheight < 0 then
+			contentheight = 0
+		end
+		content:SetHeight(contentheight)
+		content.height = contentheight
+	end,
+
+	["SetTreeWidth"] = function(self, treewidth, resizable)
+		if not resizable then
+			if type(treewidth) == 'number' then
+				resizable = false
+			elseif type(treewidth) == 'boolean' then
+				resizable = treewidth
+				treewidth = DEFAULT_TREE_WIDTH
+			else
+				resizable = false
+				treewidth = DEFAULT_TREE_WIDTH
+			end
+		end
+		self.treeframe:SetWidth(treewidth)
+		self.dragger:EnableMouse(resizable)
+
+		local status = self.status or self.localstatus
+		status.treewidth = treewidth
+		status.treesizable = resizable
+
+		-- recalculate the content width
+		if status.fullwidth then
+			self:OnWidthSet(status.fullwidth)
+		end
+	end,
+
+	["GetTreeWidth"] = function(self)
+		local status = self.status or self.localstatus
+		return status.treewidth or DEFAULT_TREE_WIDTH
+	end,
+
+	["LayoutFinished"] = function(self, width, height)
+		if self.noAutoHeight then return end
+		self:SetHeight((height or 0) + 20)
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local PaneBackdrop  = {
+	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
+	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
+	tile = true, tileSize = 16, edgeSize = 16,
+	insets = { left = 3, right = 3, top = 5, bottom = 3 }
+}
+
+local DraggerBackdrop  = {
+	bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
+	edgeFile = nil,
+	tile = true, tileSize = 16, edgeSize = 1,
+	insets = { left = 3, right = 3, top = 7, bottom = 7 }
+}
+
+local function Constructor()
+	local num = AceGUI:GetNextWidgetNum(Type)
+	local frame = CreateFrame("Frame", nil, UIParent)
+
+	local treeframe = CreateFrame("Frame", nil, frame, "BackdropTemplate")
+	treeframe:SetPoint("TOPLEFT")
+	treeframe:SetPoint("BOTTOMLEFT")
+	treeframe:SetWidth(DEFAULT_TREE_WIDTH)
+	treeframe:EnableMouseWheel(true)
+	treeframe:SetBackdrop(PaneBackdrop)
+	treeframe:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
+	treeframe:SetBackdropBorderColor(0.4, 0.4, 0.4)
+	treeframe:SetResizable(true)
+	if treeframe.SetResizeBounds then -- WoW 10.0
+		treeframe:SetResizeBounds(100, 1, 400, 1600)
+	else
+		treeframe:SetMinResize(100, 1)
+		treeframe:SetMaxResize(400, 1600)
+	end
+	treeframe:SetScript("OnUpdate", FirstFrameUpdate)
+	treeframe:SetScript("OnSizeChanged", Tree_OnSizeChanged)
+	treeframe:SetScript("OnMouseWheel", Tree_OnMouseWheel)
+
+	local dragger = CreateFrame("Frame", nil, treeframe, "BackdropTemplate")
+	dragger:SetWidth(8)
+	dragger:SetPoint("TOP", treeframe, "TOPRIGHT")
+	dragger:SetPoint("BOTTOM", treeframe, "BOTTOMRIGHT")
+	dragger:SetBackdrop(DraggerBackdrop)
+	dragger:SetBackdropColor(1, 1, 1, 0)
+	dragger:SetScript("OnEnter", Dragger_OnEnter)
+	dragger:SetScript("OnLeave", Dragger_OnLeave)
+	dragger:SetScript("OnMouseDown", Dragger_OnMouseDown)
+	dragger:SetScript("OnMouseUp", Dragger_OnMouseUp)
+
+	local scrollbar = CreateFrame("Slider", ("AceConfigDialogTreeGroup%dScrollBar"):format(num), treeframe, "UIPanelScrollBarTemplate")
+	scrollbar:SetScript("OnValueChanged", nil)
+	scrollbar:SetPoint("TOPRIGHT", -10, -26)
+	scrollbar:SetPoint("BOTTOMRIGHT", -10, 26)
+	scrollbar:SetMinMaxValues(0,0)
+	scrollbar:SetValueStep(1)
+	scrollbar:SetValue(0)
+	scrollbar:SetWidth(16)
+	scrollbar:SetScript("OnValueChanged", OnScrollValueChanged)
+
+	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
+	scrollbg:SetAllPoints(scrollbar)
+	scrollbg:SetColorTexture(0,0,0,0.4)
+
+	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
+	border:SetPoint("TOPLEFT", treeframe, "TOPRIGHT")
+	border:SetPoint("BOTTOMRIGHT")
+	border:SetBackdrop(PaneBackdrop)
+	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
+	border:SetBackdropBorderColor(0.4, 0.4, 0.4)
+
+	--Container Support
+	local content = CreateFrame("Frame", nil, border)
+	content:SetPoint("TOPLEFT", 10, -10)
+	content:SetPoint("BOTTOMRIGHT", -10, 10)
+
+	local widget = {
+		frame        = frame,
+		lines        = {},
+		levels       = {},
+		buttons      = {},
+		hasChildren  = {},
+		localstatus  = { groups = {}, scrollvalue = 0 },
+		filter       = false,
+		treeframe    = treeframe,
+		dragger      = dragger,
+		scrollbar    = scrollbar,
+		border       = border,
+		content      = content,
+		type         = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+	treeframe.obj, dragger.obj, scrollbar.obj = widget, widget, widget
+
+	return AceGUI:RegisterAsContainer(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-Window.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-Window.lua
index 5729bfd..f378d93 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-Window.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIContainer-Window.lua
@@ -1,336 +1,336 @@
-local AceGUI = LibStub("AceGUI-3.0")
-
--- Lua APIs
-local pairs, assert, type = pairs, assert, type
-
--- WoW APIs
-local PlaySound = PlaySound
-local CreateFrame, UIParent = CreateFrame, UIParent
-
-----------------
--- Main Frame --
-----------------
---[[
-	Events :
-		OnClose
-
-]]
-do
-	local Type = "Window"
-	local Version = 8
-
-	local function frameOnShow(this)
-		this.obj:Fire("OnShow")
-	end
-
-	local function frameOnClose(this)
-		this.obj:Fire("OnClose")
-	end
-
-	local function closeOnClick(this)
-		PlaySound(799) -- SOUNDKIT.GS_TITLE_OPTION_EXIT
-		this.obj:Hide()
-	end
-
-	local function frameOnMouseDown(this)
-		AceGUI:ClearFocus()
-	end
-
-	local function titleOnMouseDown(this)
-		this:GetParent():StartMoving()
-		AceGUI:ClearFocus()
-	end
-
-	local function frameOnMouseUp(this)
-		local frame = this:GetParent()
-		frame:StopMovingOrSizing()
-		local self = frame.obj
-		local status = self.status or self.localstatus
-		status.width = frame:GetWidth()
-		status.height = frame:GetHeight()
-		status.top = frame:GetTop()
-		status.left = frame:GetLeft()
-	end
-
-	local function sizerseOnMouseDown(this)
-		this:GetParent():StartSizing("BOTTOMRIGHT")
-		AceGUI:ClearFocus()
-	end
-
-	local function sizersOnMouseDown(this)
-		this:GetParent():StartSizing("BOTTOM")
-		AceGUI:ClearFocus()
-	end
-
-	local function sizereOnMouseDown(this)
-		this:GetParent():StartSizing("RIGHT")
-		AceGUI:ClearFocus()
-	end
-
-	local function sizerOnMouseUp(this)
-		this:GetParent():StopMovingOrSizing()
-	end
-
-	local function SetTitle(self,title)
-		self.titletext:SetText(title)
-	end
-
-	local function SetStatusText(self,text)
-		-- self.statustext:SetText(text)
-	end
-
-	local function Hide(self)
-		self.frame:Hide()
-	end
-
-	local function Show(self)
-		self.frame:Show()
-	end
-
-	local function OnAcquire(self)
-		self.frame:SetParent(UIParent)
-		self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
-		self:ApplyStatus()
-		self:EnableResize(true)
-		self:Show()
-	end
-
-	local function OnRelease(self)
-		self.status = nil
-		for k in pairs(self.localstatus) do
-			self.localstatus[k] = nil
-		end
-	end
-
-	-- called to set an external table to store status in
-	local function SetStatusTable(self, status)
-		assert(type(status) == "table")
-		self.status = status
-		self:ApplyStatus()
-	end
-
-	local function ApplyStatus(self)
-		local status = self.status or self.localstatus
-		local frame = self.frame
-		self:SetWidth(status.width or 700)
-		self:SetHeight(status.height or 500)
-		if status.top and status.left then
-			frame:SetPoint("TOP",UIParent,"BOTTOM",0,status.top)
-			frame:SetPoint("LEFT",UIParent,"LEFT",status.left,0)
-		else
-			frame:SetPoint("CENTER",UIParent,"CENTER")
-		end
-	end
-
-	local function OnWidthSet(self, width)
-		local content = self.content
-		local contentwidth = width - 34
-		if contentwidth < 0 then
-			contentwidth = 0
-		end
-		content:SetWidth(contentwidth)
-		content.width = contentwidth
-	end
-
-
-	local function OnHeightSet(self, height)
-		local content = self.content
-		local contentheight = height - 57
-		if contentheight < 0 then
-			contentheight = 0
-		end
-		content:SetHeight(contentheight)
-		content.height = contentheight
-	end
-
-	local function EnableResize(self, state)
-		local func = state and "Show" or "Hide"
-		self.sizer_se[func](self.sizer_se)
-		self.sizer_s[func](self.sizer_s)
-		self.sizer_e[func](self.sizer_e)
-	end
-
-	local function Constructor()
-		local frame = CreateFrame("Frame",nil,UIParent)
-		local self = {}
-		self.type = "Window"
-
-		self.Hide = Hide
-		self.Show = Show
-		self.SetTitle =  SetTitle
-		self.OnRelease = OnRelease
-		self.OnAcquire = OnAcquire
-		self.SetStatusText = SetStatusText
-		self.SetStatusTable = SetStatusTable
-		self.ApplyStatus = ApplyStatus
-		self.OnWidthSet = OnWidthSet
-		self.OnHeightSet = OnHeightSet
-		self.EnableResize = EnableResize
-
-		self.localstatus = {}
-
-		self.frame = frame
-		frame.obj = self
-		frame:SetWidth(700)
-		frame:SetHeight(500)
-		frame:SetPoint("CENTER",UIParent,"CENTER",0,0)
-		frame:EnableMouse()
-		frame:SetMovable(true)
-		frame:SetResizable(true)
-		frame:SetFrameStrata("FULLSCREEN_DIALOG")
-		frame:SetScript("OnMouseDown", frameOnMouseDown)
-
-		frame:SetScript("OnShow",frameOnShow)
-		frame:SetScript("OnHide",frameOnClose)
-		if frame.SetResizeBounds then -- WoW 10.0
-			frame:SetResizeBounds(240,240)
-		else
-			frame:SetMinResize(240,240)
-		end
-		frame:SetToplevel(true)
-
-		local titlebg = frame:CreateTexture(nil, "BACKGROUND")
-		titlebg:SetTexture(251966) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Title-Background
-		titlebg:SetPoint("TOPLEFT", 9, -6)
-		titlebg:SetPoint("BOTTOMRIGHT", frame, "TOPRIGHT", -28, -24)
-
-		local dialogbg = frame:CreateTexture(nil, "BACKGROUND")
-		dialogbg:SetTexture(137056) -- Interface\\Tooltips\\UI-Tooltip-Background
-		dialogbg:SetPoint("TOPLEFT", 8, -24)
-		dialogbg:SetPoint("BOTTOMRIGHT", -6, 8)
-		dialogbg:SetVertexColor(0, 0, 0, .75)
-
-		local topleft = frame:CreateTexture(nil, "BORDER")
-		topleft:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
-		topleft:SetWidth(64)
-		topleft:SetHeight(64)
-		topleft:SetPoint("TOPLEFT")
-		topleft:SetTexCoord(0.501953125, 0.625, 0, 1)
-
-		local topright = frame:CreateTexture(nil, "BORDER")
-		topright:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
-		topright:SetWidth(64)
-		topright:SetHeight(64)
-		topright:SetPoint("TOPRIGHT")
-		topright:SetTexCoord(0.625, 0.75, 0, 1)
-
-		local top = frame:CreateTexture(nil, "BORDER")
-		top:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
-		top:SetHeight(64)
-		top:SetPoint("TOPLEFT", topleft, "TOPRIGHT")
-		top:SetPoint("TOPRIGHT", topright, "TOPLEFT")
-		top:SetTexCoord(0.25, 0.369140625, 0, 1)
-
-		local bottomleft = frame:CreateTexture(nil, "BORDER")
-		bottomleft:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
-		bottomleft:SetWidth(64)
-		bottomleft:SetHeight(64)
-		bottomleft:SetPoint("BOTTOMLEFT")
-		bottomleft:SetTexCoord(0.751953125, 0.875, 0, 1)
-
-		local bottomright = frame:CreateTexture(nil, "BORDER")
-		bottomright:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
-		bottomright:SetWidth(64)
-		bottomright:SetHeight(64)
-		bottomright:SetPoint("BOTTOMRIGHT")
-		bottomright:SetTexCoord(0.875, 1, 0, 1)
-
-		local bottom = frame:CreateTexture(nil, "BORDER")
-		bottom:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
-		bottom:SetHeight(64)
-		bottom:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMRIGHT")
-		bottom:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMLEFT")
-		bottom:SetTexCoord(0.376953125, 0.498046875, 0, 1)
-
-		local left = frame:CreateTexture(nil, "BORDER")
-		left:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
-		left:SetWidth(64)
-		left:SetPoint("TOPLEFT", topleft, "BOTTOMLEFT")
-		left:SetPoint("BOTTOMLEFT", bottomleft, "TOPLEFT")
-		left:SetTexCoord(0.001953125, 0.125, 0, 1)
-
-		local right = frame:CreateTexture(nil, "BORDER")
-		right:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
-		right:SetWidth(64)
-		right:SetPoint("TOPRIGHT", topright, "BOTTOMRIGHT")
-		right:SetPoint("BOTTOMRIGHT", bottomright, "TOPRIGHT")
-		right:SetTexCoord(0.1171875, 0.2421875, 0, 1)
-
-		local close = CreateFrame("Button", nil, frame, "UIPanelCloseButton")
-		close:SetPoint("TOPRIGHT", 2, 1)
-		close:SetScript("OnClick", closeOnClick)
-		self.closebutton = close
-		close.obj = self
-
-		local titletext = frame:CreateFontString(nil, "ARTWORK")
-		titletext:SetFontObject(GameFontNormal)
-		titletext:SetPoint("TOPLEFT", 12, -8)
-		titletext:SetPoint("TOPRIGHT", -32, -8)
-		self.titletext = titletext
-
-		local title = CreateFrame("Button", nil, frame)
-		title:SetPoint("TOPLEFT", titlebg)
-		title:SetPoint("BOTTOMRIGHT", titlebg)
-		title:EnableMouse()
-		title:SetScript("OnMouseDown",titleOnMouseDown)
-		title:SetScript("OnMouseUp", frameOnMouseUp)
-		self.title = title
-
-		local sizer_se = CreateFrame("Frame",nil,frame)
-		sizer_se:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",0,0)
-		sizer_se:SetWidth(25)
-		sizer_se:SetHeight(25)
-		sizer_se:EnableMouse()
-		sizer_se:SetScript("OnMouseDown",sizerseOnMouseDown)
-		sizer_se:SetScript("OnMouseUp", sizerOnMouseUp)
-		self.sizer_se = sizer_se
-
-		local line1 = sizer_se:CreateTexture(nil, "BACKGROUND")
-		self.line1 = line1
-		line1:SetWidth(14)
-		line1:SetHeight(14)
-		line1:SetPoint("BOTTOMRIGHT", -8, 8)
-		line1:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
-		local x = 0.1 * 14/17
-		line1:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)
-
-		local line2 = sizer_se:CreateTexture(nil, "BACKGROUND")
-		self.line2 = line2
-		line2:SetWidth(8)
-		line2:SetHeight(8)
-		line2:SetPoint("BOTTOMRIGHT", -8, 8)
-		line2:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
-		x = 0.1 * 8/17
-		line2:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)
-
-		local sizer_s = CreateFrame("Frame",nil,frame)
-		sizer_s:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-25,0)
-		sizer_s:SetPoint("BOTTOMLEFT",frame,"BOTTOMLEFT",0,0)
-		sizer_s:SetHeight(25)
-		sizer_s:EnableMouse()
-		sizer_s:SetScript("OnMouseDown",sizersOnMouseDown)
-		sizer_s:SetScript("OnMouseUp", sizerOnMouseUp)
-		self.sizer_s = sizer_s
-
-		local sizer_e = CreateFrame("Frame",nil,frame)
-		sizer_e:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",0,25)
-		sizer_e:SetPoint("TOPRIGHT",frame,"TOPRIGHT",0,0)
-		sizer_e:SetWidth(25)
-		sizer_e:EnableMouse()
-		sizer_e:SetScript("OnMouseDown",sizereOnMouseDown)
-		sizer_e:SetScript("OnMouseUp", sizerOnMouseUp)
-		self.sizer_e = sizer_e
-
-		--Container Support
-		local content = CreateFrame("Frame",nil,frame)
-		self.content = content
-		content.obj = self
-		content:SetPoint("TOPLEFT",frame,"TOPLEFT",12,-32)
-		content:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-12,13)
-
-		AceGUI:RegisterAsContainer(self)
-		return self
-	end
-
-	AceGUI:RegisterWidgetType(Type,Constructor,Version)
-end
+local AceGUI = LibStub("AceGUI-3.0")
+
+-- Lua APIs
+local pairs, assert, type = pairs, assert, type
+
+-- WoW APIs
+local PlaySound = PlaySound
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+----------------
+-- Main Frame --
+----------------
+--[[
+	Events :
+		OnClose
+
+]]
+do
+	local Type = "Window"
+	local Version = 8
+
+	local function frameOnShow(this)
+		this.obj:Fire("OnShow")
+	end
+
+	local function frameOnClose(this)
+		this.obj:Fire("OnClose")
+	end
+
+	local function closeOnClick(this)
+		PlaySound(799) -- SOUNDKIT.GS_TITLE_OPTION_EXIT
+		this.obj:Hide()
+	end
+
+	local function frameOnMouseDown(this)
+		AceGUI:ClearFocus()
+	end
+
+	local function titleOnMouseDown(this)
+		this:GetParent():StartMoving()
+		AceGUI:ClearFocus()
+	end
+
+	local function frameOnMouseUp(this)
+		local frame = this:GetParent()
+		frame:StopMovingOrSizing()
+		local self = frame.obj
+		local status = self.status or self.localstatus
+		status.width = frame:GetWidth()
+		status.height = frame:GetHeight()
+		status.top = frame:GetTop()
+		status.left = frame:GetLeft()
+	end
+
+	local function sizerseOnMouseDown(this)
+		this:GetParent():StartSizing("BOTTOMRIGHT")
+		AceGUI:ClearFocus()
+	end
+
+	local function sizersOnMouseDown(this)
+		this:GetParent():StartSizing("BOTTOM")
+		AceGUI:ClearFocus()
+	end
+
+	local function sizereOnMouseDown(this)
+		this:GetParent():StartSizing("RIGHT")
+		AceGUI:ClearFocus()
+	end
+
+	local function sizerOnMouseUp(this)
+		this:GetParent():StopMovingOrSizing()
+	end
+
+	local function SetTitle(self,title)
+		self.titletext:SetText(title)
+	end
+
+	local function SetStatusText(self,text)
+		-- self.statustext:SetText(text)
+	end
+
+	local function Hide(self)
+		self.frame:Hide()
+	end
+
+	local function Show(self)
+		self.frame:Show()
+	end
+
+	local function OnAcquire(self)
+		self.frame:SetParent(UIParent)
+		self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
+		self:ApplyStatus()
+		self:EnableResize(true)
+		self:Show()
+	end
+
+	local function OnRelease(self)
+		self.status = nil
+		for k in pairs(self.localstatus) do
+			self.localstatus[k] = nil
+		end
+	end
+
+	-- called to set an external table to store status in
+	local function SetStatusTable(self, status)
+		assert(type(status) == "table")
+		self.status = status
+		self:ApplyStatus()
+	end
+
+	local function ApplyStatus(self)
+		local status = self.status or self.localstatus
+		local frame = self.frame
+		self:SetWidth(status.width or 700)
+		self:SetHeight(status.height or 500)
+		if status.top and status.left then
+			frame:SetPoint("TOP",UIParent,"BOTTOM",0,status.top)
+			frame:SetPoint("LEFT",UIParent,"LEFT",status.left,0)
+		else
+			frame:SetPoint("CENTER",UIParent,"CENTER")
+		end
+	end
+
+	local function OnWidthSet(self, width)
+		local content = self.content
+		local contentwidth = width - 34
+		if contentwidth < 0 then
+			contentwidth = 0
+		end
+		content:SetWidth(contentwidth)
+		content.width = contentwidth
+	end
+
+
+	local function OnHeightSet(self, height)
+		local content = self.content
+		local contentheight = height - 57
+		if contentheight < 0 then
+			contentheight = 0
+		end
+		content:SetHeight(contentheight)
+		content.height = contentheight
+	end
+
+	local function EnableResize(self, state)
+		local func = state and "Show" or "Hide"
+		self.sizer_se[func](self.sizer_se)
+		self.sizer_s[func](self.sizer_s)
+		self.sizer_e[func](self.sizer_e)
+	end
+
+	local function Constructor()
+		local frame = CreateFrame("Frame",nil,UIParent)
+		local self = {}
+		self.type = "Window"
+
+		self.Hide = Hide
+		self.Show = Show
+		self.SetTitle =  SetTitle
+		self.OnRelease = OnRelease
+		self.OnAcquire = OnAcquire
+		self.SetStatusText = SetStatusText
+		self.SetStatusTable = SetStatusTable
+		self.ApplyStatus = ApplyStatus
+		self.OnWidthSet = OnWidthSet
+		self.OnHeightSet = OnHeightSet
+		self.EnableResize = EnableResize
+
+		self.localstatus = {}
+
+		self.frame = frame
+		frame.obj = self
+		frame:SetWidth(700)
+		frame:SetHeight(500)
+		frame:SetPoint("CENTER",UIParent,"CENTER",0,0)
+		frame:EnableMouse()
+		frame:SetMovable(true)
+		frame:SetResizable(true)
+		frame:SetFrameStrata("FULLSCREEN_DIALOG")
+		frame:SetScript("OnMouseDown", frameOnMouseDown)
+
+		frame:SetScript("OnShow",frameOnShow)
+		frame:SetScript("OnHide",frameOnClose)
+		if frame.SetResizeBounds then -- WoW 10.0
+			frame:SetResizeBounds(240,240)
+		else
+			frame:SetMinResize(240,240)
+		end
+		frame:SetToplevel(true)
+
+		local titlebg = frame:CreateTexture(nil, "BACKGROUND")
+		titlebg:SetTexture(251966) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Title-Background
+		titlebg:SetPoint("TOPLEFT", 9, -6)
+		titlebg:SetPoint("BOTTOMRIGHT", frame, "TOPRIGHT", -28, -24)
+
+		local dialogbg = frame:CreateTexture(nil, "BACKGROUND")
+		dialogbg:SetTexture(137056) -- Interface\\Tooltips\\UI-Tooltip-Background
+		dialogbg:SetPoint("TOPLEFT", 8, -24)
+		dialogbg:SetPoint("BOTTOMRIGHT", -6, 8)
+		dialogbg:SetVertexColor(0, 0, 0, .75)
+
+		local topleft = frame:CreateTexture(nil, "BORDER")
+		topleft:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
+		topleft:SetWidth(64)
+		topleft:SetHeight(64)
+		topleft:SetPoint("TOPLEFT")
+		topleft:SetTexCoord(0.501953125, 0.625, 0, 1)
+
+		local topright = frame:CreateTexture(nil, "BORDER")
+		topright:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
+		topright:SetWidth(64)
+		topright:SetHeight(64)
+		topright:SetPoint("TOPRIGHT")
+		topright:SetTexCoord(0.625, 0.75, 0, 1)
+
+		local top = frame:CreateTexture(nil, "BORDER")
+		top:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
+		top:SetHeight(64)
+		top:SetPoint("TOPLEFT", topleft, "TOPRIGHT")
+		top:SetPoint("TOPRIGHT", topright, "TOPLEFT")
+		top:SetTexCoord(0.25, 0.369140625, 0, 1)
+
+		local bottomleft = frame:CreateTexture(nil, "BORDER")
+		bottomleft:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
+		bottomleft:SetWidth(64)
+		bottomleft:SetHeight(64)
+		bottomleft:SetPoint("BOTTOMLEFT")
+		bottomleft:SetTexCoord(0.751953125, 0.875, 0, 1)
+
+		local bottomright = frame:CreateTexture(nil, "BORDER")
+		bottomright:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
+		bottomright:SetWidth(64)
+		bottomright:SetHeight(64)
+		bottomright:SetPoint("BOTTOMRIGHT")
+		bottomright:SetTexCoord(0.875, 1, 0, 1)
+
+		local bottom = frame:CreateTexture(nil, "BORDER")
+		bottom:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
+		bottom:SetHeight(64)
+		bottom:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMRIGHT")
+		bottom:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMLEFT")
+		bottom:SetTexCoord(0.376953125, 0.498046875, 0, 1)
+
+		local left = frame:CreateTexture(nil, "BORDER")
+		left:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
+		left:SetWidth(64)
+		left:SetPoint("TOPLEFT", topleft, "BOTTOMLEFT")
+		left:SetPoint("BOTTOMLEFT", bottomleft, "TOPLEFT")
+		left:SetTexCoord(0.001953125, 0.125, 0, 1)
+
+		local right = frame:CreateTexture(nil, "BORDER")
+		right:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
+		right:SetWidth(64)
+		right:SetPoint("TOPRIGHT", topright, "BOTTOMRIGHT")
+		right:SetPoint("BOTTOMRIGHT", bottomright, "TOPRIGHT")
+		right:SetTexCoord(0.1171875, 0.2421875, 0, 1)
+
+		local close = CreateFrame("Button", nil, frame, "UIPanelCloseButton")
+		close:SetPoint("TOPRIGHT", 2, 1)
+		close:SetScript("OnClick", closeOnClick)
+		self.closebutton = close
+		close.obj = self
+
+		local titletext = frame:CreateFontString(nil, "ARTWORK")
+		titletext:SetFontObject(GameFontNormal)
+		titletext:SetPoint("TOPLEFT", 12, -8)
+		titletext:SetPoint("TOPRIGHT", -32, -8)
+		self.titletext = titletext
+
+		local title = CreateFrame("Button", nil, frame)
+		title:SetPoint("TOPLEFT", titlebg)
+		title:SetPoint("BOTTOMRIGHT", titlebg)
+		title:EnableMouse()
+		title:SetScript("OnMouseDown",titleOnMouseDown)
+		title:SetScript("OnMouseUp", frameOnMouseUp)
+		self.title = title
+
+		local sizer_se = CreateFrame("Frame",nil,frame)
+		sizer_se:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",0,0)
+		sizer_se:SetWidth(25)
+		sizer_se:SetHeight(25)
+		sizer_se:EnableMouse()
+		sizer_se:SetScript("OnMouseDown",sizerseOnMouseDown)
+		sizer_se:SetScript("OnMouseUp", sizerOnMouseUp)
+		self.sizer_se = sizer_se
+
+		local line1 = sizer_se:CreateTexture(nil, "BACKGROUND")
+		self.line1 = line1
+		line1:SetWidth(14)
+		line1:SetHeight(14)
+		line1:SetPoint("BOTTOMRIGHT", -8, 8)
+		line1:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
+		local x = 0.1 * 14/17
+		line1:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)
+
+		local line2 = sizer_se:CreateTexture(nil, "BACKGROUND")
+		self.line2 = line2
+		line2:SetWidth(8)
+		line2:SetHeight(8)
+		line2:SetPoint("BOTTOMRIGHT", -8, 8)
+		line2:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
+		x = 0.1 * 8/17
+		line2:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)
+
+		local sizer_s = CreateFrame("Frame",nil,frame)
+		sizer_s:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-25,0)
+		sizer_s:SetPoint("BOTTOMLEFT",frame,"BOTTOMLEFT",0,0)
+		sizer_s:SetHeight(25)
+		sizer_s:EnableMouse()
+		sizer_s:SetScript("OnMouseDown",sizersOnMouseDown)
+		sizer_s:SetScript("OnMouseUp", sizerOnMouseUp)
+		self.sizer_s = sizer_s
+
+		local sizer_e = CreateFrame("Frame",nil,frame)
+		sizer_e:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",0,25)
+		sizer_e:SetPoint("TOPRIGHT",frame,"TOPRIGHT",0,0)
+		sizer_e:SetWidth(25)
+		sizer_e:EnableMouse()
+		sizer_e:SetScript("OnMouseDown",sizereOnMouseDown)
+		sizer_e:SetScript("OnMouseUp", sizerOnMouseUp)
+		self.sizer_e = sizer_e
+
+		--Container Support
+		local content = CreateFrame("Frame",nil,frame)
+		self.content = content
+		content.obj = self
+		content:SetPoint("TOPLEFT",frame,"TOPLEFT",12,-32)
+		content:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-12,13)
+
+		AceGUI:RegisterAsContainer(self)
+		return self
+	end
+
+	AceGUI:RegisterWidgetType(Type,Constructor,Version)
+end
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Button.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Button.lua
index 8e650ce..0e286ca 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Button.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Button.lua
@@ -1,103 +1,103 @@
---[[-----------------------------------------------------------------------------
-Button Widget
-Graphical Button.
--------------------------------------------------------------------------------]]
-local Type, Version = "Button", 24
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs = pairs
-
--- WoW APIs
-local _G = _G
-local PlaySound, CreateFrame, UIParent = PlaySound, CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Button_OnClick(frame, ...)
-	AceGUI:ClearFocus()
-	PlaySound(852) -- SOUNDKIT.IG_MAINMENU_OPTION
-	frame.obj:Fire("OnClick", ...)
-end
-
-local function Control_OnEnter(frame)
-	frame.obj:Fire("OnEnter")
-end
-
-local function Control_OnLeave(frame)
-	frame.obj:Fire("OnLeave")
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		-- restore default values
-		self:SetHeight(24)
-		self:SetWidth(200)
-		self:SetDisabled(false)
-		self:SetAutoWidth(false)
-		self:SetText()
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["SetText"] = function(self, text)
-		self.text:SetText(text)
-		if self.autoWidth then
-			self:SetWidth(self.text:GetStringWidth() + 30)
-		end
-	end,
-
-	["SetAutoWidth"] = function(self, autoWidth)
-		self.autoWidth = autoWidth
-		if self.autoWidth then
-			self:SetWidth(self.text:GetStringWidth() + 30)
-		end
-	end,
-
-	["SetDisabled"] = function(self, disabled)
-		self.disabled = disabled
-		if disabled then
-			self.frame:Disable()
-		else
-			self.frame:Enable()
-		end
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local name = "AceGUI30Button" .. AceGUI:GetNextWidgetNum(Type)
-	local frame = CreateFrame("Button", name, UIParent, "UIPanelButtonTemplate")
-	frame:Hide()
-
-	frame:EnableMouse(true)
-	frame:SetScript("OnClick", Button_OnClick)
-	frame:SetScript("OnEnter", Control_OnEnter)
-	frame:SetScript("OnLeave", Control_OnLeave)
-
-	local text = frame:GetFontString()
-	text:ClearAllPoints()
-	text:SetPoint("TOPLEFT", 15, -1)
-	text:SetPoint("BOTTOMRIGHT", -15, 1)
-	text:SetJustifyV("MIDDLE")
-
-	local widget = {
-		text  = text,
-		frame = frame,
-		type  = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+Button Widget
+Graphical Button.
+-------------------------------------------------------------------------------]]
+local Type, Version = "Button", 24
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs = pairs
+
+-- WoW APIs
+local _G = _G
+local PlaySound, CreateFrame, UIParent = PlaySound, CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Button_OnClick(frame, ...)
+	AceGUI:ClearFocus()
+	PlaySound(852) -- SOUNDKIT.IG_MAINMENU_OPTION
+	frame.obj:Fire("OnClick", ...)
+end
+
+local function Control_OnEnter(frame)
+	frame.obj:Fire("OnEnter")
+end
+
+local function Control_OnLeave(frame)
+	frame.obj:Fire("OnLeave")
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		-- restore default values
+		self:SetHeight(24)
+		self:SetWidth(200)
+		self:SetDisabled(false)
+		self:SetAutoWidth(false)
+		self:SetText()
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["SetText"] = function(self, text)
+		self.text:SetText(text)
+		if self.autoWidth then
+			self:SetWidth(self.text:GetStringWidth() + 30)
+		end
+	end,
+
+	["SetAutoWidth"] = function(self, autoWidth)
+		self.autoWidth = autoWidth
+		if self.autoWidth then
+			self:SetWidth(self.text:GetStringWidth() + 30)
+		end
+	end,
+
+	["SetDisabled"] = function(self, disabled)
+		self.disabled = disabled
+		if disabled then
+			self.frame:Disable()
+		else
+			self.frame:Enable()
+		end
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local name = "AceGUI30Button" .. AceGUI:GetNextWidgetNum(Type)
+	local frame = CreateFrame("Button", name, UIParent, "UIPanelButtonTemplate")
+	frame:Hide()
+
+	frame:EnableMouse(true)
+	frame:SetScript("OnClick", Button_OnClick)
+	frame:SetScript("OnEnter", Control_OnEnter)
+	frame:SetScript("OnLeave", Control_OnLeave)
+
+	local text = frame:GetFontString()
+	text:ClearAllPoints()
+	text:SetPoint("TOPLEFT", 15, -1)
+	text:SetPoint("BOTTOMRIGHT", -15, 1)
+	text:SetJustifyV("MIDDLE")
+
+	local widget = {
+		text  = text,
+		frame = frame,
+		type  = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-CheckBox.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-CheckBox.lua
index 6e64292..fe17e03 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-CheckBox.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-CheckBox.lua
@@ -1,292 +1,292 @@
---[[-----------------------------------------------------------------------------
-Checkbox Widget
--------------------------------------------------------------------------------]]
-local Type, Version = "CheckBox", 26
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local select, pairs = select, pairs
-
--- WoW APIs
-local PlaySound = PlaySound
-local CreateFrame, UIParent = CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-local function AlignImage(self)
-	local img = self.image:GetTexture()
-	self.text:ClearAllPoints()
-	if not img then
-		self.text:SetPoint("LEFT", self.checkbg, "RIGHT")
-		self.text:SetPoint("RIGHT")
-	else
-		self.text:SetPoint("LEFT", self.image, "RIGHT", 1, 0)
-		self.text:SetPoint("RIGHT")
-	end
-end
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Control_OnEnter(frame)
-	frame.obj:Fire("OnEnter")
-end
-
-local function Control_OnLeave(frame)
-	frame.obj:Fire("OnLeave")
-end
-
-local function CheckBox_OnMouseDown(frame)
-	local self = frame.obj
-	if not self.disabled then
-		if self.image:GetTexture() then
-			self.text:SetPoint("LEFT", self.image,"RIGHT", 2, -1)
-		else
-			self.text:SetPoint("LEFT", self.checkbg, "RIGHT", 1, -1)
-		end
-	end
-	AceGUI:ClearFocus()
-end
-
-local function CheckBox_OnMouseUp(frame)
-	local self = frame.obj
-	if not self.disabled then
-		self:ToggleChecked()
-
-		if self.checked then
-			PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
-		else -- for both nil and false (tristate)
-			PlaySound(857) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_OFF
-		end
-
-		self:Fire("OnValueChanged", self.checked)
-		AlignImage(self)
-	end
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetType()
-		self:SetValue(false)
-		self:SetTriState(nil)
-		-- height is calculated from the width and required space for the description
-		self:SetWidth(200)
-		self:SetImage()
-		self:SetDisabled(nil)
-		self:SetDescription(nil)
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["OnWidthSet"] = function(self, width)
-		if self.desc then
-			self.desc:SetWidth(width - 30)
-			if self.desc:GetText() and self.desc:GetText() ~= "" then
-				self:SetHeight(28 + self.desc:GetStringHeight())
-			end
-		end
-	end,
-
-	["SetDisabled"] = function(self, disabled)
-		self.disabled = disabled
-		if disabled then
-			self.frame:Disable()
-			self.text:SetTextColor(0.5, 0.5, 0.5)
-			SetDesaturation(self.check, true)
-			if self.desc then
-				self.desc:SetTextColor(0.5, 0.5, 0.5)
-			end
-		else
-			self.frame:Enable()
-			self.text:SetTextColor(1, 1, 1)
-			if self.tristate and self.checked == nil then
-				SetDesaturation(self.check, true)
-			else
-				SetDesaturation(self.check, false)
-			end
-			if self.desc then
-				self.desc:SetTextColor(1, 1, 1)
-			end
-		end
-	end,
-
-	["SetValue"] = function(self, value)
-		local check = self.check
-		self.checked = value
-		if value then
-			SetDesaturation(check, false)
-			check:Show()
-		else
-			--Nil is the unknown tristate value
-			if self.tristate and value == nil then
-				SetDesaturation(check, true)
-				check:Show()
-			else
-				SetDesaturation(check, false)
-				check:Hide()
-			end
-		end
-		self:SetDisabled(self.disabled)
-	end,
-
-	["GetValue"] = function(self)
-		return self.checked
-	end,
-
-	["SetTriState"] = function(self, enabled)
-		self.tristate = enabled
-		self:SetValue(self:GetValue())
-	end,
-
-	["SetType"] = function(self, type)
-		local checkbg = self.checkbg
-		local check = self.check
-		local highlight = self.highlight
-
-		local size
-		if type == "radio" then
-			size = 16
-			checkbg:SetTexture(130843) -- Interface\\Buttons\\UI-RadioButton
-			checkbg:SetTexCoord(0, 0.25, 0, 1)
-			check:SetTexture(130843) -- Interface\\Buttons\\UI-RadioButton
-			check:SetTexCoord(0.25, 0.5, 0, 1)
-			check:SetBlendMode("ADD")
-			highlight:SetTexture(130843) -- Interface\\Buttons\\UI-RadioButton
-			highlight:SetTexCoord(0.5, 0.75, 0, 1)
-		else
-			size = 24
-			checkbg:SetTexture(130755) -- Interface\\Buttons\\UI-CheckBox-Up
-			checkbg:SetTexCoord(0, 1, 0, 1)
-			check:SetTexture(130751) -- Interface\\Buttons\\UI-CheckBox-Check
-			check:SetTexCoord(0, 1, 0, 1)
-			check:SetBlendMode("BLEND")
-			highlight:SetTexture(130753) -- Interface\\Buttons\\UI-CheckBox-Highlight
-			highlight:SetTexCoord(0, 1, 0, 1)
-		end
-		checkbg:SetHeight(size)
-		checkbg:SetWidth(size)
-	end,
-
-	["ToggleChecked"] = function(self)
-		local value = self:GetValue()
-		if self.tristate then
-			--cycle in true, nil, false order
-			if value then
-				self:SetValue(nil)
-			elseif value == nil then
-				self:SetValue(false)
-			else
-				self:SetValue(true)
-			end
-		else
-			self:SetValue(not self:GetValue())
-		end
-	end,
-
-	["SetLabel"] = function(self, label)
-		self.text:SetText(label)
-	end,
-
-	["SetDescription"] = function(self, desc)
-		if desc then
-			if not self.desc then
-				local f = self.frame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
-				f:ClearAllPoints()
-				f:SetPoint("TOPLEFT", self.checkbg, "TOPRIGHT", 5, -21)
-				f:SetWidth(self.frame.width - 30)
-				f:SetPoint("RIGHT", self.frame, "RIGHT", -30, 0)
-				f:SetJustifyH("LEFT")
-				f:SetJustifyV("TOP")
-				self.desc = f
-			end
-			self.desc:Show()
-			--self.text:SetFontObject(GameFontNormal)
-			self.desc:SetText(desc)
-			self:SetHeight(28 + self.desc:GetStringHeight())
-		else
-			if self.desc then
-				self.desc:SetText("")
-				self.desc:Hide()
-			end
-			--self.text:SetFontObject(GameFontHighlight)
-			self:SetHeight(24)
-		end
-	end,
-
-	["SetImage"] = function(self, path, ...)
-		local image = self.image
-		image:SetTexture(path)
-
-		if image:GetTexture() then
-			local n = select("#", ...)
-			if n == 4 or n == 8 then
-				image:SetTexCoord(...)
-			else
-				image:SetTexCoord(0, 1, 0, 1)
-			end
-		end
-		AlignImage(self)
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local frame = CreateFrame("Button", nil, UIParent)
-	frame:Hide()
-
-	frame:EnableMouse(true)
-	frame:SetScript("OnEnter", Control_OnEnter)
-	frame:SetScript("OnLeave", Control_OnLeave)
-	frame:SetScript("OnMouseDown", CheckBox_OnMouseDown)
-	frame:SetScript("OnMouseUp", CheckBox_OnMouseUp)
-
-	local checkbg = frame:CreateTexture(nil, "ARTWORK")
-	checkbg:SetWidth(24)
-	checkbg:SetHeight(24)
-	checkbg:SetPoint("TOPLEFT")
-	checkbg:SetTexture(130755) -- Interface\\Buttons\\UI-CheckBox-Up
-
-	local check = frame:CreateTexture(nil, "OVERLAY")
-	check:SetAllPoints(checkbg)
-	check:SetTexture(130751) -- Interface\\Buttons\\UI-CheckBox-Check
-
-	local text = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
-	text:SetJustifyH("LEFT")
-	text:SetHeight(18)
-	text:SetPoint("LEFT", checkbg, "RIGHT")
-	text:SetPoint("RIGHT")
-
-	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
-	highlight:SetTexture(130753) -- Interface\\Buttons\\UI-CheckBox-Highlight
-	highlight:SetBlendMode("ADD")
-	highlight:SetAllPoints(checkbg)
-
-	local image = frame:CreateTexture(nil, "OVERLAY")
-	image:SetHeight(16)
-	image:SetWidth(16)
-	image:SetPoint("LEFT", checkbg, "RIGHT", 1, 0)
-
-	local widget = {
-		checkbg   = checkbg,
-		check     = check,
-		text      = text,
-		highlight = highlight,
-		image     = image,
-		frame     = frame,
-		type      = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+Checkbox Widget
+-------------------------------------------------------------------------------]]
+local Type, Version = "CheckBox", 26
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local select, pairs = select, pairs
+
+-- WoW APIs
+local PlaySound = PlaySound
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+local function AlignImage(self)
+	local img = self.image:GetTexture()
+	self.text:ClearAllPoints()
+	if not img then
+		self.text:SetPoint("LEFT", self.checkbg, "RIGHT")
+		self.text:SetPoint("RIGHT")
+	else
+		self.text:SetPoint("LEFT", self.image, "RIGHT", 1, 0)
+		self.text:SetPoint("RIGHT")
+	end
+end
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Control_OnEnter(frame)
+	frame.obj:Fire("OnEnter")
+end
+
+local function Control_OnLeave(frame)
+	frame.obj:Fire("OnLeave")
+end
+
+local function CheckBox_OnMouseDown(frame)
+	local self = frame.obj
+	if not self.disabled then
+		if self.image:GetTexture() then
+			self.text:SetPoint("LEFT", self.image,"RIGHT", 2, -1)
+		else
+			self.text:SetPoint("LEFT", self.checkbg, "RIGHT", 1, -1)
+		end
+	end
+	AceGUI:ClearFocus()
+end
+
+local function CheckBox_OnMouseUp(frame)
+	local self = frame.obj
+	if not self.disabled then
+		self:ToggleChecked()
+
+		if self.checked then
+			PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
+		else -- for both nil and false (tristate)
+			PlaySound(857) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_OFF
+		end
+
+		self:Fire("OnValueChanged", self.checked)
+		AlignImage(self)
+	end
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetType()
+		self:SetValue(false)
+		self:SetTriState(nil)
+		-- height is calculated from the width and required space for the description
+		self:SetWidth(200)
+		self:SetImage()
+		self:SetDisabled(nil)
+		self:SetDescription(nil)
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["OnWidthSet"] = function(self, width)
+		if self.desc then
+			self.desc:SetWidth(width - 30)
+			if self.desc:GetText() and self.desc:GetText() ~= "" then
+				self:SetHeight(28 + self.desc:GetStringHeight())
+			end
+		end
+	end,
+
+	["SetDisabled"] = function(self, disabled)
+		self.disabled = disabled
+		if disabled then
+			self.frame:Disable()
+			self.text:SetTextColor(0.5, 0.5, 0.5)
+			SetDesaturation(self.check, true)
+			if self.desc then
+				self.desc:SetTextColor(0.5, 0.5, 0.5)
+			end
+		else
+			self.frame:Enable()
+			self.text:SetTextColor(1, 1, 1)
+			if self.tristate and self.checked == nil then
+				SetDesaturation(self.check, true)
+			else
+				SetDesaturation(self.check, false)
+			end
+			if self.desc then
+				self.desc:SetTextColor(1, 1, 1)
+			end
+		end
+	end,
+
+	["SetValue"] = function(self, value)
+		local check = self.check
+		self.checked = value
+		if value then
+			SetDesaturation(check, false)
+			check:Show()
+		else
+			--Nil is the unknown tristate value
+			if self.tristate and value == nil then
+				SetDesaturation(check, true)
+				check:Show()
+			else
+				SetDesaturation(check, false)
+				check:Hide()
+			end
+		end
+		self:SetDisabled(self.disabled)
+	end,
+
+	["GetValue"] = function(self)
+		return self.checked
+	end,
+
+	["SetTriState"] = function(self, enabled)
+		self.tristate = enabled
+		self:SetValue(self:GetValue())
+	end,
+
+	["SetType"] = function(self, type)
+		local checkbg = self.checkbg
+		local check = self.check
+		local highlight = self.highlight
+
+		local size
+		if type == "radio" then
+			size = 16
+			checkbg:SetTexture(130843) -- Interface\\Buttons\\UI-RadioButton
+			checkbg:SetTexCoord(0, 0.25, 0, 1)
+			check:SetTexture(130843) -- Interface\\Buttons\\UI-RadioButton
+			check:SetTexCoord(0.25, 0.5, 0, 1)
+			check:SetBlendMode("ADD")
+			highlight:SetTexture(130843) -- Interface\\Buttons\\UI-RadioButton
+			highlight:SetTexCoord(0.5, 0.75, 0, 1)
+		else
+			size = 24
+			checkbg:SetTexture(130755) -- Interface\\Buttons\\UI-CheckBox-Up
+			checkbg:SetTexCoord(0, 1, 0, 1)
+			check:SetTexture(130751) -- Interface\\Buttons\\UI-CheckBox-Check
+			check:SetTexCoord(0, 1, 0, 1)
+			check:SetBlendMode("BLEND")
+			highlight:SetTexture(130753) -- Interface\\Buttons\\UI-CheckBox-Highlight
+			highlight:SetTexCoord(0, 1, 0, 1)
+		end
+		checkbg:SetHeight(size)
+		checkbg:SetWidth(size)
+	end,
+
+	["ToggleChecked"] = function(self)
+		local value = self:GetValue()
+		if self.tristate then
+			--cycle in true, nil, false order
+			if value then
+				self:SetValue(nil)
+			elseif value == nil then
+				self:SetValue(false)
+			else
+				self:SetValue(true)
+			end
+		else
+			self:SetValue(not self:GetValue())
+		end
+	end,
+
+	["SetLabel"] = function(self, label)
+		self.text:SetText(label)
+	end,
+
+	["SetDescription"] = function(self, desc)
+		if desc then
+			if not self.desc then
+				local f = self.frame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
+				f:ClearAllPoints()
+				f:SetPoint("TOPLEFT", self.checkbg, "TOPRIGHT", 5, -21)
+				f:SetWidth(self.frame.width - 30)
+				f:SetPoint("RIGHT", self.frame, "RIGHT", -30, 0)
+				f:SetJustifyH("LEFT")
+				f:SetJustifyV("TOP")
+				self.desc = f
+			end
+			self.desc:Show()
+			--self.text:SetFontObject(GameFontNormal)
+			self.desc:SetText(desc)
+			self:SetHeight(28 + self.desc:GetStringHeight())
+		else
+			if self.desc then
+				self.desc:SetText("")
+				self.desc:Hide()
+			end
+			--self.text:SetFontObject(GameFontHighlight)
+			self:SetHeight(24)
+		end
+	end,
+
+	["SetImage"] = function(self, path, ...)
+		local image = self.image
+		image:SetTexture(path)
+
+		if image:GetTexture() then
+			local n = select("#", ...)
+			if n == 4 or n == 8 then
+				image:SetTexCoord(...)
+			else
+				image:SetTexCoord(0, 1, 0, 1)
+			end
+		end
+		AlignImage(self)
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local frame = CreateFrame("Button", nil, UIParent)
+	frame:Hide()
+
+	frame:EnableMouse(true)
+	frame:SetScript("OnEnter", Control_OnEnter)
+	frame:SetScript("OnLeave", Control_OnLeave)
+	frame:SetScript("OnMouseDown", CheckBox_OnMouseDown)
+	frame:SetScript("OnMouseUp", CheckBox_OnMouseUp)
+
+	local checkbg = frame:CreateTexture(nil, "ARTWORK")
+	checkbg:SetWidth(24)
+	checkbg:SetHeight(24)
+	checkbg:SetPoint("TOPLEFT")
+	checkbg:SetTexture(130755) -- Interface\\Buttons\\UI-CheckBox-Up
+
+	local check = frame:CreateTexture(nil, "OVERLAY")
+	check:SetAllPoints(checkbg)
+	check:SetTexture(130751) -- Interface\\Buttons\\UI-CheckBox-Check
+
+	local text = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
+	text:SetJustifyH("LEFT")
+	text:SetHeight(18)
+	text:SetPoint("LEFT", checkbg, "RIGHT")
+	text:SetPoint("RIGHT")
+
+	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
+	highlight:SetTexture(130753) -- Interface\\Buttons\\UI-CheckBox-Highlight
+	highlight:SetBlendMode("ADD")
+	highlight:SetAllPoints(checkbg)
+
+	local image = frame:CreateTexture(nil, "OVERLAY")
+	image:SetHeight(16)
+	image:SetWidth(16)
+	image:SetPoint("LEFT", checkbg, "RIGHT", 1, 0)
+
+	local widget = {
+		checkbg   = checkbg,
+		check     = check,
+		text      = text,
+		highlight = highlight,
+		image     = image,
+		frame     = frame,
+		type      = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-ColorPicker.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-ColorPicker.lua
index 5b34362..ec811d0 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-ColorPicker.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-ColorPicker.lua
@@ -1,230 +1,230 @@
---[[-----------------------------------------------------------------------------
-ColorPicker Widget
--------------------------------------------------------------------------------]]
-local Type, Version = "ColorPicker", 28
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs = pairs
-
--- WoW APIs
-local CreateFrame, UIParent = CreateFrame, UIParent
-
--- Unfortunately we have no way to realistically detect if a client uses inverted alpha
--- as no API will tell you. Wrath uses the old colorpicker, era uses the new one, both are inverted
-local INVERTED_ALPHA = (WOW_PROJECT_ID ~= WOW_PROJECT_MAINLINE)
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-local function ColorCallback(self, r, g, b, a, isAlpha)
-	if INVERTED_ALPHA and a then
-		a = 1 - a
-	end
-	if not self.HasAlpha then
-		a = 1
-	end
-	-- no change, skip update
-	if r == self.r and g == self.g and b == self.b and a == self.a then
-		return
-	end
-	self:SetColor(r, g, b, a)
-	if ColorPickerFrame:IsVisible() then
-		--colorpicker is still open
-		self:Fire("OnValueChanged", r, g, b, a)
-	else
-		--colorpicker is closed, color callback is first, ignore it,
-		--alpha callback is the final call after it closes so confirm now
-		if isAlpha then
-			self:Fire("OnValueConfirmed", r, g, b, a)
-		end
-	end
-end
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Control_OnEnter(frame)
-	frame.obj:Fire("OnEnter")
-end
-
-local function Control_OnLeave(frame)
-	frame.obj:Fire("OnLeave")
-end
-
-local function ColorSwatch_OnClick(frame)
-	ColorPickerFrame:Hide()
-	local self = frame.obj
-	if not self.disabled then
-		ColorPickerFrame:SetFrameStrata("FULLSCREEN_DIALOG")
-		ColorPickerFrame:SetFrameLevel(frame:GetFrameLevel() + 10)
-		ColorPickerFrame:SetClampedToScreen(true)
-
-		if ColorPickerFrame.SetupColorPickerAndShow then -- 10.2.5 color picker overhaul
-			local r2, g2, b2, a2 = self.r, self.g, self.b, (self.a or 1)
-			if INVERTED_ALPHA then
-				a2 = 1 - a2
-			end
-
-			local info = {
-				swatchFunc = function()
-					local r, g, b = ColorPickerFrame:GetColorRGB()
-					local a = ColorPickerFrame:GetColorAlpha()
-					ColorCallback(self, r, g, b, a)
-				end,
-
-				hasOpacity = self.HasAlpha,
-				opacityFunc = function()
-					local r, g, b = ColorPickerFrame:GetColorRGB()
-					local a = ColorPickerFrame:GetColorAlpha()
-					ColorCallback(self, r, g, b, a, true)
-				end,
-				opacity = a2,
-
-				cancelFunc = function()
-					ColorCallback(self, r2, g2, b2, a2, true)
-				end,
-
-				r = r2,
-				g = g2,
-				b = b2,
-			}
-
-			ColorPickerFrame:SetupColorPickerAndShow(info)
-		else
-			ColorPickerFrame.func = function()
-				local r, g, b = ColorPickerFrame:GetColorRGB()
-				local a = OpacitySliderFrame:GetValue()
-				ColorCallback(self, r, g, b, a)
-			end
-
-			ColorPickerFrame.hasOpacity = self.HasAlpha
-			ColorPickerFrame.opacityFunc = function()
-				local r, g, b = ColorPickerFrame:GetColorRGB()
-				local a = OpacitySliderFrame:GetValue()
-				ColorCallback(self, r, g, b, a, true)
-			end
-
-			local r, g, b, a = self.r, self.g, self.b, 1 - (self.a or 1)
-			if self.HasAlpha then
-				ColorPickerFrame.opacity = a
-			end
-			ColorPickerFrame:SetColorRGB(r, g, b)
-
-			ColorPickerFrame.cancelFunc = function()
-				ColorCallback(self, r, g, b, a, true)
-			end
-
-			ColorPickerFrame:Show()
-		end
-	end
-	AceGUI:ClearFocus()
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetHeight(24)
-		self:SetWidth(200)
-		self:SetHasAlpha(false)
-		self:SetColor(0, 0, 0, 1)
-		self:SetDisabled(nil)
-		self:SetLabel(nil)
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["SetLabel"] = function(self, text)
-		self.text:SetText(text)
-	end,
-
-	["SetColor"] = function(self, r, g, b, a)
-		self.r = r
-		self.g = g
-		self.b = b
-		self.a = a or 1
-		self.colorSwatch:SetVertexColor(r, g, b, a)
-	end,
-
-	["SetHasAlpha"] = function(self, HasAlpha)
-		self.HasAlpha = HasAlpha
-	end,
-
-	["SetDisabled"] = function(self, disabled)
-		self.disabled = disabled
-		if self.disabled then
-			self.frame:Disable()
-			self.text:SetTextColor(0.5, 0.5, 0.5)
-		else
-			self.frame:Enable()
-			self.text:SetTextColor(1, 1, 1)
-		end
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local frame = CreateFrame("Button", nil, UIParent)
-	frame:Hide()
-
-	frame:EnableMouse(true)
-	frame:SetScript("OnEnter", Control_OnEnter)
-	frame:SetScript("OnLeave", Control_OnLeave)
-	frame:SetScript("OnClick", ColorSwatch_OnClick)
-
-	local colorSwatch = frame:CreateTexture(nil, "OVERLAY")
-	colorSwatch:SetWidth(19)
-	colorSwatch:SetHeight(19)
-	colorSwatch:SetTexture(130939) -- Interface\\ChatFrame\\ChatFrameColorSwatch
-	colorSwatch:SetPoint("LEFT")
-
-	local texture = frame:CreateTexture(nil, "BACKGROUND")
-	colorSwatch.background = texture
-	texture:SetWidth(16)
-	texture:SetHeight(16)
-	texture:SetColorTexture(1, 1, 1)
-	texture:SetPoint("CENTER", colorSwatch)
-	texture:Show()
-
-	local checkers = frame:CreateTexture(nil, "BACKGROUND")
-	colorSwatch.checkers = checkers
-	checkers:SetWidth(14)
-	checkers:SetHeight(14)
-	checkers:SetTexture(188523) -- Tileset\\Generic\\Checkers
-	checkers:SetTexCoord(.25, 0, 0.5, .25)
-	checkers:SetDesaturated(true)
-	checkers:SetVertexColor(1, 1, 1, 0.75)
-	checkers:SetPoint("CENTER", colorSwatch)
-	checkers:Show()
-
-	local text = frame:CreateFontString(nil,"OVERLAY","GameFontHighlight")
-	text:SetHeight(24)
-	text:SetJustifyH("LEFT")
-	text:SetTextColor(1, 1, 1)
-	text:SetPoint("LEFT", colorSwatch, "RIGHT", 2, 0)
-	text:SetPoint("RIGHT")
-
-	--local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
-	--highlight:SetTexture(136810) -- Interface\\QuestFrame\\UI-QuestTitleHighlight
-	--highlight:SetBlendMode("ADD")
-	--highlight:SetAllPoints(frame)
-
-	local widget = {
-		colorSwatch = colorSwatch,
-		text        = text,
-		frame       = frame,
-		type        = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+ColorPicker Widget
+-------------------------------------------------------------------------------]]
+local Type, Version = "ColorPicker", 28
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs = pairs
+
+-- WoW APIs
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+-- Unfortunately we have no way to realistically detect if a client uses inverted alpha
+-- as no API will tell you. Wrath uses the old colorpicker, era uses the new one, both are inverted
+local INVERTED_ALPHA = (WOW_PROJECT_ID ~= WOW_PROJECT_MAINLINE)
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+local function ColorCallback(self, r, g, b, a, isAlpha)
+	if INVERTED_ALPHA and a then
+		a = 1 - a
+	end
+	if not self.HasAlpha then
+		a = 1
+	end
+	-- no change, skip update
+	if r == self.r and g == self.g and b == self.b and a == self.a then
+		return
+	end
+	self:SetColor(r, g, b, a)
+	if ColorPickerFrame:IsVisible() then
+		--colorpicker is still open
+		self:Fire("OnValueChanged", r, g, b, a)
+	else
+		--colorpicker is closed, color callback is first, ignore it,
+		--alpha callback is the final call after it closes so confirm now
+		if isAlpha then
+			self:Fire("OnValueConfirmed", r, g, b, a)
+		end
+	end
+end
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Control_OnEnter(frame)
+	frame.obj:Fire("OnEnter")
+end
+
+local function Control_OnLeave(frame)
+	frame.obj:Fire("OnLeave")
+end
+
+local function ColorSwatch_OnClick(frame)
+	ColorPickerFrame:Hide()
+	local self = frame.obj
+	if not self.disabled then
+		ColorPickerFrame:SetFrameStrata("FULLSCREEN_DIALOG")
+		ColorPickerFrame:SetFrameLevel(frame:GetFrameLevel() + 10)
+		ColorPickerFrame:SetClampedToScreen(true)
+
+		if ColorPickerFrame.SetupColorPickerAndShow then -- 10.2.5 color picker overhaul
+			local r2, g2, b2, a2 = self.r, self.g, self.b, (self.a or 1)
+			if INVERTED_ALPHA then
+				a2 = 1 - a2
+			end
+
+			local info = {
+				swatchFunc = function()
+					local r, g, b = ColorPickerFrame:GetColorRGB()
+					local a = ColorPickerFrame:GetColorAlpha()
+					ColorCallback(self, r, g, b, a)
+				end,
+
+				hasOpacity = self.HasAlpha,
+				opacityFunc = function()
+					local r, g, b = ColorPickerFrame:GetColorRGB()
+					local a = ColorPickerFrame:GetColorAlpha()
+					ColorCallback(self, r, g, b, a, true)
+				end,
+				opacity = a2,
+
+				cancelFunc = function()
+					ColorCallback(self, r2, g2, b2, a2, true)
+				end,
+
+				r = r2,
+				g = g2,
+				b = b2,
+			}
+
+			ColorPickerFrame:SetupColorPickerAndShow(info)
+		else
+			ColorPickerFrame.func = function()
+				local r, g, b = ColorPickerFrame:GetColorRGB()
+				local a = OpacitySliderFrame:GetValue()
+				ColorCallback(self, r, g, b, a)
+			end
+
+			ColorPickerFrame.hasOpacity = self.HasAlpha
+			ColorPickerFrame.opacityFunc = function()
+				local r, g, b = ColorPickerFrame:GetColorRGB()
+				local a = OpacitySliderFrame:GetValue()
+				ColorCallback(self, r, g, b, a, true)
+			end
+
+			local r, g, b, a = self.r, self.g, self.b, 1 - (self.a or 1)
+			if self.HasAlpha then
+				ColorPickerFrame.opacity = a
+			end
+			ColorPickerFrame:SetColorRGB(r, g, b)
+
+			ColorPickerFrame.cancelFunc = function()
+				ColorCallback(self, r, g, b, a, true)
+			end
+
+			ColorPickerFrame:Show()
+		end
+	end
+	AceGUI:ClearFocus()
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetHeight(24)
+		self:SetWidth(200)
+		self:SetHasAlpha(false)
+		self:SetColor(0, 0, 0, 1)
+		self:SetDisabled(nil)
+		self:SetLabel(nil)
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["SetLabel"] = function(self, text)
+		self.text:SetText(text)
+	end,
+
+	["SetColor"] = function(self, r, g, b, a)
+		self.r = r
+		self.g = g
+		self.b = b
+		self.a = a or 1
+		self.colorSwatch:SetVertexColor(r, g, b, a)
+	end,
+
+	["SetHasAlpha"] = function(self, HasAlpha)
+		self.HasAlpha = HasAlpha
+	end,
+
+	["SetDisabled"] = function(self, disabled)
+		self.disabled = disabled
+		if self.disabled then
+			self.frame:Disable()
+			self.text:SetTextColor(0.5, 0.5, 0.5)
+		else
+			self.frame:Enable()
+			self.text:SetTextColor(1, 1, 1)
+		end
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local frame = CreateFrame("Button", nil, UIParent)
+	frame:Hide()
+
+	frame:EnableMouse(true)
+	frame:SetScript("OnEnter", Control_OnEnter)
+	frame:SetScript("OnLeave", Control_OnLeave)
+	frame:SetScript("OnClick", ColorSwatch_OnClick)
+
+	local colorSwatch = frame:CreateTexture(nil, "OVERLAY")
+	colorSwatch:SetWidth(19)
+	colorSwatch:SetHeight(19)
+	colorSwatch:SetTexture(130939) -- Interface\\ChatFrame\\ChatFrameColorSwatch
+	colorSwatch:SetPoint("LEFT")
+
+	local texture = frame:CreateTexture(nil, "BACKGROUND")
+	colorSwatch.background = texture
+	texture:SetWidth(16)
+	texture:SetHeight(16)
+	texture:SetColorTexture(1, 1, 1)
+	texture:SetPoint("CENTER", colorSwatch)
+	texture:Show()
+
+	local checkers = frame:CreateTexture(nil, "BACKGROUND")
+	colorSwatch.checkers = checkers
+	checkers:SetWidth(14)
+	checkers:SetHeight(14)
+	checkers:SetTexture(188523) -- Tileset\\Generic\\Checkers
+	checkers:SetTexCoord(.25, 0, 0.5, .25)
+	checkers:SetDesaturated(true)
+	checkers:SetVertexColor(1, 1, 1, 0.75)
+	checkers:SetPoint("CENTER", colorSwatch)
+	checkers:Show()
+
+	local text = frame:CreateFontString(nil,"OVERLAY","GameFontHighlight")
+	text:SetHeight(24)
+	text:SetJustifyH("LEFT")
+	text:SetTextColor(1, 1, 1)
+	text:SetPoint("LEFT", colorSwatch, "RIGHT", 2, 0)
+	text:SetPoint("RIGHT")
+
+	--local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
+	--highlight:SetTexture(136810) -- Interface\\QuestFrame\\UI-QuestTitleHighlight
+	--highlight:SetBlendMode("ADD")
+	--highlight:SetAllPoints(frame)
+
+	local widget = {
+		colorSwatch = colorSwatch,
+		text        = text,
+		frame       = frame,
+		type        = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown-Items.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown-Items.lua
index 0ad94f8..947184c 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown-Items.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown-Items.lua
@@ -1,471 +1,471 @@
---[[ $Id: AceGUIWidget-DropDown-Items.lua 1272 2022-08-29 15:56:35Z nevcairiel $ ]]--
-
-local AceGUI = LibStub("AceGUI-3.0")
-
--- Lua APIs
-local select, assert = select, assert
-
--- WoW APIs
-local PlaySound = PlaySound
-local CreateFrame = CreateFrame
-
-local function fixlevels(parent,...)
-	local i = 1
-	local child = select(i, ...)
-	while child do
-		child:SetFrameLevel(parent:GetFrameLevel()+1)
-		fixlevels(child, child:GetChildren())
-		i = i + 1
-		child = select(i, ...)
-	end
-end
-
-local function fixstrata(strata, parent, ...)
-	local i = 1
-	local child = select(i, ...)
-	parent:SetFrameStrata(strata)
-	while child do
-		fixstrata(strata, child, child:GetChildren())
-		i = i + 1
-		child = select(i, ...)
-	end
-end
-
--- ItemBase is the base "class" for all dropdown items.
--- Each item has to use ItemBase.Create(widgetType) to
--- create an initial 'self' value.
--- ItemBase will add common functions and ui event handlers.
--- Be sure to keep basic usage when you override functions.
-
-local ItemBase = {
-	-- NOTE: The ItemBase version is added to each item's version number
-	--       to ensure proper updates on ItemBase changes.
-	--       Use at least 1000er steps.
-	version = 2000,
-	counter = 0,
-}
-
-function ItemBase.Frame_OnEnter(this)
-	local self = this.obj
-
-	if self.useHighlight then
-		self.highlight:Show()
-	end
-	self:Fire("OnEnter")
-
-	if self.specialOnEnter then
-		self.specialOnEnter(self)
-	end
-end
-
-function ItemBase.Frame_OnLeave(this)
-	local self = this.obj
-
-	self.highlight:Hide()
-	self:Fire("OnLeave")
-
-	if self.specialOnLeave then
-		self.specialOnLeave(self)
-	end
-end
-
--- exported, AceGUI callback
-function ItemBase.OnAcquire(self)
-	self.frame:SetToplevel(true)
-	self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
-end
-
--- exported, AceGUI callback
-function ItemBase.OnRelease(self)
-	self:SetDisabled(false)
-	self.pullout = nil
-	self.frame:SetParent(nil)
-	self.frame:ClearAllPoints()
-	self.frame:Hide()
-end
-
--- exported
--- NOTE: this is called by a Dropdown-Pullout.
---       Do not call this method directly
-function ItemBase.SetPullout(self, pullout)
-	self.pullout = pullout
-
-	self.frame:SetParent(nil)
-	self.frame:SetParent(pullout.itemFrame)
-	self.parent = pullout.itemFrame
-	fixlevels(pullout.itemFrame, pullout.itemFrame:GetChildren())
-end
-
--- exported
-function ItemBase.SetText(self, text)
-	self.text:SetText(text or "")
-end
-
--- exported
-function ItemBase.GetText(self)
-	return self.text:GetText()
-end
-
--- exported
-function ItemBase.SetPoint(self, ...)
-	self.frame:SetPoint(...)
-end
-
--- exported
-function ItemBase.Show(self)
-	self.frame:Show()
-end
-
--- exported
-function ItemBase.Hide(self)
-	self.frame:Hide()
-end
-
--- exported
-function ItemBase.SetDisabled(self, disabled)
-	self.disabled = disabled
-	if disabled then
-		self.useHighlight = false
-		self.text:SetTextColor(.5, .5, .5)
-	else
-		self.useHighlight = true
-		self.text:SetTextColor(1, 1, 1)
-	end
-end
-
--- exported
--- NOTE: this is called by a Dropdown-Pullout.
---       Do not call this method directly
-function ItemBase.SetOnLeave(self, func)
-	self.specialOnLeave = func
-end
-
--- exported
--- NOTE: this is called by a Dropdown-Pullout.
---       Do not call this method directly
-function ItemBase.SetOnEnter(self, func)
-	self.specialOnEnter = func
-end
-
-function ItemBase.Create(type)
-	-- NOTE: Most of the following code is copied from AceGUI-3.0/Dropdown widget
-	local count = AceGUI:GetNextWidgetNum(type)
-	local frame = CreateFrame("Button", "AceGUI30DropDownItem"..count)
-	local self = {}
-	self.frame = frame
-	frame.obj = self
-	self.type = type
-
-	self.useHighlight = true
-
-	frame:SetHeight(17)
-	frame:SetFrameStrata("FULLSCREEN_DIALOG")
-
-	local text = frame:CreateFontString(nil,"OVERLAY","GameFontNormalSmall")
-	text:SetTextColor(1,1,1)
-	text:SetJustifyH("LEFT")
-	text:SetPoint("TOPLEFT",frame,"TOPLEFT",18,0)
-	text:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-8,0)
-	self.text = text
-
-	local highlight = frame:CreateTexture(nil, "OVERLAY")
-	highlight:SetTexture(136810) -- Interface\\QuestFrame\\UI-QuestTitleHighlight
-	highlight:SetBlendMode("ADD")
-	highlight:SetHeight(14)
-	highlight:ClearAllPoints()
-	highlight:SetPoint("RIGHT",frame,"RIGHT",-3,0)
-	highlight:SetPoint("LEFT",frame,"LEFT",5,0)
-	highlight:Hide()
-	self.highlight = highlight
-
-	local check = frame:CreateTexture(nil, "OVERLAY")
-	check:SetWidth(16)
-	check:SetHeight(16)
-	check:SetPoint("LEFT",frame,"LEFT",3,-1)
-	check:SetTexture(130751) -- Interface\\Buttons\\UI-CheckBox-Check
-	check:Hide()
-	self.check = check
-
-	local sub = frame:CreateTexture(nil, "OVERLAY")
-	sub:SetWidth(16)
-	sub:SetHeight(16)
-	sub:SetPoint("RIGHT",frame,"RIGHT",-3,-1)
-	sub:SetTexture(130940) -- Interface\\ChatFrame\\ChatFrameExpandArrow
-	sub:Hide()
-	self.sub = sub
-
-	frame:SetScript("OnEnter", ItemBase.Frame_OnEnter)
-	frame:SetScript("OnLeave", ItemBase.Frame_OnLeave)
-
-	self.OnAcquire = ItemBase.OnAcquire
-	self.OnRelease = ItemBase.OnRelease
-
-	self.SetPullout = ItemBase.SetPullout
-	self.GetText    = ItemBase.GetText
-	self.SetText    = ItemBase.SetText
-	self.SetDisabled = ItemBase.SetDisabled
-
-	self.SetPoint   = ItemBase.SetPoint
-	self.Show       = ItemBase.Show
-	self.Hide       = ItemBase.Hide
-
-	self.SetOnLeave = ItemBase.SetOnLeave
-	self.SetOnEnter = ItemBase.SetOnEnter
-
-	return self
-end
-
--- Register a dummy LibStub library to retrieve the ItemBase, so other addons can use it.
-local IBLib = LibStub:NewLibrary("AceGUI-3.0-DropDown-ItemBase", ItemBase.version)
-if IBLib then
-	IBLib.GetItemBase = function() return ItemBase end
-end
-
---[[
-	Template for items:
-
--- Item:
---
-do
-	local widgetType = "Dropdown-Item-"
-	local widgetVersion = 1
-
-	local function Constructor()
-		local self = ItemBase.Create(widgetType)
-
-		AceGUI:RegisterAsWidget(self)
-		return self
-	end
-
-	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
-end
---]]
-
--- Item: Header
--- A single text entry.
--- Special: Different text color and no highlight
-do
-	local widgetType = "Dropdown-Item-Header"
-	local widgetVersion = 1
-
-	local function OnEnter(this)
-		local self = this.obj
-		self:Fire("OnEnter")
-
-		if self.specialOnEnter then
-			self.specialOnEnter(self)
-		end
-	end
-
-	local function OnLeave(this)
-		local self = this.obj
-		self:Fire("OnLeave")
-
-		if self.specialOnLeave then
-			self.specialOnLeave(self)
-		end
-	end
-
-	-- exported, override
-	local function SetDisabled(self, disabled)
-		ItemBase.SetDisabled(self, disabled)
-		if not disabled then
-			self.text:SetTextColor(1, 1, 0)
-		end
-	end
-
-	local function Constructor()
-		local self = ItemBase.Create(widgetType)
-
-		self.SetDisabled = SetDisabled
-
-		self.frame:SetScript("OnEnter", OnEnter)
-		self.frame:SetScript("OnLeave", OnLeave)
-
-		self.text:SetTextColor(1, 1, 0)
-
-		AceGUI:RegisterAsWidget(self)
-		return self
-	end
-
-	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
-end
-
--- Item: Execute
--- A simple button
-do
-	local widgetType = "Dropdown-Item-Execute"
-	local widgetVersion = 1
-
-	local function Frame_OnClick(this, button)
-		local self = this.obj
-		if self.disabled then return end
-		self:Fire("OnClick")
-		if self.pullout then
-			self.pullout:Close()
-		end
-	end
-
-	local function Constructor()
-		local self = ItemBase.Create(widgetType)
-
-		self.frame:SetScript("OnClick", Frame_OnClick)
-
-		AceGUI:RegisterAsWidget(self)
-		return self
-	end
-
-	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
-end
-
--- Item: Toggle
--- Some sort of checkbox for dropdown menus.
--- Does not close the pullout on click.
-do
-	local widgetType = "Dropdown-Item-Toggle"
-	local widgetVersion = 4
-
-	local function UpdateToggle(self)
-		if self.value then
-			self.check:Show()
-		else
-			self.check:Hide()
-		end
-	end
-
-	local function OnRelease(self)
-		ItemBase.OnRelease(self)
-		self:SetValue(nil)
-	end
-
-	local function Frame_OnClick(this, button)
-		local self = this.obj
-		if self.disabled then return end
-		self.value = not self.value
-		if self.value then
-			PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
-		else
-			PlaySound(857) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_OFF
-		end
-		UpdateToggle(self)
-		self:Fire("OnValueChanged", self.value)
-	end
-
-	-- exported
-	local function SetValue(self, value)
-		self.value = value
-		UpdateToggle(self)
-	end
-
-	-- exported
-	local function GetValue(self)
-		return self.value
-	end
-
-	local function Constructor()
-		local self = ItemBase.Create(widgetType)
-
-		self.frame:SetScript("OnClick", Frame_OnClick)
-
-		self.SetValue = SetValue
-		self.GetValue = GetValue
-		self.OnRelease = OnRelease
-
-		AceGUI:RegisterAsWidget(self)
-		return self
-	end
-
-	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
-end
-
--- Item: Menu
--- Shows a submenu on mouse over
--- Does not close the pullout on click
-do
-	local widgetType = "Dropdown-Item-Menu"
-	local widgetVersion = 2
-
-	local function OnEnter(this)
-		local self = this.obj
-		self:Fire("OnEnter")
-
-		if self.specialOnEnter then
-			self.specialOnEnter(self)
-		end
-
-		self.highlight:Show()
-
-		if not self.disabled and self.submenu then
-			self.submenu:Open("TOPLEFT", self.frame, "TOPRIGHT", self.pullout:GetRightBorderWidth(), 0, self.frame:GetFrameLevel() + 100)
-		end
-	end
-
-	local function OnHide(this)
-		local self = this.obj
-		if self.submenu then
-			self.submenu:Close()
-		end
-	end
-
-	-- exported
-	local function SetMenu(self, menu)
-		assert(menu.type == "Dropdown-Pullout")
-		self.submenu = menu
-	end
-
-	-- exported
-	local function CloseMenu(self)
-		self.submenu:Close()
-	end
-
-	local function Constructor()
-		local self = ItemBase.Create(widgetType)
-
-		self.sub:Show()
-
-		self.frame:SetScript("OnEnter", OnEnter)
-		self.frame:SetScript("OnHide", OnHide)
-
-		self.SetMenu   = SetMenu
-		self.CloseMenu = CloseMenu
-
-		AceGUI:RegisterAsWidget(self)
-		return self
-	end
-
-	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
-end
-
--- Item: Separator
--- A single line to separate items
-do
-	local widgetType = "Dropdown-Item-Separator"
-	local widgetVersion = 2
-
-	-- exported, override
-	local function SetDisabled(self, disabled)
-		ItemBase.SetDisabled(self, disabled)
-		self.useHighlight = false
-	end
-
-	local function Constructor()
-		local self = ItemBase.Create(widgetType)
-
-		self.SetDisabled = SetDisabled
-
-		local line = self.frame:CreateTexture(nil, "OVERLAY")
-		line:SetHeight(1)
-		line:SetColorTexture(.5, .5, .5)
-		line:SetPoint("LEFT", self.frame, "LEFT", 10, 0)
-		line:SetPoint("RIGHT", self.frame, "RIGHT", -10, 0)
-
-		self.text:Hide()
-
-		self.useHighlight = false
-
-		AceGUI:RegisterAsWidget(self)
-		return self
-	end
-
-	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
-end
+--[[ $Id: AceGUIWidget-DropDown-Items.lua 1272 2022-08-29 15:56:35Z nevcairiel $ ]]--
+
+local AceGUI = LibStub("AceGUI-3.0")
+
+-- Lua APIs
+local select, assert = select, assert
+
+-- WoW APIs
+local PlaySound = PlaySound
+local CreateFrame = CreateFrame
+
+local function fixlevels(parent,...)
+	local i = 1
+	local child = select(i, ...)
+	while child do
+		child:SetFrameLevel(parent:GetFrameLevel()+1)
+		fixlevels(child, child:GetChildren())
+		i = i + 1
+		child = select(i, ...)
+	end
+end
+
+local function fixstrata(strata, parent, ...)
+	local i = 1
+	local child = select(i, ...)
+	parent:SetFrameStrata(strata)
+	while child do
+		fixstrata(strata, child, child:GetChildren())
+		i = i + 1
+		child = select(i, ...)
+	end
+end
+
+-- ItemBase is the base "class" for all dropdown items.
+-- Each item has to use ItemBase.Create(widgetType) to
+-- create an initial 'self' value.
+-- ItemBase will add common functions and ui event handlers.
+-- Be sure to keep basic usage when you override functions.
+
+local ItemBase = {
+	-- NOTE: The ItemBase version is added to each item's version number
+	--       to ensure proper updates on ItemBase changes.
+	--       Use at least 1000er steps.
+	version = 2000,
+	counter = 0,
+}
+
+function ItemBase.Frame_OnEnter(this)
+	local self = this.obj
+
+	if self.useHighlight then
+		self.highlight:Show()
+	end
+	self:Fire("OnEnter")
+
+	if self.specialOnEnter then
+		self.specialOnEnter(self)
+	end
+end
+
+function ItemBase.Frame_OnLeave(this)
+	local self = this.obj
+
+	self.highlight:Hide()
+	self:Fire("OnLeave")
+
+	if self.specialOnLeave then
+		self.specialOnLeave(self)
+	end
+end
+
+-- exported, AceGUI callback
+function ItemBase.OnAcquire(self)
+	self.frame:SetToplevel(true)
+	self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
+end
+
+-- exported, AceGUI callback
+function ItemBase.OnRelease(self)
+	self:SetDisabled(false)
+	self.pullout = nil
+	self.frame:SetParent(nil)
+	self.frame:ClearAllPoints()
+	self.frame:Hide()
+end
+
+-- exported
+-- NOTE: this is called by a Dropdown-Pullout.
+--       Do not call this method directly
+function ItemBase.SetPullout(self, pullout)
+	self.pullout = pullout
+
+	self.frame:SetParent(nil)
+	self.frame:SetParent(pullout.itemFrame)
+	self.parent = pullout.itemFrame
+	fixlevels(pullout.itemFrame, pullout.itemFrame:GetChildren())
+end
+
+-- exported
+function ItemBase.SetText(self, text)
+	self.text:SetText(text or "")
+end
+
+-- exported
+function ItemBase.GetText(self)
+	return self.text:GetText()
+end
+
+-- exported
+function ItemBase.SetPoint(self, ...)
+	self.frame:SetPoint(...)
+end
+
+-- exported
+function ItemBase.Show(self)
+	self.frame:Show()
+end
+
+-- exported
+function ItemBase.Hide(self)
+	self.frame:Hide()
+end
+
+-- exported
+function ItemBase.SetDisabled(self, disabled)
+	self.disabled = disabled
+	if disabled then
+		self.useHighlight = false
+		self.text:SetTextColor(.5, .5, .5)
+	else
+		self.useHighlight = true
+		self.text:SetTextColor(1, 1, 1)
+	end
+end
+
+-- exported
+-- NOTE: this is called by a Dropdown-Pullout.
+--       Do not call this method directly
+function ItemBase.SetOnLeave(self, func)
+	self.specialOnLeave = func
+end
+
+-- exported
+-- NOTE: this is called by a Dropdown-Pullout.
+--       Do not call this method directly
+function ItemBase.SetOnEnter(self, func)
+	self.specialOnEnter = func
+end
+
+function ItemBase.Create(type)
+	-- NOTE: Most of the following code is copied from AceGUI-3.0/Dropdown widget
+	local count = AceGUI:GetNextWidgetNum(type)
+	local frame = CreateFrame("Button", "AceGUI30DropDownItem"..count)
+	local self = {}
+	self.frame = frame
+	frame.obj = self
+	self.type = type
+
+	self.useHighlight = true
+
+	frame:SetHeight(17)
+	frame:SetFrameStrata("FULLSCREEN_DIALOG")
+
+	local text = frame:CreateFontString(nil,"OVERLAY","GameFontNormalSmall")
+	text:SetTextColor(1,1,1)
+	text:SetJustifyH("LEFT")
+	text:SetPoint("TOPLEFT",frame,"TOPLEFT",18,0)
+	text:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-8,0)
+	self.text = text
+
+	local highlight = frame:CreateTexture(nil, "OVERLAY")
+	highlight:SetTexture(136810) -- Interface\\QuestFrame\\UI-QuestTitleHighlight
+	highlight:SetBlendMode("ADD")
+	highlight:SetHeight(14)
+	highlight:ClearAllPoints()
+	highlight:SetPoint("RIGHT",frame,"RIGHT",-3,0)
+	highlight:SetPoint("LEFT",frame,"LEFT",5,0)
+	highlight:Hide()
+	self.highlight = highlight
+
+	local check = frame:CreateTexture(nil, "OVERLAY")
+	check:SetWidth(16)
+	check:SetHeight(16)
+	check:SetPoint("LEFT",frame,"LEFT",3,-1)
+	check:SetTexture(130751) -- Interface\\Buttons\\UI-CheckBox-Check
+	check:Hide()
+	self.check = check
+
+	local sub = frame:CreateTexture(nil, "OVERLAY")
+	sub:SetWidth(16)
+	sub:SetHeight(16)
+	sub:SetPoint("RIGHT",frame,"RIGHT",-3,-1)
+	sub:SetTexture(130940) -- Interface\\ChatFrame\\ChatFrameExpandArrow
+	sub:Hide()
+	self.sub = sub
+
+	frame:SetScript("OnEnter", ItemBase.Frame_OnEnter)
+	frame:SetScript("OnLeave", ItemBase.Frame_OnLeave)
+
+	self.OnAcquire = ItemBase.OnAcquire
+	self.OnRelease = ItemBase.OnRelease
+
+	self.SetPullout = ItemBase.SetPullout
+	self.GetText    = ItemBase.GetText
+	self.SetText    = ItemBase.SetText
+	self.SetDisabled = ItemBase.SetDisabled
+
+	self.SetPoint   = ItemBase.SetPoint
+	self.Show       = ItemBase.Show
+	self.Hide       = ItemBase.Hide
+
+	self.SetOnLeave = ItemBase.SetOnLeave
+	self.SetOnEnter = ItemBase.SetOnEnter
+
+	return self
+end
+
+-- Register a dummy LibStub library to retrieve the ItemBase, so other addons can use it.
+local IBLib = LibStub:NewLibrary("AceGUI-3.0-DropDown-ItemBase", ItemBase.version)
+if IBLib then
+	IBLib.GetItemBase = function() return ItemBase end
+end
+
+--[[
+	Template for items:
+
+-- Item:
+--
+do
+	local widgetType = "Dropdown-Item-"
+	local widgetVersion = 1
+
+	local function Constructor()
+		local self = ItemBase.Create(widgetType)
+
+		AceGUI:RegisterAsWidget(self)
+		return self
+	end
+
+	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
+end
+--]]
+
+-- Item: Header
+-- A single text entry.
+-- Special: Different text color and no highlight
+do
+	local widgetType = "Dropdown-Item-Header"
+	local widgetVersion = 1
+
+	local function OnEnter(this)
+		local self = this.obj
+		self:Fire("OnEnter")
+
+		if self.specialOnEnter then
+			self.specialOnEnter(self)
+		end
+	end
+
+	local function OnLeave(this)
+		local self = this.obj
+		self:Fire("OnLeave")
+
+		if self.specialOnLeave then
+			self.specialOnLeave(self)
+		end
+	end
+
+	-- exported, override
+	local function SetDisabled(self, disabled)
+		ItemBase.SetDisabled(self, disabled)
+		if not disabled then
+			self.text:SetTextColor(1, 1, 0)
+		end
+	end
+
+	local function Constructor()
+		local self = ItemBase.Create(widgetType)
+
+		self.SetDisabled = SetDisabled
+
+		self.frame:SetScript("OnEnter", OnEnter)
+		self.frame:SetScript("OnLeave", OnLeave)
+
+		self.text:SetTextColor(1, 1, 0)
+
+		AceGUI:RegisterAsWidget(self)
+		return self
+	end
+
+	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
+end
+
+-- Item: Execute
+-- A simple button
+do
+	local widgetType = "Dropdown-Item-Execute"
+	local widgetVersion = 1
+
+	local function Frame_OnClick(this, button)
+		local self = this.obj
+		if self.disabled then return end
+		self:Fire("OnClick")
+		if self.pullout then
+			self.pullout:Close()
+		end
+	end
+
+	local function Constructor()
+		local self = ItemBase.Create(widgetType)
+
+		self.frame:SetScript("OnClick", Frame_OnClick)
+
+		AceGUI:RegisterAsWidget(self)
+		return self
+	end
+
+	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
+end
+
+-- Item: Toggle
+-- Some sort of checkbox for dropdown menus.
+-- Does not close the pullout on click.
+do
+	local widgetType = "Dropdown-Item-Toggle"
+	local widgetVersion = 4
+
+	local function UpdateToggle(self)
+		if self.value then
+			self.check:Show()
+		else
+			self.check:Hide()
+		end
+	end
+
+	local function OnRelease(self)
+		ItemBase.OnRelease(self)
+		self:SetValue(nil)
+	end
+
+	local function Frame_OnClick(this, button)
+		local self = this.obj
+		if self.disabled then return end
+		self.value = not self.value
+		if self.value then
+			PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
+		else
+			PlaySound(857) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_OFF
+		end
+		UpdateToggle(self)
+		self:Fire("OnValueChanged", self.value)
+	end
+
+	-- exported
+	local function SetValue(self, value)
+		self.value = value
+		UpdateToggle(self)
+	end
+
+	-- exported
+	local function GetValue(self)
+		return self.value
+	end
+
+	local function Constructor()
+		local self = ItemBase.Create(widgetType)
+
+		self.frame:SetScript("OnClick", Frame_OnClick)
+
+		self.SetValue = SetValue
+		self.GetValue = GetValue
+		self.OnRelease = OnRelease
+
+		AceGUI:RegisterAsWidget(self)
+		return self
+	end
+
+	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
+end
+
+-- Item: Menu
+-- Shows a submenu on mouse over
+-- Does not close the pullout on click
+do
+	local widgetType = "Dropdown-Item-Menu"
+	local widgetVersion = 2
+
+	local function OnEnter(this)
+		local self = this.obj
+		self:Fire("OnEnter")
+
+		if self.specialOnEnter then
+			self.specialOnEnter(self)
+		end
+
+		self.highlight:Show()
+
+		if not self.disabled and self.submenu then
+			self.submenu:Open("TOPLEFT", self.frame, "TOPRIGHT", self.pullout:GetRightBorderWidth(), 0, self.frame:GetFrameLevel() + 100)
+		end
+	end
+
+	local function OnHide(this)
+		local self = this.obj
+		if self.submenu then
+			self.submenu:Close()
+		end
+	end
+
+	-- exported
+	local function SetMenu(self, menu)
+		assert(menu.type == "Dropdown-Pullout")
+		self.submenu = menu
+	end
+
+	-- exported
+	local function CloseMenu(self)
+		self.submenu:Close()
+	end
+
+	local function Constructor()
+		local self = ItemBase.Create(widgetType)
+
+		self.sub:Show()
+
+		self.frame:SetScript("OnEnter", OnEnter)
+		self.frame:SetScript("OnHide", OnHide)
+
+		self.SetMenu   = SetMenu
+		self.CloseMenu = CloseMenu
+
+		AceGUI:RegisterAsWidget(self)
+		return self
+	end
+
+	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
+end
+
+-- Item: Separator
+-- A single line to separate items
+do
+	local widgetType = "Dropdown-Item-Separator"
+	local widgetVersion = 2
+
+	-- exported, override
+	local function SetDisabled(self, disabled)
+		ItemBase.SetDisabled(self, disabled)
+		self.useHighlight = false
+	end
+
+	local function Constructor()
+		local self = ItemBase.Create(widgetType)
+
+		self.SetDisabled = SetDisabled
+
+		local line = self.frame:CreateTexture(nil, "OVERLAY")
+		line:SetHeight(1)
+		line:SetColorTexture(.5, .5, .5)
+		line:SetPoint("LEFT", self.frame, "LEFT", 10, 0)
+		line:SetPoint("RIGHT", self.frame, "RIGHT", -10, 0)
+
+		self.text:Hide()
+
+		self.useHighlight = false
+
+		AceGUI:RegisterAsWidget(self)
+		return self
+	end
+
+	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
+end
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown.lua
index 3d8dd11..59c7f53 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown.lua
@@ -1,732 +1,732 @@
---[[ $Id: AceGUIWidget-DropDown.lua 1284 2022-09-25 09:15:30Z nevcairiel $ ]]--
-local AceGUI = LibStub("AceGUI-3.0")
-
--- Lua APIs
-local min, max, floor = math.min, math.max, math.floor
-local select, pairs, ipairs, type, tostring = select, pairs, ipairs, type, tostring
-local tsort = table.sort
-
--- WoW APIs
-local PlaySound = PlaySound
-local UIParent, CreateFrame = UIParent, CreateFrame
-local _G = _G
-
-local function fixlevels(parent,...)
-	local i = 1
-	local child = select(i, ...)
-	while child do
-		child:SetFrameLevel(parent:GetFrameLevel()+1)
-		fixlevels(child, child:GetChildren())
-		i = i + 1
-		child = select(i, ...)
-	end
-end
-
-local function fixstrata(strata, parent, ...)
-	local i = 1
-	local child = select(i, ...)
-	parent:SetFrameStrata(strata)
-	while child do
-		fixstrata(strata, child, child:GetChildren())
-		i = i + 1
-		child = select(i, ...)
-	end
-end
-
-do
-	local widgetType = "Dropdown-Pullout"
-	local widgetVersion = 5
-
-	--[[ Static data ]]--
-
-	local backdrop = {
-		bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
-		edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
-		edgeSize = 32,
-		tileSize = 32,
-		tile = true,
-		insets = { left = 11, right = 12, top = 12, bottom = 11 },
-	}
-	local sliderBackdrop  = {
-		bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
-		edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
-		tile = true, tileSize = 8, edgeSize = 8,
-		insets = { left = 3, right = 3, top = 3, bottom = 3 }
-	}
-
-	local defaultWidth = 200
-	local defaultMaxHeight = 600
-
-	--[[ UI Event Handlers ]]--
-
-	-- HACK: This should be no part of the pullout, but there
-	--       is no other 'clean' way to response to any item-OnEnter
-	--       Used to close Submenus when an other item is entered
-	local function OnEnter(item)
-		local self = item.pullout
-		for k, v in ipairs(self.items) do
-			if v.CloseMenu and v ~= item then
-				v:CloseMenu()
-			end
-		end
-	end
-
-	-- See the note in Constructor() for each scroll related function
-	local function OnMouseWheel(this, value)
-		this.obj:MoveScroll(value)
-	end
-
-	local function OnScrollValueChanged(this, value)
-		this.obj:SetScroll(value)
-	end
-
-	local function OnSizeChanged(this)
-		this.obj:FixScroll()
-	end
-
-	--[[ Exported methods ]]--
-
-	-- exported
-	local function SetScroll(self, value)
-		local status = self.scrollStatus
-		local frame, child = self.scrollFrame, self.itemFrame
-		local height, viewheight = frame:GetHeight(), child:GetHeight()
-
-		local offset
-		if height > viewheight then
-			offset = 0
-		else
-			offset = floor((viewheight - height) / 1000 * value)
-		end
-		child:ClearAllPoints()
-		child:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, offset)
-		child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", self.slider:IsShown() and -12 or 0, offset)
-		status.offset = offset
-		status.scrollvalue = value
-	end
-
-	-- exported
-	local function MoveScroll(self, value)
-		local status = self.scrollStatus
-		local frame, child = self.scrollFrame, self.itemFrame
-		local height, viewheight = frame:GetHeight(), child:GetHeight()
-
-		if height > viewheight then
-			self.slider:Hide()
-		else
-			self.slider:Show()
-			local diff = height - viewheight
-			local delta = 1
-			if value < 0 then
-				delta = -1
-			end
-			self.slider:SetValue(min(max(status.scrollvalue + delta*(1000/(diff/45)),0), 1000))
-		end
-	end
-
-	-- exported
-	local function FixScroll(self)
-		local status = self.scrollStatus
-		local frame, child = self.scrollFrame, self.itemFrame
-		local height, viewheight = frame:GetHeight(), child:GetHeight()
-		local offset = status.offset or 0
-
-		if viewheight < height then
-			self.slider:Hide()
-			child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, offset)
-			self.slider:SetValue(0)
-		else
-			self.slider:Show()
-			local value = (offset / (viewheight - height) * 1000)
-			if value > 1000 then value = 1000 end
-			self.slider:SetValue(value)
-			self:SetScroll(value)
-			if value < 1000 then
-				child:ClearAllPoints()
-				child:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, offset)
-				child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -12, offset)
-				status.offset = offset
-			end
-		end
-	end
-
-	-- exported, AceGUI callback
-	local function OnAcquire(self)
-		self.frame:SetParent(UIParent)
-		--self.itemFrame:SetToplevel(true)
-	end
-
-	-- exported, AceGUI callback
-	local function OnRelease(self)
-		self:Clear()
-		self.frame:ClearAllPoints()
-		self.frame:Hide()
-	end
-
-	-- exported
-	local function AddItem(self, item)
-		self.items[#self.items + 1] = item
-
-		local h = #self.items * 16
-		self.itemFrame:SetHeight(h)
-		self.frame:SetHeight(min(h + 34, self.maxHeight)) -- +34: 20 for scrollFrame placement (10 offset) and +14 for item placement
-
-		item.frame:SetPoint("LEFT", self.itemFrame, "LEFT")
-		item.frame:SetPoint("RIGHT", self.itemFrame, "RIGHT")
-
-		item:SetPullout(self)
-		item:SetOnEnter(OnEnter)
-	end
-
-	-- exported
-	local function Open(self, point, relFrame, relPoint, x, y)
-		local items = self.items
-		local frame = self.frame
-		local itemFrame = self.itemFrame
-
-		frame:SetPoint(point, relFrame, relPoint, x, y)
-
-
-		local height = 8
-		for i, item in pairs(items) do
-			item:SetPoint("TOP", itemFrame, "TOP", 0, -2 + (i - 1) * -16)
-			item:Show()
-
-			height = height + 16
-		end
-		itemFrame:SetHeight(height)
-		fixstrata("TOOLTIP", frame, frame:GetChildren())
-		frame:Show()
-		self:Fire("OnOpen")
-	end
-
-	-- exported
-	local function Close(self)
-		self.frame:Hide()
-		self:Fire("OnClose")
-	end
-
-	-- exported
-	local function Clear(self)
-		local items = self.items
-		for i, item in pairs(items) do
-			AceGUI:Release(item)
-			items[i] = nil
-		end
-	end
-
-	-- exported
-	local function IterateItems(self)
-		return ipairs(self.items)
-	end
-
-	-- exported
-	local function SetHideOnLeave(self, val)
-		self.hideOnLeave = val
-	end
-
-	-- exported
-	local function SetMaxHeight(self, height)
-		self.maxHeight = height or defaultMaxHeight
-		if self.frame:GetHeight() > height then
-			self.frame:SetHeight(height)
-		elseif (self.itemFrame:GetHeight() + 34) < height then
-			self.frame:SetHeight(self.itemFrame:GetHeight() + 34) -- see :AddItem
-		end
-	end
-
-	-- exported
-	local function GetRightBorderWidth(self)
-		return 6 + (self.slider:IsShown() and 12 or 0)
-	end
-
-	-- exported
-	local function GetLeftBorderWidth(self)
-		return 6
-	end
-
-	--[[ Constructor ]]--
-
-	local function Constructor()
-		local count = AceGUI:GetNextWidgetNum(widgetType)
-		local frame = CreateFrame("Frame", "AceGUI30Pullout"..count, UIParent, "BackdropTemplate")
-		local self = {}
-		self.count = count
-		self.type = widgetType
-		self.frame = frame
-		frame.obj = self
-
-		self.OnAcquire = OnAcquire
-		self.OnRelease = OnRelease
-
-		self.AddItem = AddItem
-		self.Open    = Open
-		self.Close   = Close
-		self.Clear   = Clear
-		self.IterateItems = IterateItems
-		self.SetHideOnLeave = SetHideOnLeave
-
-		self.SetScroll  = SetScroll
-		self.MoveScroll = MoveScroll
-		self.FixScroll  = FixScroll
-
-		self.SetMaxHeight = SetMaxHeight
-		self.GetRightBorderWidth = GetRightBorderWidth
-		self.GetLeftBorderWidth = GetLeftBorderWidth
-
-		self.items = {}
-
-		self.scrollStatus = {
-			scrollvalue = 0,
-		}
-
-		self.maxHeight = defaultMaxHeight
-
-		frame:SetBackdrop(backdrop)
-		frame:SetBackdropColor(0, 0, 0)
-		frame:SetFrameStrata("FULLSCREEN_DIALOG")
-		frame:SetClampedToScreen(true)
-		frame:SetWidth(defaultWidth)
-		frame:SetHeight(self.maxHeight)
-		--frame:SetToplevel(true)
-
-		-- NOTE: The whole scroll frame code is copied from the AceGUI-3.0 widget ScrollFrame
-		local scrollFrame = CreateFrame("ScrollFrame", nil, frame)
-		local itemFrame = CreateFrame("Frame", nil, scrollFrame)
-
-		self.scrollFrame = scrollFrame
-		self.itemFrame = itemFrame
-
-		scrollFrame.obj = self
-		itemFrame.obj = self
-
-		local slider = CreateFrame("Slider", "AceGUI30PulloutScrollbar"..count, scrollFrame, "BackdropTemplate")
-		slider:SetOrientation("VERTICAL")
-		slider:SetHitRectInsets(0, 0, -10, 0)
-		slider:SetBackdrop(sliderBackdrop)
-		slider:SetWidth(8)
-		slider:SetThumbTexture("Interface\\Buttons\\UI-SliderBar-Button-Vertical")
-		slider:SetFrameStrata("FULLSCREEN_DIALOG")
-		self.slider = slider
-		slider.obj = self
-
-		scrollFrame:SetScrollChild(itemFrame)
-		scrollFrame:SetPoint("TOPLEFT", frame, "TOPLEFT", 6, -12)
-		scrollFrame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -6, 12)
-		scrollFrame:EnableMouseWheel(true)
-		scrollFrame:SetScript("OnMouseWheel", OnMouseWheel)
-		scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
-		scrollFrame:SetToplevel(true)
-		scrollFrame:SetFrameStrata("FULLSCREEN_DIALOG")
-
-		itemFrame:SetPoint("TOPLEFT", scrollFrame, "TOPLEFT", 0, 0)
-		itemFrame:SetPoint("TOPRIGHT", scrollFrame, "TOPRIGHT", -12, 0)
-		itemFrame:SetHeight(400)
-		itemFrame:SetToplevel(true)
-		itemFrame:SetFrameStrata("FULLSCREEN_DIALOG")
-
-		slider:SetPoint("TOPLEFT", scrollFrame, "TOPRIGHT", -16, 0)
-		slider:SetPoint("BOTTOMLEFT", scrollFrame, "BOTTOMRIGHT", -16, 0)
-		slider:SetScript("OnValueChanged", OnScrollValueChanged)
-		slider:SetMinMaxValues(0, 1000)
-		slider:SetValueStep(1)
-		slider:SetValue(0)
-
-		scrollFrame:Show()
-		itemFrame:Show()
-		slider:Hide()
-
-		self:FixScroll()
-
-		AceGUI:RegisterAsWidget(self)
-		return self
-	end
-
-	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)
-end
-
-do
-	local widgetType = "Dropdown"
-	local widgetVersion = 36
-
-	--[[ Static data ]]--
-
-	--[[ UI event handler ]]--
-
-	local function Control_OnEnter(this)
-		this.obj.button:LockHighlight()
-		this.obj:Fire("OnEnter")
-	end
-
-	local function Control_OnLeave(this)
-		this.obj.button:UnlockHighlight()
-		this.obj:Fire("OnLeave")
-	end
-
-	local function Dropdown_OnHide(this)
-		local self = this.obj
-		if self.open then
-			self.pullout:Close()
-		end
-	end
-
-	local function Dropdown_TogglePullout(this)
-		local self = this.obj
-		if self.open then
-			self.open = nil
-			self.pullout:Close()
-			AceGUI:ClearFocus()
-		else
-			self.open = true
-			self.pullout:SetWidth(self.pulloutWidth or self.frame:GetWidth())
-			self.pullout:Open("TOPLEFT", self.frame, "BOTTOMLEFT", 0, self.label:IsShown() and -2 or 0)
-			AceGUI:SetFocus(self)
-		end
-	end
-
-	local function OnPulloutOpen(this)
-		local self = this.userdata.obj
-		local value = self.value
-
-		if not self.multiselect then
-			for i, item in this:IterateItems() do
-				item:SetValue(item.userdata.value == value)
-			end
-		end
-
-		self.open = true
-		self:Fire("OnOpened")
-	end
-
-	local function OnPulloutClose(this)
-		local self = this.userdata.obj
-		self.open = nil
-		self:Fire("OnClosed")
-	end
-
-	local function ShowMultiText(self)
-		local text
-		for i, widget in self.pullout:IterateItems() do
-			if widget.type == "Dropdown-Item-Toggle" then
-				if widget:GetValue() then
-					if text then
-						text = text..", "..widget:GetText()
-					else
-						text = widget:GetText()
-					end
-				end
-			end
-		end
-		self:SetText(text)
-	end
-
-	local function OnItemValueChanged(this, event, checked)
-		local self = this.userdata.obj
-
-		if self.multiselect then
-			self:Fire("OnValueChanged", this.userdata.value, checked)
-			ShowMultiText(self)
-		else
-			if checked then
-				self:SetValue(this.userdata.value)
-				self:Fire("OnValueChanged", this.userdata.value)
-			else
-				this:SetValue(true)
-			end
-			if self.open then
-				self.pullout:Close()
-			end
-		end
-	end
-
-	--[[ Exported methods ]]--
-
-	-- exported, AceGUI callback
-	local function OnAcquire(self)
-		local pullout = AceGUI:Create("Dropdown-Pullout")
-		self.pullout = pullout
-		pullout.userdata.obj = self
-		pullout:SetCallback("OnClose", OnPulloutClose)
-		pullout:SetCallback("OnOpen", OnPulloutOpen)
-		self.pullout.frame:SetFrameLevel(self.frame:GetFrameLevel() + 1)
-		fixlevels(self.pullout.frame, self.pullout.frame:GetChildren())
-
-		self:SetHeight(44)
-		self:SetWidth(200)
-		self:SetLabel()
-		self:SetPulloutWidth(nil)
-		self.list = {}
-	end
-
-	-- exported, AceGUI callback
-	local function OnRelease(self)
-		if self.open then
-			self.pullout:Close()
-		end
-		AceGUI:Release(self.pullout)
-		self.pullout = nil
-
-		self:SetText("")
-		self:SetDisabled(false)
-		self:SetMultiselect(false)
-
-		self.value = nil
-		self.list = nil
-		self.open = nil
-		self.hasClose = nil
-
-		self.frame:ClearAllPoints()
-		self.frame:Hide()
-	end
-
-	-- exported
-	local function SetDisabled(self, disabled)
-		self.disabled = disabled
-		if disabled then
-			self.text:SetTextColor(0.5,0.5,0.5)
-			self.button:Disable()
-			self.button_cover:Disable()
-			self.label:SetTextColor(0.5,0.5,0.5)
-		else
-			self.button:Enable()
-			self.button_cover:Enable()
-			self.label:SetTextColor(1,.82,0)
-			self.text:SetTextColor(1,1,1)
-		end
-	end
-
-	-- exported
-	local function ClearFocus(self)
-		if self.open then
-			self.pullout:Close()
-		end
-	end
-
-	-- exported
-	local function SetText(self, text)
-		self.text:SetText(text or "")
-	end
-
-	-- exported
-	local function SetLabel(self, text)
-		if text and text ~= "" then
-			self.label:SetText(text)
-			self.label:Show()
-			self.dropdown:SetPoint("TOPLEFT",self.frame,"TOPLEFT",-15,-14)
-			self:SetHeight(40)
-			self.alignoffset = 26
-		else
-			self.label:SetText("")
-			self.label:Hide()
-			self.dropdown:SetPoint("TOPLEFT",self.frame,"TOPLEFT",-15,0)
-			self:SetHeight(26)
-			self.alignoffset = 12
-		end
-	end
-
-	-- exported
-	local function SetValue(self, value)
-		self:SetText(self.list[value] or "")
-		self.value = value
-	end
-
-	-- exported
-	local function GetValue(self)
-		return self.value
-	end
-
-	-- exported
-	local function SetItemValue(self, item, value)
-		if not self.multiselect then return end
-		for i, widget in self.pullout:IterateItems() do
-			if widget.userdata.value == item then
-				if widget.SetValue then
-					widget:SetValue(value)
-				end
-			end
-		end
-		ShowMultiText(self)
-	end
-
-	-- exported
-	local function SetItemDisabled(self, item, disabled)
-		for i, widget in self.pullout:IterateItems() do
-			if widget.userdata.value == item then
-				widget:SetDisabled(disabled)
-			end
-		end
-	end
-
-	local function AddListItem(self, value, text, itemType)
-		if not itemType then itemType = "Dropdown-Item-Toggle" end
-		local exists = AceGUI:GetWidgetVersion(itemType)
-		if not exists then error(("The given item type, %q, does not exist within AceGUI-3.0"):format(tostring(itemType)), 2) end
-
-		local item = AceGUI:Create(itemType)
-		item:SetText(text)
-		item.userdata.obj = self
-		item.userdata.value = value
-		item:SetCallback("OnValueChanged", OnItemValueChanged)
-		self.pullout:AddItem(item)
-	end
-
-	local function AddCloseButton(self)
-		if not self.hasClose then
-			local close = AceGUI:Create("Dropdown-Item-Execute")
-			close:SetText(CLOSE)
-			self.pullout:AddItem(close)
-			self.hasClose = true
-		end
-	end
-
-	-- exported
-	local sortlist = {}
-	local function sortTbl(x,y)
-		local num1, num2 = tonumber(x), tonumber(y)
-		if num1 and num2 then -- numeric comparison, either two numbers or numeric strings
-			return num1 < num2
-		else -- compare everything else tostring'ed
-			return tostring(x) < tostring(y)
-		end
-	end
-	local function SetList(self, list, order, itemType)
-		self.list = list or {}
-		self.pullout:Clear()
-		self.hasClose = nil
-		if not list then return end
-
-		if type(order) ~= "table" then
-			for v in pairs(list) do
-				sortlist[#sortlist + 1] = v
-			end
-			tsort(sortlist, sortTbl)
-
-			for i, key in ipairs(sortlist) do
-				AddListItem(self, key, list[key], itemType)
-				sortlist[i] = nil
-			end
-		else
-			for i, key in ipairs(order) do
-				AddListItem(self, key, list[key], itemType)
-			end
-		end
-		if self.multiselect then
-			ShowMultiText(self)
-			AddCloseButton(self)
-		end
-	end
-
-	-- exported
-	local function AddItem(self, value, text, itemType)
-		self.list[value] = text
-		AddListItem(self, value, text, itemType)
-	end
-
-	-- exported
-	local function SetMultiselect(self, multi)
-		self.multiselect = multi
-		if multi then
-			ShowMultiText(self)
-			AddCloseButton(self)
-		end
-	end
-
-	-- exported
-	local function GetMultiselect(self)
-		return self.multiselect
-	end
-
-	local function SetPulloutWidth(self, width)
-		self.pulloutWidth = width
-	end
-
-	--[[ Constructor ]]--
-
-	local function Constructor()
-		local count = AceGUI:GetNextWidgetNum(widgetType)
-		local frame = CreateFrame("Frame", nil, UIParent)
-		local dropdown = CreateFrame("Frame", "AceGUI30DropDown"..count, frame, "UIDropDownMenuTemplate")
-
-		local self = {}
-		self.type = widgetType
-		self.frame = frame
-		self.dropdown = dropdown
-		self.count = count
-		frame.obj = self
-		dropdown.obj = self
-
-		self.OnRelease   = OnRelease
-		self.OnAcquire   = OnAcquire
-
-		self.ClearFocus  = ClearFocus
-
-		self.SetText     = SetText
-		self.SetValue    = SetValue
-		self.GetValue    = GetValue
-		self.SetList     = SetList
-		self.SetLabel    = SetLabel
-		self.SetDisabled = SetDisabled
-		self.AddItem     = AddItem
-		self.SetMultiselect = SetMultiselect
-		self.GetMultiselect = GetMultiselect
-		self.SetItemValue = SetItemValue
-		self.SetItemDisabled = SetItemDisabled
-		self.SetPulloutWidth = SetPulloutWidth
-
-		self.alignoffset = 26
-
-		frame:SetScript("OnHide",Dropdown_OnHide)
-
-		dropdown:ClearAllPoints()
-		dropdown:SetPoint("TOPLEFT",frame,"TOPLEFT",-15,0)
-		dropdown:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",17,0)
-		dropdown:SetScript("OnHide", nil)
-
-		local left = _G[dropdown:GetName() .. "Left"]
-		local middle = _G[dropdown:GetName() .. "Middle"]
-		local right = _G[dropdown:GetName() .. "Right"]
-
-		middle:ClearAllPoints()
-		right:ClearAllPoints()
-
-		middle:SetPoint("LEFT", left, "RIGHT", 0, 0)
-		middle:SetPoint("RIGHT", right, "LEFT", 0, 0)
-		right:SetPoint("TOPRIGHT", dropdown, "TOPRIGHT", 0, 17)
-
-		local button = _G[dropdown:GetName() .. "Button"]
-		self.button = button
-		button.obj = self
-		button:SetScript("OnEnter",Control_OnEnter)
-		button:SetScript("OnLeave",Control_OnLeave)
-		button:SetScript("OnClick",Dropdown_TogglePullout)
-
-		local button_cover = CreateFrame("BUTTON",nil,self.frame)
-		self.button_cover = button_cover
-		button_cover.obj = self
-		button_cover:SetPoint("TOPLEFT",self.frame,"BOTTOMLEFT",0,25)
-		button_cover:SetPoint("BOTTOMRIGHT",self.frame,"BOTTOMRIGHT")
-		button_cover:SetScript("OnEnter",Control_OnEnter)
-		button_cover:SetScript("OnLeave",Control_OnLeave)
-		button_cover:SetScript("OnClick",Dropdown_TogglePullout)
-
-		local text = _G[dropdown:GetName() .. "Text"]
-		self.text = text
-		text.obj = self
-		text:ClearAllPoints()
-		text:SetPoint("RIGHT", right, "RIGHT" ,-43, 2)
-		text:SetPoint("LEFT", left, "LEFT", 25, 2)
-
-		local label = frame:CreateFontString(nil,"OVERLAY","GameFontNormalSmall")
-		label:SetPoint("TOPLEFT",frame,"TOPLEFT",0,0)
-		label:SetPoint("TOPRIGHT",frame,"TOPRIGHT",0,0)
-		label:SetJustifyH("LEFT")
-		label:SetHeight(18)
-		label:Hide()
-		self.label = label
-
-		AceGUI:RegisterAsWidget(self)
-		return self
-	end
-
-	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)
-end
+--[[ $Id: AceGUIWidget-DropDown.lua 1284 2022-09-25 09:15:30Z nevcairiel $ ]]--
+local AceGUI = LibStub("AceGUI-3.0")
+
+-- Lua APIs
+local min, max, floor = math.min, math.max, math.floor
+local select, pairs, ipairs, type, tostring = select, pairs, ipairs, type, tostring
+local tsort = table.sort
+
+-- WoW APIs
+local PlaySound = PlaySound
+local UIParent, CreateFrame = UIParent, CreateFrame
+local _G = _G
+
+local function fixlevels(parent,...)
+	local i = 1
+	local child = select(i, ...)
+	while child do
+		child:SetFrameLevel(parent:GetFrameLevel()+1)
+		fixlevels(child, child:GetChildren())
+		i = i + 1
+		child = select(i, ...)
+	end
+end
+
+local function fixstrata(strata, parent, ...)
+	local i = 1
+	local child = select(i, ...)
+	parent:SetFrameStrata(strata)
+	while child do
+		fixstrata(strata, child, child:GetChildren())
+		i = i + 1
+		child = select(i, ...)
+	end
+end
+
+do
+	local widgetType = "Dropdown-Pullout"
+	local widgetVersion = 5
+
+	--[[ Static data ]]--
+
+	local backdrop = {
+		bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
+		edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
+		edgeSize = 32,
+		tileSize = 32,
+		tile = true,
+		insets = { left = 11, right = 12, top = 12, bottom = 11 },
+	}
+	local sliderBackdrop  = {
+		bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
+		edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
+		tile = true, tileSize = 8, edgeSize = 8,
+		insets = { left = 3, right = 3, top = 3, bottom = 3 }
+	}
+
+	local defaultWidth = 200
+	local defaultMaxHeight = 600
+
+	--[[ UI Event Handlers ]]--
+
+	-- HACK: This should be no part of the pullout, but there
+	--       is no other 'clean' way to response to any item-OnEnter
+	--       Used to close Submenus when an other item is entered
+	local function OnEnter(item)
+		local self = item.pullout
+		for k, v in ipairs(self.items) do
+			if v.CloseMenu and v ~= item then
+				v:CloseMenu()
+			end
+		end
+	end
+
+	-- See the note in Constructor() for each scroll related function
+	local function OnMouseWheel(this, value)
+		this.obj:MoveScroll(value)
+	end
+
+	local function OnScrollValueChanged(this, value)
+		this.obj:SetScroll(value)
+	end
+
+	local function OnSizeChanged(this)
+		this.obj:FixScroll()
+	end
+
+	--[[ Exported methods ]]--
+
+	-- exported
+	local function SetScroll(self, value)
+		local status = self.scrollStatus
+		local frame, child = self.scrollFrame, self.itemFrame
+		local height, viewheight = frame:GetHeight(), child:GetHeight()
+
+		local offset
+		if height > viewheight then
+			offset = 0
+		else
+			offset = floor((viewheight - height) / 1000 * value)
+		end
+		child:ClearAllPoints()
+		child:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, offset)
+		child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", self.slider:IsShown() and -12 or 0, offset)
+		status.offset = offset
+		status.scrollvalue = value
+	end
+
+	-- exported
+	local function MoveScroll(self, value)
+		local status = self.scrollStatus
+		local frame, child = self.scrollFrame, self.itemFrame
+		local height, viewheight = frame:GetHeight(), child:GetHeight()
+
+		if height > viewheight then
+			self.slider:Hide()
+		else
+			self.slider:Show()
+			local diff = height - viewheight
+			local delta = 1
+			if value < 0 then
+				delta = -1
+			end
+			self.slider:SetValue(min(max(status.scrollvalue + delta*(1000/(diff/45)),0), 1000))
+		end
+	end
+
+	-- exported
+	local function FixScroll(self)
+		local status = self.scrollStatus
+		local frame, child = self.scrollFrame, self.itemFrame
+		local height, viewheight = frame:GetHeight(), child:GetHeight()
+		local offset = status.offset or 0
+
+		if viewheight < height then
+			self.slider:Hide()
+			child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, offset)
+			self.slider:SetValue(0)
+		else
+			self.slider:Show()
+			local value = (offset / (viewheight - height) * 1000)
+			if value > 1000 then value = 1000 end
+			self.slider:SetValue(value)
+			self:SetScroll(value)
+			if value < 1000 then
+				child:ClearAllPoints()
+				child:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, offset)
+				child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -12, offset)
+				status.offset = offset
+			end
+		end
+	end
+
+	-- exported, AceGUI callback
+	local function OnAcquire(self)
+		self.frame:SetParent(UIParent)
+		--self.itemFrame:SetToplevel(true)
+	end
+
+	-- exported, AceGUI callback
+	local function OnRelease(self)
+		self:Clear()
+		self.frame:ClearAllPoints()
+		self.frame:Hide()
+	end
+
+	-- exported
+	local function AddItem(self, item)
+		self.items[#self.items + 1] = item
+
+		local h = #self.items * 16
+		self.itemFrame:SetHeight(h)
+		self.frame:SetHeight(min(h + 34, self.maxHeight)) -- +34: 20 for scrollFrame placement (10 offset) and +14 for item placement
+
+		item.frame:SetPoint("LEFT", self.itemFrame, "LEFT")
+		item.frame:SetPoint("RIGHT", self.itemFrame, "RIGHT")
+
+		item:SetPullout(self)
+		item:SetOnEnter(OnEnter)
+	end
+
+	-- exported
+	local function Open(self, point, relFrame, relPoint, x, y)
+		local items = self.items
+		local frame = self.frame
+		local itemFrame = self.itemFrame
+
+		frame:SetPoint(point, relFrame, relPoint, x, y)
+
+
+		local height = 8
+		for i, item in pairs(items) do
+			item:SetPoint("TOP", itemFrame, "TOP", 0, -2 + (i - 1) * -16)
+			item:Show()
+
+			height = height + 16
+		end
+		itemFrame:SetHeight(height)
+		fixstrata("TOOLTIP", frame, frame:GetChildren())
+		frame:Show()
+		self:Fire("OnOpen")
+	end
+
+	-- exported
+	local function Close(self)
+		self.frame:Hide()
+		self:Fire("OnClose")
+	end
+
+	-- exported
+	local function Clear(self)
+		local items = self.items
+		for i, item in pairs(items) do
+			AceGUI:Release(item)
+			items[i] = nil
+		end
+	end
+
+	-- exported
+	local function IterateItems(self)
+		return ipairs(self.items)
+	end
+
+	-- exported
+	local function SetHideOnLeave(self, val)
+		self.hideOnLeave = val
+	end
+
+	-- exported
+	local function SetMaxHeight(self, height)
+		self.maxHeight = height or defaultMaxHeight
+		if self.frame:GetHeight() > height then
+			self.frame:SetHeight(height)
+		elseif (self.itemFrame:GetHeight() + 34) < height then
+			self.frame:SetHeight(self.itemFrame:GetHeight() + 34) -- see :AddItem
+		end
+	end
+
+	-- exported
+	local function GetRightBorderWidth(self)
+		return 6 + (self.slider:IsShown() and 12 or 0)
+	end
+
+	-- exported
+	local function GetLeftBorderWidth(self)
+		return 6
+	end
+
+	--[[ Constructor ]]--
+
+	local function Constructor()
+		local count = AceGUI:GetNextWidgetNum(widgetType)
+		local frame = CreateFrame("Frame", "AceGUI30Pullout"..count, UIParent, "BackdropTemplate")
+		local self = {}
+		self.count = count
+		self.type = widgetType
+		self.frame = frame
+		frame.obj = self
+
+		self.OnAcquire = OnAcquire
+		self.OnRelease = OnRelease
+
+		self.AddItem = AddItem
+		self.Open    = Open
+		self.Close   = Close
+		self.Clear   = Clear
+		self.IterateItems = IterateItems
+		self.SetHideOnLeave = SetHideOnLeave
+
+		self.SetScroll  = SetScroll
+		self.MoveScroll = MoveScroll
+		self.FixScroll  = FixScroll
+
+		self.SetMaxHeight = SetMaxHeight
+		self.GetRightBorderWidth = GetRightBorderWidth
+		self.GetLeftBorderWidth = GetLeftBorderWidth
+
+		self.items = {}
+
+		self.scrollStatus = {
+			scrollvalue = 0,
+		}
+
+		self.maxHeight = defaultMaxHeight
+
+		frame:SetBackdrop(backdrop)
+		frame:SetBackdropColor(0, 0, 0)
+		frame:SetFrameStrata("FULLSCREEN_DIALOG")
+		frame:SetClampedToScreen(true)
+		frame:SetWidth(defaultWidth)
+		frame:SetHeight(self.maxHeight)
+		--frame:SetToplevel(true)
+
+		-- NOTE: The whole scroll frame code is copied from the AceGUI-3.0 widget ScrollFrame
+		local scrollFrame = CreateFrame("ScrollFrame", nil, frame)
+		local itemFrame = CreateFrame("Frame", nil, scrollFrame)
+
+		self.scrollFrame = scrollFrame
+		self.itemFrame = itemFrame
+
+		scrollFrame.obj = self
+		itemFrame.obj = self
+
+		local slider = CreateFrame("Slider", "AceGUI30PulloutScrollbar"..count, scrollFrame, "BackdropTemplate")
+		slider:SetOrientation("VERTICAL")
+		slider:SetHitRectInsets(0, 0, -10, 0)
+		slider:SetBackdrop(sliderBackdrop)
+		slider:SetWidth(8)
+		slider:SetThumbTexture("Interface\\Buttons\\UI-SliderBar-Button-Vertical")
+		slider:SetFrameStrata("FULLSCREEN_DIALOG")
+		self.slider = slider
+		slider.obj = self
+
+		scrollFrame:SetScrollChild(itemFrame)
+		scrollFrame:SetPoint("TOPLEFT", frame, "TOPLEFT", 6, -12)
+		scrollFrame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -6, 12)
+		scrollFrame:EnableMouseWheel(true)
+		scrollFrame:SetScript("OnMouseWheel", OnMouseWheel)
+		scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
+		scrollFrame:SetToplevel(true)
+		scrollFrame:SetFrameStrata("FULLSCREEN_DIALOG")
+
+		itemFrame:SetPoint("TOPLEFT", scrollFrame, "TOPLEFT", 0, 0)
+		itemFrame:SetPoint("TOPRIGHT", scrollFrame, "TOPRIGHT", -12, 0)
+		itemFrame:SetHeight(400)
+		itemFrame:SetToplevel(true)
+		itemFrame:SetFrameStrata("FULLSCREEN_DIALOG")
+
+		slider:SetPoint("TOPLEFT", scrollFrame, "TOPRIGHT", -16, 0)
+		slider:SetPoint("BOTTOMLEFT", scrollFrame, "BOTTOMRIGHT", -16, 0)
+		slider:SetScript("OnValueChanged", OnScrollValueChanged)
+		slider:SetMinMaxValues(0, 1000)
+		slider:SetValueStep(1)
+		slider:SetValue(0)
+
+		scrollFrame:Show()
+		itemFrame:Show()
+		slider:Hide()
+
+		self:FixScroll()
+
+		AceGUI:RegisterAsWidget(self)
+		return self
+	end
+
+	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)
+end
+
+do
+	local widgetType = "Dropdown"
+	local widgetVersion = 36
+
+	--[[ Static data ]]--
+
+	--[[ UI event handler ]]--
+
+	local function Control_OnEnter(this)
+		this.obj.button:LockHighlight()
+		this.obj:Fire("OnEnter")
+	end
+
+	local function Control_OnLeave(this)
+		this.obj.button:UnlockHighlight()
+		this.obj:Fire("OnLeave")
+	end
+
+	local function Dropdown_OnHide(this)
+		local self = this.obj
+		if self.open then
+			self.pullout:Close()
+		end
+	end
+
+	local function Dropdown_TogglePullout(this)
+		local self = this.obj
+		if self.open then
+			self.open = nil
+			self.pullout:Close()
+			AceGUI:ClearFocus()
+		else
+			self.open = true
+			self.pullout:SetWidth(self.pulloutWidth or self.frame:GetWidth())
+			self.pullout:Open("TOPLEFT", self.frame, "BOTTOMLEFT", 0, self.label:IsShown() and -2 or 0)
+			AceGUI:SetFocus(self)
+		end
+	end
+
+	local function OnPulloutOpen(this)
+		local self = this.userdata.obj
+		local value = self.value
+
+		if not self.multiselect then
+			for i, item in this:IterateItems() do
+				item:SetValue(item.userdata.value == value)
+			end
+		end
+
+		self.open = true
+		self:Fire("OnOpened")
+	end
+
+	local function OnPulloutClose(this)
+		local self = this.userdata.obj
+		self.open = nil
+		self:Fire("OnClosed")
+	end
+
+	local function ShowMultiText(self)
+		local text
+		for i, widget in self.pullout:IterateItems() do
+			if widget.type == "Dropdown-Item-Toggle" then
+				if widget:GetValue() then
+					if text then
+						text = text..", "..widget:GetText()
+					else
+						text = widget:GetText()
+					end
+				end
+			end
+		end
+		self:SetText(text)
+	end
+
+	local function OnItemValueChanged(this, event, checked)
+		local self = this.userdata.obj
+
+		if self.multiselect then
+			self:Fire("OnValueChanged", this.userdata.value, checked)
+			ShowMultiText(self)
+		else
+			if checked then
+				self:SetValue(this.userdata.value)
+				self:Fire("OnValueChanged", this.userdata.value)
+			else
+				this:SetValue(true)
+			end
+			if self.open then
+				self.pullout:Close()
+			end
+		end
+	end
+
+	--[[ Exported methods ]]--
+
+	-- exported, AceGUI callback
+	local function OnAcquire(self)
+		local pullout = AceGUI:Create("Dropdown-Pullout")
+		self.pullout = pullout
+		pullout.userdata.obj = self
+		pullout:SetCallback("OnClose", OnPulloutClose)
+		pullout:SetCallback("OnOpen", OnPulloutOpen)
+		self.pullout.frame:SetFrameLevel(self.frame:GetFrameLevel() + 1)
+		fixlevels(self.pullout.frame, self.pullout.frame:GetChildren())
+
+		self:SetHeight(44)
+		self:SetWidth(200)
+		self:SetLabel()
+		self:SetPulloutWidth(nil)
+		self.list = {}
+	end
+
+	-- exported, AceGUI callback
+	local function OnRelease(self)
+		if self.open then
+			self.pullout:Close()
+		end
+		AceGUI:Release(self.pullout)
+		self.pullout = nil
+
+		self:SetText("")
+		self:SetDisabled(false)
+		self:SetMultiselect(false)
+
+		self.value = nil
+		self.list = nil
+		self.open = nil
+		self.hasClose = nil
+
+		self.frame:ClearAllPoints()
+		self.frame:Hide()
+	end
+
+	-- exported
+	local function SetDisabled(self, disabled)
+		self.disabled = disabled
+		if disabled then
+			self.text:SetTextColor(0.5,0.5,0.5)
+			self.button:Disable()
+			self.button_cover:Disable()
+			self.label:SetTextColor(0.5,0.5,0.5)
+		else
+			self.button:Enable()
+			self.button_cover:Enable()
+			self.label:SetTextColor(1,.82,0)
+			self.text:SetTextColor(1,1,1)
+		end
+	end
+
+	-- exported
+	local function ClearFocus(self)
+		if self.open then
+			self.pullout:Close()
+		end
+	end
+
+	-- exported
+	local function SetText(self, text)
+		self.text:SetText(text or "")
+	end
+
+	-- exported
+	local function SetLabel(self, text)
+		if text and text ~= "" then
+			self.label:SetText(text)
+			self.label:Show()
+			self.dropdown:SetPoint("TOPLEFT",self.frame,"TOPLEFT",-15,-14)
+			self:SetHeight(40)
+			self.alignoffset = 26
+		else
+			self.label:SetText("")
+			self.label:Hide()
+			self.dropdown:SetPoint("TOPLEFT",self.frame,"TOPLEFT",-15,0)
+			self:SetHeight(26)
+			self.alignoffset = 12
+		end
+	end
+
+	-- exported
+	local function SetValue(self, value)
+		self:SetText(self.list[value] or "")
+		self.value = value
+	end
+
+	-- exported
+	local function GetValue(self)
+		return self.value
+	end
+
+	-- exported
+	local function SetItemValue(self, item, value)
+		if not self.multiselect then return end
+		for i, widget in self.pullout:IterateItems() do
+			if widget.userdata.value == item then
+				if widget.SetValue then
+					widget:SetValue(value)
+				end
+			end
+		end
+		ShowMultiText(self)
+	end
+
+	-- exported
+	local function SetItemDisabled(self, item, disabled)
+		for i, widget in self.pullout:IterateItems() do
+			if widget.userdata.value == item then
+				widget:SetDisabled(disabled)
+			end
+		end
+	end
+
+	local function AddListItem(self, value, text, itemType)
+		if not itemType then itemType = "Dropdown-Item-Toggle" end
+		local exists = AceGUI:GetWidgetVersion(itemType)
+		if not exists then error(("The given item type, %q, does not exist within AceGUI-3.0"):format(tostring(itemType)), 2) end
+
+		local item = AceGUI:Create(itemType)
+		item:SetText(text)
+		item.userdata.obj = self
+		item.userdata.value = value
+		item:SetCallback("OnValueChanged", OnItemValueChanged)
+		self.pullout:AddItem(item)
+	end
+
+	local function AddCloseButton(self)
+		if not self.hasClose then
+			local close = AceGUI:Create("Dropdown-Item-Execute")
+			close:SetText(CLOSE)
+			self.pullout:AddItem(close)
+			self.hasClose = true
+		end
+	end
+
+	-- exported
+	local sortlist = {}
+	local function sortTbl(x,y)
+		local num1, num2 = tonumber(x), tonumber(y)
+		if num1 and num2 then -- numeric comparison, either two numbers or numeric strings
+			return num1 < num2
+		else -- compare everything else tostring'ed
+			return tostring(x) < tostring(y)
+		end
+	end
+	local function SetList(self, list, order, itemType)
+		self.list = list or {}
+		self.pullout:Clear()
+		self.hasClose = nil
+		if not list then return end
+
+		if type(order) ~= "table" then
+			for v in pairs(list) do
+				sortlist[#sortlist + 1] = v
+			end
+			tsort(sortlist, sortTbl)
+
+			for i, key in ipairs(sortlist) do
+				AddListItem(self, key, list[key], itemType)
+				sortlist[i] = nil
+			end
+		else
+			for i, key in ipairs(order) do
+				AddListItem(self, key, list[key], itemType)
+			end
+		end
+		if self.multiselect then
+			ShowMultiText(self)
+			AddCloseButton(self)
+		end
+	end
+
+	-- exported
+	local function AddItem(self, value, text, itemType)
+		self.list[value] = text
+		AddListItem(self, value, text, itemType)
+	end
+
+	-- exported
+	local function SetMultiselect(self, multi)
+		self.multiselect = multi
+		if multi then
+			ShowMultiText(self)
+			AddCloseButton(self)
+		end
+	end
+
+	-- exported
+	local function GetMultiselect(self)
+		return self.multiselect
+	end
+
+	local function SetPulloutWidth(self, width)
+		self.pulloutWidth = width
+	end
+
+	--[[ Constructor ]]--
+
+	local function Constructor()
+		local count = AceGUI:GetNextWidgetNum(widgetType)
+		local frame = CreateFrame("Frame", nil, UIParent)
+		local dropdown = CreateFrame("Frame", "AceGUI30DropDown"..count, frame, "UIDropDownMenuTemplate")
+
+		local self = {}
+		self.type = widgetType
+		self.frame = frame
+		self.dropdown = dropdown
+		self.count = count
+		frame.obj = self
+		dropdown.obj = self
+
+		self.OnRelease   = OnRelease
+		self.OnAcquire   = OnAcquire
+
+		self.ClearFocus  = ClearFocus
+
+		self.SetText     = SetText
+		self.SetValue    = SetValue
+		self.GetValue    = GetValue
+		self.SetList     = SetList
+		self.SetLabel    = SetLabel
+		self.SetDisabled = SetDisabled
+		self.AddItem     = AddItem
+		self.SetMultiselect = SetMultiselect
+		self.GetMultiselect = GetMultiselect
+		self.SetItemValue = SetItemValue
+		self.SetItemDisabled = SetItemDisabled
+		self.SetPulloutWidth = SetPulloutWidth
+
+		self.alignoffset = 26
+
+		frame:SetScript("OnHide",Dropdown_OnHide)
+
+		dropdown:ClearAllPoints()
+		dropdown:SetPoint("TOPLEFT",frame,"TOPLEFT",-15,0)
+		dropdown:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",17,0)
+		dropdown:SetScript("OnHide", nil)
+
+		local left = _G[dropdown:GetName() .. "Left"]
+		local middle = _G[dropdown:GetName() .. "Middle"]
+		local right = _G[dropdown:GetName() .. "Right"]
+
+		middle:ClearAllPoints()
+		right:ClearAllPoints()
+
+		middle:SetPoint("LEFT", left, "RIGHT", 0, 0)
+		middle:SetPoint("RIGHT", right, "LEFT", 0, 0)
+		right:SetPoint("TOPRIGHT", dropdown, "TOPRIGHT", 0, 17)
+
+		local button = _G[dropdown:GetName() .. "Button"]
+		self.button = button
+		button.obj = self
+		button:SetScript("OnEnter",Control_OnEnter)
+		button:SetScript("OnLeave",Control_OnLeave)
+		button:SetScript("OnClick",Dropdown_TogglePullout)
+
+		local button_cover = CreateFrame("BUTTON",nil,self.frame)
+		self.button_cover = button_cover
+		button_cover.obj = self
+		button_cover:SetPoint("TOPLEFT",self.frame,"BOTTOMLEFT",0,25)
+		button_cover:SetPoint("BOTTOMRIGHT",self.frame,"BOTTOMRIGHT")
+		button_cover:SetScript("OnEnter",Control_OnEnter)
+		button_cover:SetScript("OnLeave",Control_OnLeave)
+		button_cover:SetScript("OnClick",Dropdown_TogglePullout)
+
+		local text = _G[dropdown:GetName() .. "Text"]
+		self.text = text
+		text.obj = self
+		text:ClearAllPoints()
+		text:SetPoint("RIGHT", right, "RIGHT" ,-43, 2)
+		text:SetPoint("LEFT", left, "LEFT", 25, 2)
+
+		local label = frame:CreateFontString(nil,"OVERLAY","GameFontNormalSmall")
+		label:SetPoint("TOPLEFT",frame,"TOPLEFT",0,0)
+		label:SetPoint("TOPRIGHT",frame,"TOPRIGHT",0,0)
+		label:SetJustifyH("LEFT")
+		label:SetHeight(18)
+		label:Hide()
+		self.label = label
+
+		AceGUI:RegisterAsWidget(self)
+		return self
+	end
+
+	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)
+end
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-EditBox.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-EditBox.lua
index 85a32a0..bb1e4fd 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-EditBox.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-EditBox.lua
@@ -1,259 +1,259 @@
---[[-----------------------------------------------------------------------------
-EditBox Widget
--------------------------------------------------------------------------------]]
-local Type, Version = "EditBox", 28
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local tostring, pairs = tostring, pairs
-
--- WoW APIs
-local PlaySound = PlaySound
-local GetCursorInfo, ClearCursor, GetSpellInfo = GetCursorInfo, ClearCursor, GetSpellInfo
-local CreateFrame, UIParent = CreateFrame, UIParent
-local _G = _G
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-if not AceGUIEditBoxInsertLink then
-	-- upgradeable hook
-	hooksecurefunc("ChatEdit_InsertLink", function(...) return _G.AceGUIEditBoxInsertLink(...) end)
-end
-
-function _G.AceGUIEditBoxInsertLink(text)
-	for i = 1, AceGUI:GetWidgetCount(Type) do
-		local editbox = _G["AceGUI-3.0EditBox"..i]
-		if editbox and editbox:IsVisible() and editbox:HasFocus() then
-			editbox:Insert(text)
-			return true
-		end
-	end
-end
-
-local function ShowButton(self)
-	if not self.disablebutton then
-		self.button:Show()
-		self.editbox:SetTextInsets(0, 20, 3, 3)
-	end
-end
-
-local function HideButton(self)
-	self.button:Hide()
-	self.editbox:SetTextInsets(0, 0, 3, 3)
-end
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Control_OnEnter(frame)
-	frame.obj:Fire("OnEnter")
-end
-
-local function Control_OnLeave(frame)
-	frame.obj:Fire("OnLeave")
-end
-
-local function Frame_OnShowFocus(frame)
-	frame.obj.editbox:SetFocus()
-	frame:SetScript("OnShow", nil)
-end
-
-local function EditBox_OnEscapePressed(frame)
-	AceGUI:ClearFocus()
-end
-
-local function EditBox_OnEnterPressed(frame)
-	local self = frame.obj
-	local value = frame:GetText()
-	local cancel = self:Fire("OnEnterPressed", value)
-	if not cancel then
-		PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
-		HideButton(self)
-	end
-end
-
-local function EditBox_OnReceiveDrag(frame)
-	local self = frame.obj
-	local type, id, info = GetCursorInfo()
-	local name
-	if type == "item" then
-		name = info
-	elseif type == "spell" then
-		name = GetSpellInfo(id, info)
-	elseif type == "macro" then
-		name = GetMacroInfo(id)
-	end
-	if name then
-		self:SetText(name)
-		self:Fire("OnEnterPressed", name)
-		ClearCursor()
-		HideButton(self)
-		AceGUI:ClearFocus()
-	end
-end
-
-local function EditBox_OnTextChanged(frame)
-	local self = frame.obj
-	local value = frame:GetText()
-	if tostring(value) ~= tostring(self.lasttext) then
-		self:Fire("OnTextChanged", value)
-		self.lasttext = value
-		ShowButton(self)
-	end
-end
-
-local function EditBox_OnFocusGained(frame)
-	AceGUI:SetFocus(frame.obj)
-end
-
-local function Button_OnClick(frame)
-	local editbox = frame.obj.editbox
-	editbox:ClearFocus()
-	EditBox_OnEnterPressed(editbox)
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		-- height is controlled by SetLabel
-		self:SetWidth(200)
-		self:SetDisabled(false)
-		self:SetLabel()
-		self:SetText()
-		self:DisableButton(false)
-		self:SetMaxLetters(0)
-	end,
-
-	["OnRelease"] = function(self)
-		self:ClearFocus()
-	end,
-
-	["SetDisabled"] = function(self, disabled)
-		self.disabled = disabled
-		if disabled then
-			self.editbox:EnableMouse(false)
-			self.editbox:ClearFocus()
-			self.editbox:SetTextColor(0.5,0.5,0.5)
-			self.label:SetTextColor(0.5,0.5,0.5)
-		else
-			self.editbox:EnableMouse(true)
-			self.editbox:SetTextColor(1,1,1)
-			self.label:SetTextColor(1,.82,0)
-		end
-	end,
-
-	["SetText"] = function(self, text)
-		self.lasttext = text or ""
-		self.editbox:SetText(text or "")
-		self.editbox:SetCursorPosition(0)
-		HideButton(self)
-	end,
-
-	["GetText"] = function(self, text)
-		return self.editbox:GetText()
-	end,
-
-	["SetLabel"] = function(self, text)
-		if text and text ~= "" then
-			self.label:SetText(text)
-			self.label:Show()
-			self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,-18)
-			self:SetHeight(44)
-			self.alignoffset = 30
-		else
-			self.label:SetText("")
-			self.label:Hide()
-			self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,0)
-			self:SetHeight(26)
-			self.alignoffset = 12
-		end
-	end,
-
-	["DisableButton"] = function(self, disabled)
-		self.disablebutton = disabled
-		if disabled then
-			HideButton(self)
-		end
-	end,
-
-	["SetMaxLetters"] = function (self, num)
-		self.editbox:SetMaxLetters(num or 0)
-	end,
-
-	["ClearFocus"] = function(self)
-		self.editbox:ClearFocus()
-		self.frame:SetScript("OnShow", nil)
-	end,
-
-	["SetFocus"] = function(self)
-		self.editbox:SetFocus()
-		if not self.frame:IsShown() then
-			self.frame:SetScript("OnShow", Frame_OnShowFocus)
-		end
-	end,
-
-	["HighlightText"] = function(self, from, to)
-		self.editbox:HighlightText(from, to)
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local num  = AceGUI:GetNextWidgetNum(Type)
-	local frame = CreateFrame("Frame", nil, UIParent)
-	frame:Hide()
-
-	local editbox = CreateFrame("EditBox", "AceGUI-3.0EditBox"..num, frame, "InputBoxTemplate")
-	editbox:SetAutoFocus(false)
-	editbox:SetFontObject(ChatFontNormal)
-	editbox:SetScript("OnEnter", Control_OnEnter)
-	editbox:SetScript("OnLeave", Control_OnLeave)
-	editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)
-	editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
-	editbox:SetScript("OnTextChanged", EditBox_OnTextChanged)
-	editbox:SetScript("OnReceiveDrag", EditBox_OnReceiveDrag)
-	editbox:SetScript("OnMouseDown", EditBox_OnReceiveDrag)
-	editbox:SetScript("OnEditFocusGained", EditBox_OnFocusGained)
-	editbox:SetTextInsets(0, 0, 3, 3)
-	editbox:SetMaxLetters(256)
-	editbox:SetPoint("BOTTOMLEFT", 6, 0)
-	editbox:SetPoint("BOTTOMRIGHT")
-	editbox:SetHeight(19)
-
-	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
-	label:SetPoint("TOPLEFT", 0, -2)
-	label:SetPoint("TOPRIGHT", 0, -2)
-	label:SetJustifyH("LEFT")
-	label:SetHeight(18)
-
-	local button = CreateFrame("Button", nil, editbox, "UIPanelButtonTemplate")
-	button:SetWidth(40)
-	button:SetHeight(20)
-	button:SetPoint("RIGHT", -2, 0)
-	button:SetText(OKAY)
-	button:SetScript("OnClick", Button_OnClick)
-	button:Hide()
-
-	local widget = {
-		alignoffset = 30,
-		editbox     = editbox,
-		label       = label,
-		button      = button,
-		frame       = frame,
-		type        = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-	editbox.obj, button.obj = widget, widget
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+EditBox Widget
+-------------------------------------------------------------------------------]]
+local Type, Version = "EditBox", 28
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local tostring, pairs = tostring, pairs
+
+-- WoW APIs
+local PlaySound = PlaySound
+local GetCursorInfo, ClearCursor, GetSpellInfo = GetCursorInfo, ClearCursor, GetSpellInfo
+local CreateFrame, UIParent = CreateFrame, UIParent
+local _G = _G
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+if not AceGUIEditBoxInsertLink then
+	-- upgradeable hook
+	hooksecurefunc("ChatEdit_InsertLink", function(...) return _G.AceGUIEditBoxInsertLink(...) end)
+end
+
+function _G.AceGUIEditBoxInsertLink(text)
+	for i = 1, AceGUI:GetWidgetCount(Type) do
+		local editbox = _G["AceGUI-3.0EditBox"..i]
+		if editbox and editbox:IsVisible() and editbox:HasFocus() then
+			editbox:Insert(text)
+			return true
+		end
+	end
+end
+
+local function ShowButton(self)
+	if not self.disablebutton then
+		self.button:Show()
+		self.editbox:SetTextInsets(0, 20, 3, 3)
+	end
+end
+
+local function HideButton(self)
+	self.button:Hide()
+	self.editbox:SetTextInsets(0, 0, 3, 3)
+end
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Control_OnEnter(frame)
+	frame.obj:Fire("OnEnter")
+end
+
+local function Control_OnLeave(frame)
+	frame.obj:Fire("OnLeave")
+end
+
+local function Frame_OnShowFocus(frame)
+	frame.obj.editbox:SetFocus()
+	frame:SetScript("OnShow", nil)
+end
+
+local function EditBox_OnEscapePressed(frame)
+	AceGUI:ClearFocus()
+end
+
+local function EditBox_OnEnterPressed(frame)
+	local self = frame.obj
+	local value = frame:GetText()
+	local cancel = self:Fire("OnEnterPressed", value)
+	if not cancel then
+		PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
+		HideButton(self)
+	end
+end
+
+local function EditBox_OnReceiveDrag(frame)
+	local self = frame.obj
+	local type, id, info = GetCursorInfo()
+	local name
+	if type == "item" then
+		name = info
+	elseif type == "spell" then
+		name = GetSpellInfo(id, info)
+	elseif type == "macro" then
+		name = GetMacroInfo(id)
+	end
+	if name then
+		self:SetText(name)
+		self:Fire("OnEnterPressed", name)
+		ClearCursor()
+		HideButton(self)
+		AceGUI:ClearFocus()
+	end
+end
+
+local function EditBox_OnTextChanged(frame)
+	local self = frame.obj
+	local value = frame:GetText()
+	if tostring(value) ~= tostring(self.lasttext) then
+		self:Fire("OnTextChanged", value)
+		self.lasttext = value
+		ShowButton(self)
+	end
+end
+
+local function EditBox_OnFocusGained(frame)
+	AceGUI:SetFocus(frame.obj)
+end
+
+local function Button_OnClick(frame)
+	local editbox = frame.obj.editbox
+	editbox:ClearFocus()
+	EditBox_OnEnterPressed(editbox)
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		-- height is controlled by SetLabel
+		self:SetWidth(200)
+		self:SetDisabled(false)
+		self:SetLabel()
+		self:SetText()
+		self:DisableButton(false)
+		self:SetMaxLetters(0)
+	end,
+
+	["OnRelease"] = function(self)
+		self:ClearFocus()
+	end,
+
+	["SetDisabled"] = function(self, disabled)
+		self.disabled = disabled
+		if disabled then
+			self.editbox:EnableMouse(false)
+			self.editbox:ClearFocus()
+			self.editbox:SetTextColor(0.5,0.5,0.5)
+			self.label:SetTextColor(0.5,0.5,0.5)
+		else
+			self.editbox:EnableMouse(true)
+			self.editbox:SetTextColor(1,1,1)
+			self.label:SetTextColor(1,.82,0)
+		end
+	end,
+
+	["SetText"] = function(self, text)
+		self.lasttext = text or ""
+		self.editbox:SetText(text or "")
+		self.editbox:SetCursorPosition(0)
+		HideButton(self)
+	end,
+
+	["GetText"] = function(self, text)
+		return self.editbox:GetText()
+	end,
+
+	["SetLabel"] = function(self, text)
+		if text and text ~= "" then
+			self.label:SetText(text)
+			self.label:Show()
+			self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,-18)
+			self:SetHeight(44)
+			self.alignoffset = 30
+		else
+			self.label:SetText("")
+			self.label:Hide()
+			self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,0)
+			self:SetHeight(26)
+			self.alignoffset = 12
+		end
+	end,
+
+	["DisableButton"] = function(self, disabled)
+		self.disablebutton = disabled
+		if disabled then
+			HideButton(self)
+		end
+	end,
+
+	["SetMaxLetters"] = function (self, num)
+		self.editbox:SetMaxLetters(num or 0)
+	end,
+
+	["ClearFocus"] = function(self)
+		self.editbox:ClearFocus()
+		self.frame:SetScript("OnShow", nil)
+	end,
+
+	["SetFocus"] = function(self)
+		self.editbox:SetFocus()
+		if not self.frame:IsShown() then
+			self.frame:SetScript("OnShow", Frame_OnShowFocus)
+		end
+	end,
+
+	["HighlightText"] = function(self, from, to)
+		self.editbox:HighlightText(from, to)
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local num  = AceGUI:GetNextWidgetNum(Type)
+	local frame = CreateFrame("Frame", nil, UIParent)
+	frame:Hide()
+
+	local editbox = CreateFrame("EditBox", "AceGUI-3.0EditBox"..num, frame, "InputBoxTemplate")
+	editbox:SetAutoFocus(false)
+	editbox:SetFontObject(ChatFontNormal)
+	editbox:SetScript("OnEnter", Control_OnEnter)
+	editbox:SetScript("OnLeave", Control_OnLeave)
+	editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)
+	editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
+	editbox:SetScript("OnTextChanged", EditBox_OnTextChanged)
+	editbox:SetScript("OnReceiveDrag", EditBox_OnReceiveDrag)
+	editbox:SetScript("OnMouseDown", EditBox_OnReceiveDrag)
+	editbox:SetScript("OnEditFocusGained", EditBox_OnFocusGained)
+	editbox:SetTextInsets(0, 0, 3, 3)
+	editbox:SetMaxLetters(256)
+	editbox:SetPoint("BOTTOMLEFT", 6, 0)
+	editbox:SetPoint("BOTTOMRIGHT")
+	editbox:SetHeight(19)
+
+	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
+	label:SetPoint("TOPLEFT", 0, -2)
+	label:SetPoint("TOPRIGHT", 0, -2)
+	label:SetJustifyH("LEFT")
+	label:SetHeight(18)
+
+	local button = CreateFrame("Button", nil, editbox, "UIPanelButtonTemplate")
+	button:SetWidth(40)
+	button:SetHeight(20)
+	button:SetPoint("RIGHT", -2, 0)
+	button:SetText(OKAY)
+	button:SetScript("OnClick", Button_OnClick)
+	button:Hide()
+
+	local widget = {
+		alignoffset = 30,
+		editbox     = editbox,
+		label       = label,
+		button      = button,
+		frame       = frame,
+		type        = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+	editbox.obj, button.obj = widget, widget
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Heading.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Heading.lua
index 670cd4e..862ae88 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Heading.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Heading.lua
@@ -1,78 +1,78 @@
---[[-----------------------------------------------------------------------------
-Heading Widget
--------------------------------------------------------------------------------]]
-local Type, Version = "Heading", 20
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs = pairs
-
--- WoW APIs
-local CreateFrame, UIParent = CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetText()
-		self:SetFullWidth()
-		self:SetHeight(18)
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["SetText"] = function(self, text)
-		self.label:SetText(text or "")
-		if text and text ~= "" then
-			self.left:SetPoint("RIGHT", self.label, "LEFT", -5, 0)
-			self.right:Show()
-		else
-			self.left:SetPoint("RIGHT", -3, 0)
-			self.right:Hide()
-		end
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local frame = CreateFrame("Frame", nil, UIParent)
-	frame:Hide()
-
-	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontNormal")
-	label:SetPoint("TOP")
-	label:SetPoint("BOTTOM")
-	label:SetJustifyH("CENTER")
-
-	local left = frame:CreateTexture(nil, "BACKGROUND")
-	left:SetHeight(8)
-	left:SetPoint("LEFT", 3, 0)
-	left:SetPoint("RIGHT", label, "LEFT", -5, 0)
-	left:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
-	left:SetTexCoord(0.81, 0.94, 0.5, 1)
-
-	local right = frame:CreateTexture(nil, "BACKGROUND")
-	right:SetHeight(8)
-	right:SetPoint("RIGHT", -3, 0)
-	right:SetPoint("LEFT", label, "RIGHT", 5, 0)
-	right:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
-	right:SetTexCoord(0.81, 0.94, 0.5, 1)
-
-	local widget = {
-		label = label,
-		left  = left,
-		right = right,
-		frame = frame,
-		type  = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+Heading Widget
+-------------------------------------------------------------------------------]]
+local Type, Version = "Heading", 20
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs = pairs
+
+-- WoW APIs
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetText()
+		self:SetFullWidth()
+		self:SetHeight(18)
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["SetText"] = function(self, text)
+		self.label:SetText(text or "")
+		if text and text ~= "" then
+			self.left:SetPoint("RIGHT", self.label, "LEFT", -5, 0)
+			self.right:Show()
+		else
+			self.left:SetPoint("RIGHT", -3, 0)
+			self.right:Hide()
+		end
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local frame = CreateFrame("Frame", nil, UIParent)
+	frame:Hide()
+
+	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontNormal")
+	label:SetPoint("TOP")
+	label:SetPoint("BOTTOM")
+	label:SetJustifyH("CENTER")
+
+	local left = frame:CreateTexture(nil, "BACKGROUND")
+	left:SetHeight(8)
+	left:SetPoint("LEFT", 3, 0)
+	left:SetPoint("RIGHT", label, "LEFT", -5, 0)
+	left:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
+	left:SetTexCoord(0.81, 0.94, 0.5, 1)
+
+	local right = frame:CreateTexture(nil, "BACKGROUND")
+	right:SetHeight(8)
+	right:SetPoint("RIGHT", -3, 0)
+	right:SetPoint("LEFT", label, "RIGHT", 5, 0)
+	right:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
+	right:SetTexCoord(0.81, 0.94, 0.5, 1)
+
+	local widget = {
+		label = label,
+		left  = left,
+		right = right,
+		frame = frame,
+		type  = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Icon.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Icon.lua
index 092697e..378e813 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Icon.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Icon.lua
@@ -1,140 +1,140 @@
---[[-----------------------------------------------------------------------------
-Icon Widget
--------------------------------------------------------------------------------]]
-local Type, Version = "Icon", 21
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local select, pairs, print = select, pairs, print
-
--- WoW APIs
-local CreateFrame, UIParent = CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Control_OnEnter(frame)
-	frame.obj:Fire("OnEnter")
-end
-
-local function Control_OnLeave(frame)
-	frame.obj:Fire("OnLeave")
-end
-
-local function Button_OnClick(frame, button)
-	frame.obj:Fire("OnClick", button)
-	AceGUI:ClearFocus()
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetHeight(110)
-		self:SetWidth(110)
-		self:SetLabel()
-		self:SetImage(nil)
-		self:SetImageSize(64, 64)
-		self:SetDisabled(false)
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["SetLabel"] = function(self, text)
-		if text and text ~= "" then
-			self.label:Show()
-			self.label:SetText(text)
-			self:SetHeight(self.image:GetHeight() + 25)
-		else
-			self.label:Hide()
-			self:SetHeight(self.image:GetHeight() + 10)
-		end
-	end,
-
-	["SetImage"] = function(self, path, ...)
-		local image = self.image
-		image:SetTexture(path)
-
-		if image:GetTexture() then
-			local n = select("#", ...)
-			if n == 4 or n == 8 then
-				image:SetTexCoord(...)
-			else
-				image:SetTexCoord(0, 1, 0, 1)
-			end
-		end
-	end,
-
-	["SetImageSize"] = function(self, width, height)
-		self.image:SetWidth(width)
-		self.image:SetHeight(height)
-		--self.frame:SetWidth(width + 30)
-		if self.label:IsShown() then
-			self:SetHeight(height + 25)
-		else
-			self:SetHeight(height + 10)
-		end
-	end,
-
-	["SetDisabled"] = function(self, disabled)
-		self.disabled = disabled
-		if disabled then
-			self.frame:Disable()
-			self.label:SetTextColor(0.5, 0.5, 0.5)
-			self.image:SetVertexColor(0.5, 0.5, 0.5, 0.5)
-		else
-			self.frame:Enable()
-			self.label:SetTextColor(1, 1, 1)
-			self.image:SetVertexColor(1, 1, 1, 1)
-		end
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local frame = CreateFrame("Button", nil, UIParent)
-	frame:Hide()
-
-	frame:EnableMouse(true)
-	frame:SetScript("OnEnter", Control_OnEnter)
-	frame:SetScript("OnLeave", Control_OnLeave)
-	frame:SetScript("OnClick", Button_OnClick)
-
-	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlight")
-	label:SetPoint("BOTTOMLEFT")
-	label:SetPoint("BOTTOMRIGHT")
-	label:SetJustifyH("CENTER")
-	label:SetJustifyV("TOP")
-	label:SetHeight(18)
-
-	local image = frame:CreateTexture(nil, "BACKGROUND")
-	image:SetWidth(64)
-	image:SetHeight(64)
-	image:SetPoint("TOP", 0, -5)
-
-	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
-	highlight:SetAllPoints(image)
-	highlight:SetTexture(136580) -- Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight
-	highlight:SetTexCoord(0, 1, 0.23, 0.77)
-	highlight:SetBlendMode("ADD")
-
-	local widget = {
-		label = label,
-		image = image,
-		frame = frame,
-		type  = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	widget.SetText = function(self, ...) print("AceGUI-3.0-Icon: SetText is deprecated! Use SetLabel instead!"); self:SetLabel(...) end
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+Icon Widget
+-------------------------------------------------------------------------------]]
+local Type, Version = "Icon", 21
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local select, pairs, print = select, pairs, print
+
+-- WoW APIs
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Control_OnEnter(frame)
+	frame.obj:Fire("OnEnter")
+end
+
+local function Control_OnLeave(frame)
+	frame.obj:Fire("OnLeave")
+end
+
+local function Button_OnClick(frame, button)
+	frame.obj:Fire("OnClick", button)
+	AceGUI:ClearFocus()
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetHeight(110)
+		self:SetWidth(110)
+		self:SetLabel()
+		self:SetImage(nil)
+		self:SetImageSize(64, 64)
+		self:SetDisabled(false)
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["SetLabel"] = function(self, text)
+		if text and text ~= "" then
+			self.label:Show()
+			self.label:SetText(text)
+			self:SetHeight(self.image:GetHeight() + 25)
+		else
+			self.label:Hide()
+			self:SetHeight(self.image:GetHeight() + 10)
+		end
+	end,
+
+	["SetImage"] = function(self, path, ...)
+		local image = self.image
+		image:SetTexture(path)
+
+		if image:GetTexture() then
+			local n = select("#", ...)
+			if n == 4 or n == 8 then
+				image:SetTexCoord(...)
+			else
+				image:SetTexCoord(0, 1, 0, 1)
+			end
+		end
+	end,
+
+	["SetImageSize"] = function(self, width, height)
+		self.image:SetWidth(width)
+		self.image:SetHeight(height)
+		--self.frame:SetWidth(width + 30)
+		if self.label:IsShown() then
+			self:SetHeight(height + 25)
+		else
+			self:SetHeight(height + 10)
+		end
+	end,
+
+	["SetDisabled"] = function(self, disabled)
+		self.disabled = disabled
+		if disabled then
+			self.frame:Disable()
+			self.label:SetTextColor(0.5, 0.5, 0.5)
+			self.image:SetVertexColor(0.5, 0.5, 0.5, 0.5)
+		else
+			self.frame:Enable()
+			self.label:SetTextColor(1, 1, 1)
+			self.image:SetVertexColor(1, 1, 1, 1)
+		end
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local frame = CreateFrame("Button", nil, UIParent)
+	frame:Hide()
+
+	frame:EnableMouse(true)
+	frame:SetScript("OnEnter", Control_OnEnter)
+	frame:SetScript("OnLeave", Control_OnLeave)
+	frame:SetScript("OnClick", Button_OnClick)
+
+	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlight")
+	label:SetPoint("BOTTOMLEFT")
+	label:SetPoint("BOTTOMRIGHT")
+	label:SetJustifyH("CENTER")
+	label:SetJustifyV("TOP")
+	label:SetHeight(18)
+
+	local image = frame:CreateTexture(nil, "BACKGROUND")
+	image:SetWidth(64)
+	image:SetHeight(64)
+	image:SetPoint("TOP", 0, -5)
+
+	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
+	highlight:SetAllPoints(image)
+	highlight:SetTexture(136580) -- Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight
+	highlight:SetTexCoord(0, 1, 0.23, 0.77)
+	highlight:SetBlendMode("ADD")
+
+	local widget = {
+		label = label,
+		image = image,
+		frame = frame,
+		type  = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	widget.SetText = function(self, ...) print("AceGUI-3.0-Icon: SetText is deprecated! Use SetLabel instead!"); self:SetLabel(...) end
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-InteractiveLabel.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-InteractiveLabel.lua
index 76a2cf9..255dd97 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-InteractiveLabel.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-InteractiveLabel.lua
@@ -1,94 +1,94 @@
---[[-----------------------------------------------------------------------------
-InteractiveLabel Widget
--------------------------------------------------------------------------------]]
-local Type, Version = "InteractiveLabel", 21
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local select, pairs = select, pairs
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Control_OnEnter(frame)
-	frame.obj:Fire("OnEnter")
-end
-
-local function Control_OnLeave(frame)
-	frame.obj:Fire("OnLeave")
-end
-
-local function Label_OnClick(frame, button)
-	frame.obj:Fire("OnClick", button)
-	AceGUI:ClearFocus()
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:LabelOnAcquire()
-		self:SetHighlight()
-		self:SetHighlightTexCoord()
-		self:SetDisabled(false)
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["SetHighlight"] = function(self, ...)
-		self.highlight:SetTexture(...)
-	end,
-
-	["SetHighlightTexCoord"] = function(self, ...)
-		local c = select("#", ...)
-		if c == 4 or c == 8 then
-			self.highlight:SetTexCoord(...)
-		else
-			self.highlight:SetTexCoord(0, 1, 0, 1)
-		end
-	end,
-
-	["SetDisabled"] = function(self,disabled)
-		self.disabled = disabled
-		if disabled then
-			self.frame:EnableMouse(false)
-			self.label:SetTextColor(0.5, 0.5, 0.5)
-		else
-			self.frame:EnableMouse(true)
-			self.label:SetTextColor(1, 1, 1)
-		end
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	-- create a Label type that we will hijack
-	local label = AceGUI:Create("Label")
-
-	local frame = label.frame
-	frame:EnableMouse(true)
-	frame:SetScript("OnEnter", Control_OnEnter)
-	frame:SetScript("OnLeave", Control_OnLeave)
-	frame:SetScript("OnMouseDown", Label_OnClick)
-
-	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
-	highlight:SetTexture(nil)
-	highlight:SetAllPoints()
-	highlight:SetBlendMode("ADD")
-
-	label.highlight = highlight
-	label.type = Type
-	label.LabelOnAcquire = label.OnAcquire
-	for method, func in pairs(methods) do
-		label[method] = func
-	end
-
-	return label
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
-
+--[[-----------------------------------------------------------------------------
+InteractiveLabel Widget
+-------------------------------------------------------------------------------]]
+local Type, Version = "InteractiveLabel", 21
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local select, pairs = select, pairs
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Control_OnEnter(frame)
+	frame.obj:Fire("OnEnter")
+end
+
+local function Control_OnLeave(frame)
+	frame.obj:Fire("OnLeave")
+end
+
+local function Label_OnClick(frame, button)
+	frame.obj:Fire("OnClick", button)
+	AceGUI:ClearFocus()
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:LabelOnAcquire()
+		self:SetHighlight()
+		self:SetHighlightTexCoord()
+		self:SetDisabled(false)
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["SetHighlight"] = function(self, ...)
+		self.highlight:SetTexture(...)
+	end,
+
+	["SetHighlightTexCoord"] = function(self, ...)
+		local c = select("#", ...)
+		if c == 4 or c == 8 then
+			self.highlight:SetTexCoord(...)
+		else
+			self.highlight:SetTexCoord(0, 1, 0, 1)
+		end
+	end,
+
+	["SetDisabled"] = function(self,disabled)
+		self.disabled = disabled
+		if disabled then
+			self.frame:EnableMouse(false)
+			self.label:SetTextColor(0.5, 0.5, 0.5)
+		else
+			self.frame:EnableMouse(true)
+			self.label:SetTextColor(1, 1, 1)
+		end
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	-- create a Label type that we will hijack
+	local label = AceGUI:Create("Label")
+
+	local frame = label.frame
+	frame:EnableMouse(true)
+	frame:SetScript("OnEnter", Control_OnEnter)
+	frame:SetScript("OnLeave", Control_OnLeave)
+	frame:SetScript("OnMouseDown", Label_OnClick)
+
+	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
+	highlight:SetTexture(nil)
+	highlight:SetAllPoints()
+	highlight:SetBlendMode("ADD")
+
+	label.highlight = highlight
+	label.type = Type
+	label.LabelOnAcquire = label.OnAcquire
+	for method, func in pairs(methods) do
+		label[method] = func
+	end
+
+	return label
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
+
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Keybinding.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Keybinding.lua
index 96f7e5b..0c779dc 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Keybinding.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Keybinding.lua
@@ -1,245 +1,245 @@
---[[-----------------------------------------------------------------------------
-Keybinding Widget
-Set Keybindings in the Config UI.
--------------------------------------------------------------------------------]]
-local Type, Version = "Keybinding", 26
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs = pairs
-
--- WoW APIs
-local IsShiftKeyDown, IsControlKeyDown, IsAltKeyDown = IsShiftKeyDown, IsControlKeyDown, IsAltKeyDown
-local CreateFrame, UIParent = CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-
-local function Control_OnEnter(frame)
-	frame.obj:Fire("OnEnter")
-end
-
-local function Control_OnLeave(frame)
-	frame.obj:Fire("OnLeave")
-end
-
-local function Keybinding_OnClick(frame, button)
-	if button == "LeftButton" or button == "RightButton" then
-		local self = frame.obj
-		if self.waitingForKey then
-			frame:EnableKeyboard(false)
-			frame:EnableMouseWheel(false)
-			self.msgframe:Hide()
-			frame:UnlockHighlight()
-			self.waitingForKey = nil
-		else
-			frame:EnableKeyboard(true)
-			frame:EnableMouseWheel(true)
-			self.msgframe:Show()
-			frame:LockHighlight()
-			self.waitingForKey = true
-		end
-	end
-	AceGUI:ClearFocus()
-end
-
-local ignoreKeys = {
-	["BUTTON1"] = true, ["BUTTON2"] = true,
-	["UNKNOWN"] = true,
-	["LSHIFT"] = true, ["LCTRL"] = true, ["LALT"] = true,
-	["RSHIFT"] = true, ["RCTRL"] = true, ["RALT"] = true,
-}
-local function Keybinding_OnKeyDown(frame, key)
-	local self = frame.obj
-	if self.waitingForKey then
-		local keyPressed = key
-		if keyPressed == "ESCAPE" then
-			keyPressed = ""
-		else
-			if ignoreKeys[keyPressed] then return end
-			if IsShiftKeyDown() then
-				keyPressed = "SHIFT-"..keyPressed
-			end
-			if IsControlKeyDown() then
-				keyPressed = "CTRL-"..keyPressed
-			end
-			if IsAltKeyDown() then
-				keyPressed = "ALT-"..keyPressed
-			end
-		end
-
-		frame:EnableKeyboard(false)
-		frame:EnableMouseWheel(false)
-		self.msgframe:Hide()
-		frame:UnlockHighlight()
-		self.waitingForKey = nil
-
-		if not self.disabled then
-			self:SetKey(keyPressed)
-			self:Fire("OnKeyChanged", keyPressed)
-		end
-	end
-end
-
-local function Keybinding_OnMouseDown(frame, button)
-	if button == "LeftButton" or button == "RightButton" then
-		return
-	elseif button == "MiddleButton" then
-		button = "BUTTON3"
-	elseif button == "Button4" then
-		button = "BUTTON4"
-	elseif button == "Button5" then
-		button = "BUTTON5"
-	end
-	Keybinding_OnKeyDown(frame, button)
-end
-
-local function Keybinding_OnMouseWheel(frame, direction)
-	local button
-	if direction >= 0 then
-		button = "MOUSEWHEELUP"
-	else
-		button = "MOUSEWHEELDOWN"
-	end
-	Keybinding_OnKeyDown(frame, button)
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetWidth(200)
-		self:SetLabel("")
-		self:SetKey("")
-		self.waitingForKey = nil
-		self.msgframe:Hide()
-		self:SetDisabled(false)
-		self.button:EnableKeyboard(false)
-		self.button:EnableMouseWheel(false)
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["SetDisabled"] = function(self, disabled)
-		self.disabled = disabled
-		if disabled then
-			self.button:Disable()
-			self.label:SetTextColor(0.5,0.5,0.5)
-		else
-			self.button:Enable()
-			self.label:SetTextColor(1,1,1)
-		end
-	end,
-
-	["SetKey"] = function(self, key)
-		if (key or "") == "" then
-			self.button:SetText(NOT_BOUND)
-			self.button:SetNormalFontObject("GameFontNormal")
-		else
-			self.button:SetText(key)
-			self.button:SetNormalFontObject("GameFontHighlight")
-		end
-	end,
-
-	["GetKey"] = function(self)
-		local key = self.button:GetText()
-		if key == NOT_BOUND then
-			key = nil
-		end
-		return key
-	end,
-
-	["SetLabel"] = function(self, label)
-		self.label:SetText(label or "")
-		if (label or "") == "" then
-			self.alignoffset = nil
-			self:SetHeight(24)
-		else
-			self.alignoffset = 30
-			self:SetHeight(44)
-		end
-	end,
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-
-local ControlBackdrop  = {
-	bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
-	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
-	tile = true, tileSize = 16, edgeSize = 16,
-	insets = { left = 3, right = 3, top = 3, bottom = 3 }
-}
-
-local function keybindingMsgFixWidth(frame)
-	frame:SetWidth(frame.msg:GetWidth() + 10)
-	frame:SetScript("OnUpdate", nil)
-end
-
-local function Constructor()
-	local name = "AceGUI30KeybindingButton" .. AceGUI:GetNextWidgetNum(Type)
-
-	local frame = CreateFrame("Frame", nil, UIParent)
-	local button = CreateFrame("Button", name, frame, "UIPanelButtonTemplate")
-
-	button:EnableMouse(true)
-	button:EnableMouseWheel(false)
-	button:RegisterForClicks("AnyDown")
-	button:SetScript("OnEnter", Control_OnEnter)
-	button:SetScript("OnLeave", Control_OnLeave)
-	button:SetScript("OnClick", Keybinding_OnClick)
-	button:SetScript("OnKeyDown", Keybinding_OnKeyDown)
-	button:SetScript("OnMouseDown", Keybinding_OnMouseDown)
-	button:SetScript("OnMouseWheel", Keybinding_OnMouseWheel)
-	button:SetPoint("BOTTOMLEFT")
-	button:SetPoint("BOTTOMRIGHT")
-	button:SetHeight(24)
-	button:EnableKeyboard(false)
-
-	local text = button:GetFontString()
-	text:SetPoint("LEFT", 7, 0)
-	text:SetPoint("RIGHT", -7, 0)
-
-	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
-	label:SetPoint("TOPLEFT")
-	label:SetPoint("TOPRIGHT")
-	label:SetJustifyH("CENTER")
-	label:SetHeight(18)
-
-	local msgframe = CreateFrame("Frame", nil, UIParent, "BackdropTemplate")
-	msgframe:SetHeight(30)
-	msgframe:SetBackdrop(ControlBackdrop)
-	msgframe:SetBackdropColor(0,0,0)
-	msgframe:SetFrameStrata("FULLSCREEN_DIALOG")
-	msgframe:SetFrameLevel(1000)
-	msgframe:SetToplevel(true)
-
-	local msg = msgframe:CreateFontString(nil, "OVERLAY", "GameFontNormal")
-	msg:SetText("Press a key to bind, ESC to clear the binding or click the button again to cancel.")
-	msgframe.msg = msg
-	msg:SetPoint("TOPLEFT", 5, -5)
-	msgframe:SetScript("OnUpdate", keybindingMsgFixWidth)
-	msgframe:SetPoint("BOTTOM", button, "TOP")
-	msgframe:Hide()
-
-	local widget = {
-		button      = button,
-		label       = label,
-		msgframe    = msgframe,
-		frame       = frame,
-		alignoffset = 30,
-		type        = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-	button.obj = widget
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+Keybinding Widget
+Set Keybindings in the Config UI.
+-------------------------------------------------------------------------------]]
+local Type, Version = "Keybinding", 26
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs = pairs
+
+-- WoW APIs
+local IsShiftKeyDown, IsControlKeyDown, IsAltKeyDown = IsShiftKeyDown, IsControlKeyDown, IsAltKeyDown
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+
+local function Control_OnEnter(frame)
+	frame.obj:Fire("OnEnter")
+end
+
+local function Control_OnLeave(frame)
+	frame.obj:Fire("OnLeave")
+end
+
+local function Keybinding_OnClick(frame, button)
+	if button == "LeftButton" or button == "RightButton" then
+		local self = frame.obj
+		if self.waitingForKey then
+			frame:EnableKeyboard(false)
+			frame:EnableMouseWheel(false)
+			self.msgframe:Hide()
+			frame:UnlockHighlight()
+			self.waitingForKey = nil
+		else
+			frame:EnableKeyboard(true)
+			frame:EnableMouseWheel(true)
+			self.msgframe:Show()
+			frame:LockHighlight()
+			self.waitingForKey = true
+		end
+	end
+	AceGUI:ClearFocus()
+end
+
+local ignoreKeys = {
+	["BUTTON1"] = true, ["BUTTON2"] = true,
+	["UNKNOWN"] = true,
+	["LSHIFT"] = true, ["LCTRL"] = true, ["LALT"] = true,
+	["RSHIFT"] = true, ["RCTRL"] = true, ["RALT"] = true,
+}
+local function Keybinding_OnKeyDown(frame, key)
+	local self = frame.obj
+	if self.waitingForKey then
+		local keyPressed = key
+		if keyPressed == "ESCAPE" then
+			keyPressed = ""
+		else
+			if ignoreKeys[keyPressed] then return end
+			if IsShiftKeyDown() then
+				keyPressed = "SHIFT-"..keyPressed
+			end
+			if IsControlKeyDown() then
+				keyPressed = "CTRL-"..keyPressed
+			end
+			if IsAltKeyDown() then
+				keyPressed = "ALT-"..keyPressed
+			end
+		end
+
+		frame:EnableKeyboard(false)
+		frame:EnableMouseWheel(false)
+		self.msgframe:Hide()
+		frame:UnlockHighlight()
+		self.waitingForKey = nil
+
+		if not self.disabled then
+			self:SetKey(keyPressed)
+			self:Fire("OnKeyChanged", keyPressed)
+		end
+	end
+end
+
+local function Keybinding_OnMouseDown(frame, button)
+	if button == "LeftButton" or button == "RightButton" then
+		return
+	elseif button == "MiddleButton" then
+		button = "BUTTON3"
+	elseif button == "Button4" then
+		button = "BUTTON4"
+	elseif button == "Button5" then
+		button = "BUTTON5"
+	end
+	Keybinding_OnKeyDown(frame, button)
+end
+
+local function Keybinding_OnMouseWheel(frame, direction)
+	local button
+	if direction >= 0 then
+		button = "MOUSEWHEELUP"
+	else
+		button = "MOUSEWHEELDOWN"
+	end
+	Keybinding_OnKeyDown(frame, button)
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetWidth(200)
+		self:SetLabel("")
+		self:SetKey("")
+		self.waitingForKey = nil
+		self.msgframe:Hide()
+		self:SetDisabled(false)
+		self.button:EnableKeyboard(false)
+		self.button:EnableMouseWheel(false)
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["SetDisabled"] = function(self, disabled)
+		self.disabled = disabled
+		if disabled then
+			self.button:Disable()
+			self.label:SetTextColor(0.5,0.5,0.5)
+		else
+			self.button:Enable()
+			self.label:SetTextColor(1,1,1)
+		end
+	end,
+
+	["SetKey"] = function(self, key)
+		if (key or "") == "" then
+			self.button:SetText(NOT_BOUND)
+			self.button:SetNormalFontObject("GameFontNormal")
+		else
+			self.button:SetText(key)
+			self.button:SetNormalFontObject("GameFontHighlight")
+		end
+	end,
+
+	["GetKey"] = function(self)
+		local key = self.button:GetText()
+		if key == NOT_BOUND then
+			key = nil
+		end
+		return key
+	end,
+
+	["SetLabel"] = function(self, label)
+		self.label:SetText(label or "")
+		if (label or "") == "" then
+			self.alignoffset = nil
+			self:SetHeight(24)
+		else
+			self.alignoffset = 30
+			self:SetHeight(44)
+		end
+	end,
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+
+local ControlBackdrop  = {
+	bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
+	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
+	tile = true, tileSize = 16, edgeSize = 16,
+	insets = { left = 3, right = 3, top = 3, bottom = 3 }
+}
+
+local function keybindingMsgFixWidth(frame)
+	frame:SetWidth(frame.msg:GetWidth() + 10)
+	frame:SetScript("OnUpdate", nil)
+end
+
+local function Constructor()
+	local name = "AceGUI30KeybindingButton" .. AceGUI:GetNextWidgetNum(Type)
+
+	local frame = CreateFrame("Frame", nil, UIParent)
+	local button = CreateFrame("Button", name, frame, "UIPanelButtonTemplate")
+
+	button:EnableMouse(true)
+	button:EnableMouseWheel(false)
+	button:RegisterForClicks("AnyDown")
+	button:SetScript("OnEnter", Control_OnEnter)
+	button:SetScript("OnLeave", Control_OnLeave)
+	button:SetScript("OnClick", Keybinding_OnClick)
+	button:SetScript("OnKeyDown", Keybinding_OnKeyDown)
+	button:SetScript("OnMouseDown", Keybinding_OnMouseDown)
+	button:SetScript("OnMouseWheel", Keybinding_OnMouseWheel)
+	button:SetPoint("BOTTOMLEFT")
+	button:SetPoint("BOTTOMRIGHT")
+	button:SetHeight(24)
+	button:EnableKeyboard(false)
+
+	local text = button:GetFontString()
+	text:SetPoint("LEFT", 7, 0)
+	text:SetPoint("RIGHT", -7, 0)
+
+	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
+	label:SetPoint("TOPLEFT")
+	label:SetPoint("TOPRIGHT")
+	label:SetJustifyH("CENTER")
+	label:SetHeight(18)
+
+	local msgframe = CreateFrame("Frame", nil, UIParent, "BackdropTemplate")
+	msgframe:SetHeight(30)
+	msgframe:SetBackdrop(ControlBackdrop)
+	msgframe:SetBackdropColor(0,0,0)
+	msgframe:SetFrameStrata("FULLSCREEN_DIALOG")
+	msgframe:SetFrameLevel(1000)
+	msgframe:SetToplevel(true)
+
+	local msg = msgframe:CreateFontString(nil, "OVERLAY", "GameFontNormal")
+	msg:SetText("Press a key to bind, ESC to clear the binding or click the button again to cancel.")
+	msgframe.msg = msg
+	msg:SetPoint("TOPLEFT", 5, -5)
+	msgframe:SetScript("OnUpdate", keybindingMsgFixWidth)
+	msgframe:SetPoint("BOTTOM", button, "TOP")
+	msgframe:Hide()
+
+	local widget = {
+		button      = button,
+		label       = label,
+		msgframe    = msgframe,
+		frame       = frame,
+		alignoffset = 30,
+		type        = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+	button.obj = widget
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Label.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Label.lua
index 6bbcf3b..d0841ef 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Label.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Label.lua
@@ -1,179 +1,179 @@
---[[-----------------------------------------------------------------------------
-Label Widget
-Displays text and optionally an icon.
--------------------------------------------------------------------------------]]
-local Type, Version = "Label", 28
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local max, select, pairs = math.max, select, pairs
-
--- WoW APIs
-local CreateFrame, UIParent = CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-
-local function UpdateImageAnchor(self)
-	if self.resizing then return end
-	local frame = self.frame
-	local width = frame.width or frame:GetWidth() or 0
-	local image = self.image
-	local label = self.label
-	local height
-
-	label:ClearAllPoints()
-	image:ClearAllPoints()
-
-	if self.imageshown then
-		local imagewidth = image:GetWidth()
-		if (width - imagewidth) < 200 or (label:GetText() or "") == "" then
-			-- image goes on top centered when less than 200 width for the text, or if there is no text
-			image:SetPoint("TOP")
-			label:SetPoint("TOP", image, "BOTTOM")
-			label:SetPoint("LEFT")
-			label:SetWidth(width)
-			height = image:GetHeight() + label:GetStringHeight()
-		else
-			-- image on the left
-			image:SetPoint("TOPLEFT")
-			if image:GetHeight() > label:GetStringHeight() then
-				label:SetPoint("LEFT", image, "RIGHT", 4, 0)
-			else
-				label:SetPoint("TOPLEFT", image, "TOPRIGHT", 4, 0)
-			end
-			label:SetWidth(width - imagewidth - 4)
-			height = max(image:GetHeight(), label:GetStringHeight())
-		end
-	else
-		-- no image shown
-		label:SetPoint("TOPLEFT")
-		label:SetWidth(width)
-		height = label:GetStringHeight()
-	end
-
-	-- avoid zero-height labels, since they can used as spacers
-	if not height or height == 0 then
-		height = 1
-	end
-
-	self.resizing = true
-	frame:SetHeight(height)
-	frame.height = height
-	self.resizing = nil
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		-- set the flag to stop constant size updates
-		self.resizing = true
-		-- height is set dynamically by the text and image size
-		self:SetWidth(200)
-		self:SetText()
-		self:SetImage(nil)
-		self:SetImageSize(16, 16)
-		self:SetColor()
-		self:SetFontObject()
-		self:SetJustifyH("LEFT")
-		self:SetJustifyV("TOP")
-
-		-- reset the flag
-		self.resizing = nil
-		-- run the update explicitly
-		UpdateImageAnchor(self)
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["OnWidthSet"] = function(self, width)
-		UpdateImageAnchor(self)
-	end,
-
-	["SetText"] = function(self, text)
-		self.label:SetText(text)
-		UpdateImageAnchor(self)
-	end,
-
-	["SetColor"] = function(self, r, g, b)
-		if not (r and g and b) then
-			r, g, b = 1, 1, 1
-		end
-		self.label:SetVertexColor(r, g, b)
-	end,
-
-	["SetImage"] = function(self, path, ...)
-		local image = self.image
-		image:SetTexture(path)
-
-		if image:GetTexture() then
-			self.imageshown = true
-			local n = select("#", ...)
-			if n == 4 or n == 8 then
-				image:SetTexCoord(...)
-			else
-				image:SetTexCoord(0, 1, 0, 1)
-			end
-		else
-			self.imageshown = nil
-		end
-		UpdateImageAnchor(self)
-	end,
-
-	["SetFont"] = function(self, font, height, flags)
-		if not self.fontObject then
-			self.fontObject = CreateFont("AceGUI30LabelFont" .. AceGUI:GetNextWidgetNum(Type))
-		end
-		self.fontObject:SetFont(font, height, flags)
-		self:SetFontObject(self.fontObject)
-	end,
-
-	["SetFontObject"] = function(self, font)
-		self.label:SetFontObject(font or GameFontHighlightSmall)
-		UpdateImageAnchor(self)
-	end,
-
-	["SetImageSize"] = function(self, width, height)
-		self.image:SetWidth(width)
-		self.image:SetHeight(height)
-		UpdateImageAnchor(self)
-	end,
-
-	["SetJustifyH"] = function(self, justifyH)
-		self.label:SetJustifyH(justifyH)
-	end,
-
-	["SetJustifyV"] = function(self, justifyV)
-		self.label:SetJustifyV(justifyV)
-	end,
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local function Constructor()
-	local frame = CreateFrame("Frame", nil, UIParent)
-	frame:Hide()
-
-	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlightSmall")
-	local image = frame:CreateTexture(nil, "BACKGROUND")
-
-	-- create widget
-	local widget = {
-		label = label,
-		image = image,
-		frame = frame,
-		type  = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+--[[-----------------------------------------------------------------------------
+Label Widget
+Displays text and optionally an icon.
+-------------------------------------------------------------------------------]]
+local Type, Version = "Label", 28
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local max, select, pairs = math.max, select, pairs
+
+-- WoW APIs
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+
+local function UpdateImageAnchor(self)
+	if self.resizing then return end
+	local frame = self.frame
+	local width = frame.width or frame:GetWidth() or 0
+	local image = self.image
+	local label = self.label
+	local height
+
+	label:ClearAllPoints()
+	image:ClearAllPoints()
+
+	if self.imageshown then
+		local imagewidth = image:GetWidth()
+		if (width - imagewidth) < 200 or (label:GetText() or "") == "" then
+			-- image goes on top centered when less than 200 width for the text, or if there is no text
+			image:SetPoint("TOP")
+			label:SetPoint("TOP", image, "BOTTOM")
+			label:SetPoint("LEFT")
+			label:SetWidth(width)
+			height = image:GetHeight() + label:GetStringHeight()
+		else
+			-- image on the left
+			image:SetPoint("TOPLEFT")
+			if image:GetHeight() > label:GetStringHeight() then
+				label:SetPoint("LEFT", image, "RIGHT", 4, 0)
+			else
+				label:SetPoint("TOPLEFT", image, "TOPRIGHT", 4, 0)
+			end
+			label:SetWidth(width - imagewidth - 4)
+			height = max(image:GetHeight(), label:GetStringHeight())
+		end
+	else
+		-- no image shown
+		label:SetPoint("TOPLEFT")
+		label:SetWidth(width)
+		height = label:GetStringHeight()
+	end
+
+	-- avoid zero-height labels, since they can used as spacers
+	if not height or height == 0 then
+		height = 1
+	end
+
+	self.resizing = true
+	frame:SetHeight(height)
+	frame.height = height
+	self.resizing = nil
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		-- set the flag to stop constant size updates
+		self.resizing = true
+		-- height is set dynamically by the text and image size
+		self:SetWidth(200)
+		self:SetText()
+		self:SetImage(nil)
+		self:SetImageSize(16, 16)
+		self:SetColor()
+		self:SetFontObject()
+		self:SetJustifyH("LEFT")
+		self:SetJustifyV("TOP")
+
+		-- reset the flag
+		self.resizing = nil
+		-- run the update explicitly
+		UpdateImageAnchor(self)
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["OnWidthSet"] = function(self, width)
+		UpdateImageAnchor(self)
+	end,
+
+	["SetText"] = function(self, text)
+		self.label:SetText(text)
+		UpdateImageAnchor(self)
+	end,
+
+	["SetColor"] = function(self, r, g, b)
+		if not (r and g and b) then
+			r, g, b = 1, 1, 1
+		end
+		self.label:SetVertexColor(r, g, b)
+	end,
+
+	["SetImage"] = function(self, path, ...)
+		local image = self.image
+		image:SetTexture(path)
+
+		if image:GetTexture() then
+			self.imageshown = true
+			local n = select("#", ...)
+			if n == 4 or n == 8 then
+				image:SetTexCoord(...)
+			else
+				image:SetTexCoord(0, 1, 0, 1)
+			end
+		else
+			self.imageshown = nil
+		end
+		UpdateImageAnchor(self)
+	end,
+
+	["SetFont"] = function(self, font, height, flags)
+		if not self.fontObject then
+			self.fontObject = CreateFont("AceGUI30LabelFont" .. AceGUI:GetNextWidgetNum(Type))
+		end
+		self.fontObject:SetFont(font, height, flags)
+		self:SetFontObject(self.fontObject)
+	end,
+
+	["SetFontObject"] = function(self, font)
+		self.label:SetFontObject(font or GameFontHighlightSmall)
+		UpdateImageAnchor(self)
+	end,
+
+	["SetImageSize"] = function(self, width, height)
+		self.image:SetWidth(width)
+		self.image:SetHeight(height)
+		UpdateImageAnchor(self)
+	end,
+
+	["SetJustifyH"] = function(self, justifyH)
+		self.label:SetJustifyH(justifyH)
+	end,
+
+	["SetJustifyV"] = function(self, justifyV)
+		self.label:SetJustifyV(justifyV)
+	end,
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local function Constructor()
+	local frame = CreateFrame("Frame", nil, UIParent)
+	frame:Hide()
+
+	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlightSmall")
+	local image = frame:CreateTexture(nil, "BACKGROUND")
+
+	-- create widget
+	local widget = {
+		label = label,
+		image = image,
+		frame = frame,
+		type  = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-MultiLineEditBox.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-MultiLineEditBox.lua
index c33a986..bacb2be 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-MultiLineEditBox.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-MultiLineEditBox.lua
@@ -1,369 +1,369 @@
-local Type, Version = "MultiLineEditBox", 32
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local pairs = pairs
-
--- WoW APIs
-local GetCursorInfo, GetSpellInfo, ClearCursor = GetCursorInfo, GetSpellInfo, ClearCursor
-local CreateFrame, UIParent = CreateFrame, UIParent
-local _G = _G
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-
-if not AceGUIMultiLineEditBoxInsertLink then
-	-- upgradeable hook
-	hooksecurefunc("ChatEdit_InsertLink", function(...) return _G.AceGUIMultiLineEditBoxInsertLink(...) end)
-end
-
-function _G.AceGUIMultiLineEditBoxInsertLink(text)
-	for i = 1, AceGUI:GetWidgetCount(Type) do
-		local editbox = _G[("MultiLineEditBox%uEdit"):format(i)]
-		if editbox and editbox:IsVisible() and editbox:HasFocus() then
-			editbox:Insert(text)
-			return true
-		end
-	end
-end
-
-
-local function Layout(self)
-	self:SetHeight(self.numlines * 14 + (self.disablebutton and 19 or 41) + self.labelHeight)
-
-	if self.labelHeight == 0 then
-		self.scrollBar:SetPoint("TOP", self.frame, "TOP", 0, -23)
-	else
-		self.scrollBar:SetPoint("TOP", self.label, "BOTTOM", 0, -19)
-	end
-
-	if self.disablebutton then
-		self.scrollBar:SetPoint("BOTTOM", self.frame, "BOTTOM", 0, 21)
-		self.scrollBG:SetPoint("BOTTOMLEFT", 0, 4)
-	else
-		self.scrollBar:SetPoint("BOTTOM", self.button, "TOP", 0, 18)
-		self.scrollBG:SetPoint("BOTTOMLEFT", self.button, "TOPLEFT")
-	end
-end
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function OnClick(self)                                                     -- Button
-	self = self.obj
-	self.editBox:ClearFocus()
-	if not self:Fire("OnEnterPressed", self.editBox:GetText()) then
-		self.button:Disable()
-	end
-end
-
-local function OnCursorChanged(self, _, y, _, cursorHeight)                      -- EditBox
-	self, y = self.obj.scrollFrame, -y
-	local offset = self:GetVerticalScroll()
-	if y < offset then
-		self:SetVerticalScroll(y)
-	else
-		y = y + cursorHeight - self:GetHeight()
-		if y > offset then
-			self:SetVerticalScroll(y)
-		end
-	end
-end
-
-local function OnEditFocusLost(self)                                             -- EditBox
-	self:HighlightText(0, 0)
-	self.obj:Fire("OnEditFocusLost")
-end
-
-local function OnEnter(self)                                                     -- EditBox / ScrollFrame
-	self = self.obj
-	if not self.entered then
-		self.entered = true
-		self:Fire("OnEnter")
-	end
-end
-
-local function OnLeave(self)                                                     -- EditBox / ScrollFrame
-	self = self.obj
-	if self.entered then
-		self.entered = nil
-		self:Fire("OnLeave")
-	end
-end
-
-local function OnMouseUp(self)                                                   -- ScrollFrame
-	self = self.obj.editBox
-	self:SetFocus()
-	self:SetCursorPosition(self:GetNumLetters())
-end
-
-local function OnReceiveDrag(self)                                               -- EditBox / ScrollFrame
-	local type, id, info = GetCursorInfo()
-	if type == "spell" then
-		info = GetSpellInfo(id, info)
-	elseif type ~= "item" then
-		return
-	end
-	ClearCursor()
-	self = self.obj
-	local editBox = self.editBox
-	if not editBox:HasFocus() then
-		editBox:SetFocus()
-		editBox:SetCursorPosition(editBox:GetNumLetters())
-	end
-	editBox:Insert(info)
-	self.button:Enable()
-end
-
-local function OnSizeChanged(self, width, height)                                -- ScrollFrame
-	self.obj.editBox:SetWidth(width)
-end
-
-local function OnTextChanged(self, userInput)                                    -- EditBox
-	if userInput then
-		self = self.obj
-		self:Fire("OnTextChanged", self.editBox:GetText())
-		self.button:Enable()
-	end
-end
-
-local function OnTextSet(self)                                                   -- EditBox
-	self:HighlightText(0, 0)
-	self:SetCursorPosition(self:GetNumLetters())
-	self:SetCursorPosition(0)
-	self.obj.button:Disable()
-end
-
-local function OnVerticalScroll(self, offset)                                    -- ScrollFrame
-	local editBox = self.obj.editBox
-	editBox:SetHitRectInsets(0, 0, offset, editBox:GetHeight() - offset - self:GetHeight())
-end
-
-local function OnScrollRangeChanged(self, xrange, yrange)
-	if yrange == 0 then
-		self.obj.editBox:SetHitRectInsets(0, 0, 0, 0)
-	else
-		OnVerticalScroll(self, self:GetVerticalScroll())
-	end
-end
-
-local function OnShowFocus(frame)
-	frame.obj.editBox:SetFocus()
-	frame:SetScript("OnShow", nil)
-end
-
-local function OnEditFocusGained(frame)
-	AceGUI:SetFocus(frame.obj)
-	frame.obj:Fire("OnEditFocusGained")
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self.editBox:SetText("")
-		self:SetDisabled(false)
-		self:SetWidth(200)
-		self:DisableButton(false)
-		self:SetNumLines()
-		self.entered = nil
-		self:SetMaxLetters(0)
-	end,
-
-	["OnRelease"] = function(self)
-		self:ClearFocus()
-	end,
-
-	["SetDisabled"] = function(self, disabled)
-		local editBox = self.editBox
-		if disabled then
-			editBox:ClearFocus()
-			editBox:EnableMouse(false)
-			editBox:SetTextColor(0.5, 0.5, 0.5)
-			self.label:SetTextColor(0.5, 0.5, 0.5)
-			self.scrollFrame:EnableMouse(false)
-			self.button:Disable()
-		else
-			editBox:EnableMouse(true)
-			editBox:SetTextColor(1, 1, 1)
-			self.label:SetTextColor(1, 0.82, 0)
-			self.scrollFrame:EnableMouse(true)
-		end
-	end,
-
-	["SetLabel"] = function(self, text)
-		if text and text ~= "" then
-			self.label:SetText(text)
-			if self.labelHeight ~= 10 then
-				self.labelHeight = 10
-				self.label:Show()
-			end
-		elseif self.labelHeight ~= 0 then
-			self.labelHeight = 0
-			self.label:Hide()
-		end
-		Layout(self)
-	end,
-
-	["SetNumLines"] = function(self, value)
-		if not value or value < 4 then
-			value = 4
-		end
-		self.numlines = value
-		Layout(self)
-	end,
-
-	["SetText"] = function(self, text)
-		self.editBox:SetText(text)
-	end,
-
-	["GetText"] = function(self)
-		return self.editBox:GetText()
-	end,
-
-	["SetMaxLetters"] = function (self, num)
-		self.editBox:SetMaxLetters(num or 0)
-	end,
-
-	["DisableButton"] = function(self, disabled)
-		self.disablebutton = disabled
-		if disabled then
-			self.button:Hide()
-		else
-			self.button:Show()
-		end
-		Layout(self)
-	end,
-
-	["ClearFocus"] = function(self)
-		self.editBox:ClearFocus()
-		self.frame:SetScript("OnShow", nil)
-	end,
-
-	["SetFocus"] = function(self)
-		self.editBox:SetFocus()
-		if not self.frame:IsShown() then
-			self.frame:SetScript("OnShow", OnShowFocus)
-		end
-	end,
-
-	["HighlightText"] = function(self, from, to)
-		self.editBox:HighlightText(from, to)
-	end,
-
-	["GetCursorPosition"] = function(self)
-		return self.editBox:GetCursorPosition()
-	end,
-
-	["SetCursorPosition"] = function(self, ...)
-		return self.editBox:SetCursorPosition(...)
-	end,
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local backdrop = {
-	bgFile = [[Interface\Tooltips\UI-Tooltip-Background]],
-	edgeFile = [[Interface\Tooltips\UI-Tooltip-Border]], edgeSize = 16,
-	insets = { left = 4, right = 3, top = 4, bottom = 3 }
-}
-
-local function Constructor()
-	local frame = CreateFrame("Frame", nil, UIParent)
-	frame:Hide()
-
-	local widgetNum = AceGUI:GetNextWidgetNum(Type)
-
-	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
-	label:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, -4)
-	label:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, -4)
-	label:SetJustifyH("LEFT")
-	label:SetText(ACCEPT)
-	label:SetHeight(10)
-
-	local button = CreateFrame("Button", ("%s%dButton"):format(Type, widgetNum), frame, "UIPanelButtonTemplate")
-	button:SetPoint("BOTTOMLEFT", 0, 4)
-	button:SetHeight(22)
-	button:SetWidth(label:GetStringWidth() + 24)
-	button:SetText(ACCEPT)
-	button:SetScript("OnClick", OnClick)
-	button:Disable()
-
-	local text = button:GetFontString()
-	text:ClearAllPoints()
-	text:SetPoint("TOPLEFT", button, "TOPLEFT", 5, -5)
-	text:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", -5, 1)
-	text:SetJustifyV("MIDDLE")
-
-	local scrollBG = CreateFrame("Frame", nil, frame, "BackdropTemplate")
-	scrollBG:SetBackdrop(backdrop)
-	scrollBG:SetBackdropColor(0, 0, 0)
-	scrollBG:SetBackdropBorderColor(0.4, 0.4, 0.4)
-
-	local scrollFrame = CreateFrame("ScrollFrame", ("%s%dScrollFrame"):format(Type, widgetNum), frame, "UIPanelScrollFrameTemplate")
-
-	local scrollBar = _G[scrollFrame:GetName() .. "ScrollBar"]
-	scrollBar:ClearAllPoints()
-	scrollBar:SetPoint("TOP", label, "BOTTOM", 0, -19)
-	scrollBar:SetPoint("BOTTOM", button, "TOP", 0, 18)
-	scrollBar:SetPoint("RIGHT", frame, "RIGHT")
-
-	scrollBG:SetPoint("TOPRIGHT", scrollBar, "TOPLEFT", 0, 19)
-	scrollBG:SetPoint("BOTTOMLEFT", button, "TOPLEFT")
-
-	scrollFrame:SetPoint("TOPLEFT", scrollBG, "TOPLEFT", 5, -6)
-	scrollFrame:SetPoint("BOTTOMRIGHT", scrollBG, "BOTTOMRIGHT", -4, 4)
-	scrollFrame:SetScript("OnEnter", OnEnter)
-	scrollFrame:SetScript("OnLeave", OnLeave)
-	scrollFrame:SetScript("OnMouseUp", OnMouseUp)
-	scrollFrame:SetScript("OnReceiveDrag", OnReceiveDrag)
-	scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
-	scrollFrame:HookScript("OnVerticalScroll", OnVerticalScroll)
-	scrollFrame:HookScript("OnScrollRangeChanged", OnScrollRangeChanged)
-
-	local editBox = CreateFrame("EditBox", ("%s%dEdit"):format(Type, widgetNum), scrollFrame)
-	editBox:SetAllPoints()
-	editBox:SetFontObject(ChatFontNormal)
-	editBox:SetMultiLine(true)
-	editBox:EnableMouse(true)
-	editBox:SetAutoFocus(false)
-	editBox:SetCountInvisibleLetters(false)
-	editBox:SetScript("OnCursorChanged", OnCursorChanged)
-	editBox:SetScript("OnEditFocusLost", OnEditFocusLost)
-	editBox:SetScript("OnEnter", OnEnter)
-	editBox:SetScript("OnEscapePressed", editBox.ClearFocus)
-	editBox:SetScript("OnLeave", OnLeave)
-	editBox:SetScript("OnMouseDown", OnReceiveDrag)
-	editBox:SetScript("OnReceiveDrag", OnReceiveDrag)
-	editBox:SetScript("OnTextChanged", OnTextChanged)
-	editBox:SetScript("OnTextSet", OnTextSet)
-	editBox:SetScript("OnEditFocusGained", OnEditFocusGained)
-
-
-	scrollFrame:SetScrollChild(editBox)
-
-	local widget = {
-		button      = button,
-		editBox     = editBox,
-		frame       = frame,
-		label       = label,
-		labelHeight = 10,
-		numlines    = 4,
-		scrollBar   = scrollBar,
-		scrollBG    = scrollBG,
-		scrollFrame = scrollFrame,
-		type        = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-	button.obj, editBox.obj, scrollFrame.obj = widget, widget, widget
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type, Constructor, Version)
+local Type, Version = "MultiLineEditBox", 32
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local pairs = pairs
+
+-- WoW APIs
+local GetCursorInfo, GetSpellInfo, ClearCursor = GetCursorInfo, GetSpellInfo, ClearCursor
+local CreateFrame, UIParent = CreateFrame, UIParent
+local _G = _G
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+
+if not AceGUIMultiLineEditBoxInsertLink then
+	-- upgradeable hook
+	hooksecurefunc("ChatEdit_InsertLink", function(...) return _G.AceGUIMultiLineEditBoxInsertLink(...) end)
+end
+
+function _G.AceGUIMultiLineEditBoxInsertLink(text)
+	for i = 1, AceGUI:GetWidgetCount(Type) do
+		local editbox = _G[("MultiLineEditBox%uEdit"):format(i)]
+		if editbox and editbox:IsVisible() and editbox:HasFocus() then
+			editbox:Insert(text)
+			return true
+		end
+	end
+end
+
+
+local function Layout(self)
+	self:SetHeight(self.numlines * 14 + (self.disablebutton and 19 or 41) + self.labelHeight)
+
+	if self.labelHeight == 0 then
+		self.scrollBar:SetPoint("TOP", self.frame, "TOP", 0, -23)
+	else
+		self.scrollBar:SetPoint("TOP", self.label, "BOTTOM", 0, -19)
+	end
+
+	if self.disablebutton then
+		self.scrollBar:SetPoint("BOTTOM", self.frame, "BOTTOM", 0, 21)
+		self.scrollBG:SetPoint("BOTTOMLEFT", 0, 4)
+	else
+		self.scrollBar:SetPoint("BOTTOM", self.button, "TOP", 0, 18)
+		self.scrollBG:SetPoint("BOTTOMLEFT", self.button, "TOPLEFT")
+	end
+end
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function OnClick(self)                                                     -- Button
+	self = self.obj
+	self.editBox:ClearFocus()
+	if not self:Fire("OnEnterPressed", self.editBox:GetText()) then
+		self.button:Disable()
+	end
+end
+
+local function OnCursorChanged(self, _, y, _, cursorHeight)                      -- EditBox
+	self, y = self.obj.scrollFrame, -y
+	local offset = self:GetVerticalScroll()
+	if y < offset then
+		self:SetVerticalScroll(y)
+	else
+		y = y + cursorHeight - self:GetHeight()
+		if y > offset then
+			self:SetVerticalScroll(y)
+		end
+	end
+end
+
+local function OnEditFocusLost(self)                                             -- EditBox
+	self:HighlightText(0, 0)
+	self.obj:Fire("OnEditFocusLost")
+end
+
+local function OnEnter(self)                                                     -- EditBox / ScrollFrame
+	self = self.obj
+	if not self.entered then
+		self.entered = true
+		self:Fire("OnEnter")
+	end
+end
+
+local function OnLeave(self)                                                     -- EditBox / ScrollFrame
+	self = self.obj
+	if self.entered then
+		self.entered = nil
+		self:Fire("OnLeave")
+	end
+end
+
+local function OnMouseUp(self)                                                   -- ScrollFrame
+	self = self.obj.editBox
+	self:SetFocus()
+	self:SetCursorPosition(self:GetNumLetters())
+end
+
+local function OnReceiveDrag(self)                                               -- EditBox / ScrollFrame
+	local type, id, info = GetCursorInfo()
+	if type == "spell" then
+		info = GetSpellInfo(id, info)
+	elseif type ~= "item" then
+		return
+	end
+	ClearCursor()
+	self = self.obj
+	local editBox = self.editBox
+	if not editBox:HasFocus() then
+		editBox:SetFocus()
+		editBox:SetCursorPosition(editBox:GetNumLetters())
+	end
+	editBox:Insert(info)
+	self.button:Enable()
+end
+
+local function OnSizeChanged(self, width, height)                                -- ScrollFrame
+	self.obj.editBox:SetWidth(width)
+end
+
+local function OnTextChanged(self, userInput)                                    -- EditBox
+	if userInput then
+		self = self.obj
+		self:Fire("OnTextChanged", self.editBox:GetText())
+		self.button:Enable()
+	end
+end
+
+local function OnTextSet(self)                                                   -- EditBox
+	self:HighlightText(0, 0)
+	self:SetCursorPosition(self:GetNumLetters())
+	self:SetCursorPosition(0)
+	self.obj.button:Disable()
+end
+
+local function OnVerticalScroll(self, offset)                                    -- ScrollFrame
+	local editBox = self.obj.editBox
+	editBox:SetHitRectInsets(0, 0, offset, editBox:GetHeight() - offset - self:GetHeight())
+end
+
+local function OnScrollRangeChanged(self, xrange, yrange)
+	if yrange == 0 then
+		self.obj.editBox:SetHitRectInsets(0, 0, 0, 0)
+	else
+		OnVerticalScroll(self, self:GetVerticalScroll())
+	end
+end
+
+local function OnShowFocus(frame)
+	frame.obj.editBox:SetFocus()
+	frame:SetScript("OnShow", nil)
+end
+
+local function OnEditFocusGained(frame)
+	AceGUI:SetFocus(frame.obj)
+	frame.obj:Fire("OnEditFocusGained")
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self.editBox:SetText("")
+		self:SetDisabled(false)
+		self:SetWidth(200)
+		self:DisableButton(false)
+		self:SetNumLines()
+		self.entered = nil
+		self:SetMaxLetters(0)
+	end,
+
+	["OnRelease"] = function(self)
+		self:ClearFocus()
+	end,
+
+	["SetDisabled"] = function(self, disabled)
+		local editBox = self.editBox
+		if disabled then
+			editBox:ClearFocus()
+			editBox:EnableMouse(false)
+			editBox:SetTextColor(0.5, 0.5, 0.5)
+			self.label:SetTextColor(0.5, 0.5, 0.5)
+			self.scrollFrame:EnableMouse(false)
+			self.button:Disable()
+		else
+			editBox:EnableMouse(true)
+			editBox:SetTextColor(1, 1, 1)
+			self.label:SetTextColor(1, 0.82, 0)
+			self.scrollFrame:EnableMouse(true)
+		end
+	end,
+
+	["SetLabel"] = function(self, text)
+		if text and text ~= "" then
+			self.label:SetText(text)
+			if self.labelHeight ~= 10 then
+				self.labelHeight = 10
+				self.label:Show()
+			end
+		elseif self.labelHeight ~= 0 then
+			self.labelHeight = 0
+			self.label:Hide()
+		end
+		Layout(self)
+	end,
+
+	["SetNumLines"] = function(self, value)
+		if not value or value < 4 then
+			value = 4
+		end
+		self.numlines = value
+		Layout(self)
+	end,
+
+	["SetText"] = function(self, text)
+		self.editBox:SetText(text)
+	end,
+
+	["GetText"] = function(self)
+		return self.editBox:GetText()
+	end,
+
+	["SetMaxLetters"] = function (self, num)
+		self.editBox:SetMaxLetters(num or 0)
+	end,
+
+	["DisableButton"] = function(self, disabled)
+		self.disablebutton = disabled
+		if disabled then
+			self.button:Hide()
+		else
+			self.button:Show()
+		end
+		Layout(self)
+	end,
+
+	["ClearFocus"] = function(self)
+		self.editBox:ClearFocus()
+		self.frame:SetScript("OnShow", nil)
+	end,
+
+	["SetFocus"] = function(self)
+		self.editBox:SetFocus()
+		if not self.frame:IsShown() then
+			self.frame:SetScript("OnShow", OnShowFocus)
+		end
+	end,
+
+	["HighlightText"] = function(self, from, to)
+		self.editBox:HighlightText(from, to)
+	end,
+
+	["GetCursorPosition"] = function(self)
+		return self.editBox:GetCursorPosition()
+	end,
+
+	["SetCursorPosition"] = function(self, ...)
+		return self.editBox:SetCursorPosition(...)
+	end,
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local backdrop = {
+	bgFile = [[Interface\Tooltips\UI-Tooltip-Background]],
+	edgeFile = [[Interface\Tooltips\UI-Tooltip-Border]], edgeSize = 16,
+	insets = { left = 4, right = 3, top = 4, bottom = 3 }
+}
+
+local function Constructor()
+	local frame = CreateFrame("Frame", nil, UIParent)
+	frame:Hide()
+
+	local widgetNum = AceGUI:GetNextWidgetNum(Type)
+
+	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
+	label:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, -4)
+	label:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, -4)
+	label:SetJustifyH("LEFT")
+	label:SetText(ACCEPT)
+	label:SetHeight(10)
+
+	local button = CreateFrame("Button", ("%s%dButton"):format(Type, widgetNum), frame, "UIPanelButtonTemplate")
+	button:SetPoint("BOTTOMLEFT", 0, 4)
+	button:SetHeight(22)
+	button:SetWidth(label:GetStringWidth() + 24)
+	button:SetText(ACCEPT)
+	button:SetScript("OnClick", OnClick)
+	button:Disable()
+
+	local text = button:GetFontString()
+	text:ClearAllPoints()
+	text:SetPoint("TOPLEFT", button, "TOPLEFT", 5, -5)
+	text:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", -5, 1)
+	text:SetJustifyV("MIDDLE")
+
+	local scrollBG = CreateFrame("Frame", nil, frame, "BackdropTemplate")
+	scrollBG:SetBackdrop(backdrop)
+	scrollBG:SetBackdropColor(0, 0, 0)
+	scrollBG:SetBackdropBorderColor(0.4, 0.4, 0.4)
+
+	local scrollFrame = CreateFrame("ScrollFrame", ("%s%dScrollFrame"):format(Type, widgetNum), frame, "UIPanelScrollFrameTemplate")
+
+	local scrollBar = _G[scrollFrame:GetName() .. "ScrollBar"]
+	scrollBar:ClearAllPoints()
+	scrollBar:SetPoint("TOP", label, "BOTTOM", 0, -19)
+	scrollBar:SetPoint("BOTTOM", button, "TOP", 0, 18)
+	scrollBar:SetPoint("RIGHT", frame, "RIGHT")
+
+	scrollBG:SetPoint("TOPRIGHT", scrollBar, "TOPLEFT", 0, 19)
+	scrollBG:SetPoint("BOTTOMLEFT", button, "TOPLEFT")
+
+	scrollFrame:SetPoint("TOPLEFT", scrollBG, "TOPLEFT", 5, -6)
+	scrollFrame:SetPoint("BOTTOMRIGHT", scrollBG, "BOTTOMRIGHT", -4, 4)
+	scrollFrame:SetScript("OnEnter", OnEnter)
+	scrollFrame:SetScript("OnLeave", OnLeave)
+	scrollFrame:SetScript("OnMouseUp", OnMouseUp)
+	scrollFrame:SetScript("OnReceiveDrag", OnReceiveDrag)
+	scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
+	scrollFrame:HookScript("OnVerticalScroll", OnVerticalScroll)
+	scrollFrame:HookScript("OnScrollRangeChanged", OnScrollRangeChanged)
+
+	local editBox = CreateFrame("EditBox", ("%s%dEdit"):format(Type, widgetNum), scrollFrame)
+	editBox:SetAllPoints()
+	editBox:SetFontObject(ChatFontNormal)
+	editBox:SetMultiLine(true)
+	editBox:EnableMouse(true)
+	editBox:SetAutoFocus(false)
+	editBox:SetCountInvisibleLetters(false)
+	editBox:SetScript("OnCursorChanged", OnCursorChanged)
+	editBox:SetScript("OnEditFocusLost", OnEditFocusLost)
+	editBox:SetScript("OnEnter", OnEnter)
+	editBox:SetScript("OnEscapePressed", editBox.ClearFocus)
+	editBox:SetScript("OnLeave", OnLeave)
+	editBox:SetScript("OnMouseDown", OnReceiveDrag)
+	editBox:SetScript("OnReceiveDrag", OnReceiveDrag)
+	editBox:SetScript("OnTextChanged", OnTextChanged)
+	editBox:SetScript("OnTextSet", OnTextSet)
+	editBox:SetScript("OnEditFocusGained", OnEditFocusGained)
+
+
+	scrollFrame:SetScrollChild(editBox)
+
+	local widget = {
+		button      = button,
+		editBox     = editBox,
+		frame       = frame,
+		label       = label,
+		labelHeight = 10,
+		numlines    = 4,
+		scrollBar   = scrollBar,
+		scrollBG    = scrollBG,
+		scrollFrame = scrollFrame,
+		type        = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+	button.obj, editBox.obj, scrollFrame.obj = widget, widget, widget
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type, Constructor, Version)
diff --git a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Slider.lua b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Slider.lua
index 8989608..483d400 100644
--- a/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Slider.lua
+++ b/Carbonite/Libs/AceGUI-3.0/widgets/AceGUIWidget-Slider.lua
@@ -1,280 +1,280 @@
---[[-----------------------------------------------------------------------------
-Slider Widget
-Graphical Slider, like, for Range values.
--------------------------------------------------------------------------------]]
-local Type, Version = "Slider", 23
-local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
-if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
-
--- Lua APIs
-local min, max, floor = math.min, math.max, math.floor
-local tonumber, pairs = tonumber, pairs
-
--- WoW APIs
-local PlaySound = PlaySound
-local CreateFrame, UIParent = CreateFrame, UIParent
-
---[[-----------------------------------------------------------------------------
-Support functions
--------------------------------------------------------------------------------]]
-local function UpdateText(self)
-	local value = self.value or 0
-	if self.ispercent then
-		self.editbox:SetText(("%s%%"):format(floor(value * 1000 + 0.5) / 10))
-	else
-		self.editbox:SetText(floor(value * 100 + 0.5) / 100)
-	end
-end
-
-local function UpdateLabels(self)
-	local min_value, max_value = (self.min or 0), (self.max or 100)
-	if self.ispercent then
-		self.lowtext:SetFormattedText("%s%%", (min_value * 100))
-		self.hightext:SetFormattedText("%s%%", (max_value * 100))
-	else
-		self.lowtext:SetText(min_value)
-		self.hightext:SetText(max_value)
-	end
-end
-
---[[-----------------------------------------------------------------------------
-Scripts
--------------------------------------------------------------------------------]]
-local function Control_OnEnter(frame)
-	frame.obj:Fire("OnEnter")
-end
-
-local function Control_OnLeave(frame)
-	frame.obj:Fire("OnLeave")
-end
-
-local function Frame_OnMouseDown(frame)
-	frame.obj.slider:EnableMouseWheel(true)
-	AceGUI:ClearFocus()
-end
-
-local function Slider_OnValueChanged(frame, newvalue)
-	local self = frame.obj
-	if not frame.setup then
-		if self.step and self.step > 0 then
-			local min_value = self.min or 0
-			newvalue = floor((newvalue - min_value) / self.step + 0.5) * self.step + min_value
-		end
-		if newvalue ~= self.value and not self.disabled then
-			self.value = newvalue
-			self:Fire("OnValueChanged", newvalue)
-		end
-		if self.value then
-			UpdateText(self)
-		end
-	end
-end
-
-local function Slider_OnMouseUp(frame)
-	local self = frame.obj
-	self:Fire("OnMouseUp", self.value)
-end
-
-local function Slider_OnMouseWheel(frame, v)
-	local self = frame.obj
-	if not self.disabled then
-		local value = self.value
-		if v > 0 then
-			value = min(value + (self.step or 1), self.max)
-		else
-			value = max(value - (self.step or 1), self.min)
-		end
-		self.slider:SetValue(value)
-	end
-end
-
-local function EditBox_OnEscapePressed(frame)
-	frame:ClearFocus()
-end
-
-local function EditBox_OnEnterPressed(frame)
-	local self = frame.obj
-	local value = frame:GetText()
-	if self.ispercent then
-		value = value:gsub('%%', '')
-		value = tonumber(value) / 100
-	else
-		value = tonumber(value)
-	end
-
-	if value then
-		PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
-		self.slider:SetValue(value)
-		self:Fire("OnMouseUp", value)
-	end
-end
-
-local function EditBox_OnEnter(frame)
-	frame:SetBackdropBorderColor(0.5, 0.5, 0.5, 1)
-end
-
-local function EditBox_OnLeave(frame)
-	frame:SetBackdropBorderColor(0.3, 0.3, 0.3, 0.8)
-end
-
---[[-----------------------------------------------------------------------------
-Methods
--------------------------------------------------------------------------------]]
-local methods = {
-	["OnAcquire"] = function(self)
-		self:SetWidth(200)
-		self:SetHeight(44)
-		self:SetDisabled(false)
-		self:SetIsPercent(nil)
-		self:SetSliderValues(0,100,1)
-		self:SetValue(0)
-		self.slider:EnableMouseWheel(false)
-	end,
-
-	-- ["OnRelease"] = nil,
-
-	["SetDisabled"] = function(self, disabled)
-		self.disabled = disabled
-		if disabled then
-			self.slider:EnableMouse(false)
-			self.label:SetTextColor(.5, .5, .5)
-			self.hightext:SetTextColor(.5, .5, .5)
-			self.lowtext:SetTextColor(.5, .5, .5)
-			--self.valuetext:SetTextColor(.5, .5, .5)
-			self.editbox:SetTextColor(.5, .5, .5)
-			self.editbox:EnableMouse(false)
-			self.editbox:ClearFocus()
-		else
-			self.slider:EnableMouse(true)
-			self.label:SetTextColor(1, .82, 0)
-			self.hightext:SetTextColor(1, 1, 1)
-			self.lowtext:SetTextColor(1, 1, 1)
-			--self.valuetext:SetTextColor(1, 1, 1)
-			self.editbox:SetTextColor(1, 1, 1)
-			self.editbox:EnableMouse(true)
-		end
-	end,
-
-	["SetValue"] = function(self, value)
-		self.slider.setup = true
-		self.slider:SetValue(value)
-		self.value = value
-		UpdateText(self)
-		self.slider.setup = nil
-	end,
-
-	["GetValue"] = function(self)
-		return self.value
-	end,
-
-	["SetLabel"] = function(self, text)
-		self.label:SetText(text)
-	end,
-
-	["SetSliderValues"] = function(self, min_value, max_value, step)
-		local frame = self.slider
-		frame.setup = true
-		self.min = min_value
-		self.max = max_value
-		self.step = step
-		frame:SetMinMaxValues(min_value or 0,max_value or 100)
-		UpdateLabels(self)
-		frame:SetValueStep(step or 1)
-		if self.value then
-			frame:SetValue(self.value)
-		end
-		frame.setup = nil
-	end,
-
-	["SetIsPercent"] = function(self, value)
-		self.ispercent = value
-		UpdateLabels(self)
-		UpdateText(self)
-	end
-}
-
---[[-----------------------------------------------------------------------------
-Constructor
--------------------------------------------------------------------------------]]
-local SliderBackdrop  = {
-	bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
-	edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
-	tile = true, tileSize = 8, edgeSize = 8,
-	insets = { left = 3, right = 3, top = 6, bottom = 6 }
-}
-
-local ManualBackdrop = {
-	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
-	edgeFile = "Interface\\ChatFrame\\ChatFrameBackground",
-	tile = true, edgeSize = 1, tileSize = 5,
-}
-
-local function Constructor()
-	local frame = CreateFrame("Frame", nil, UIParent)
-
-	frame:EnableMouse(true)
-	frame:SetScript("OnMouseDown", Frame_OnMouseDown)
-
-	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
-	label:SetPoint("TOPLEFT")
-	label:SetPoint("TOPRIGHT")
-	label:SetJustifyH("CENTER")
-	label:SetHeight(15)
-
-	local slider = CreateFrame("Slider", nil, frame, "BackdropTemplate")
-	slider:SetOrientation("HORIZONTAL")
-	slider:SetHeight(15)
-	slider:SetHitRectInsets(0, 0, -10, 0)
-	slider:SetBackdrop(SliderBackdrop)
-	slider:SetThumbTexture("Interface\\Buttons\\UI-SliderBar-Button-Horizontal")
-	slider:SetPoint("TOP", label, "BOTTOM")
-	slider:SetPoint("LEFT", 3, 0)
-	slider:SetPoint("RIGHT", -3, 0)
-	slider:SetValue(0)
-	slider:SetScript("OnValueChanged",Slider_OnValueChanged)
-	slider:SetScript("OnEnter", Control_OnEnter)
-	slider:SetScript("OnLeave", Control_OnLeave)
-	slider:SetScript("OnMouseUp", Slider_OnMouseUp)
-	slider:SetScript("OnMouseWheel", Slider_OnMouseWheel)
-
-	local lowtext = slider:CreateFontString(nil, "ARTWORK", "GameFontHighlightSmall")
-	lowtext:SetPoint("TOPLEFT", slider, "BOTTOMLEFT", 2, 3)
-
-	local hightext = slider:CreateFontString(nil, "ARTWORK", "GameFontHighlightSmall")
-	hightext:SetPoint("TOPRIGHT", slider, "BOTTOMRIGHT", -2, 3)
-
-	local editbox = CreateFrame("EditBox", nil, frame, "BackdropTemplate")
-	editbox:SetAutoFocus(false)
-	editbox:SetFontObject(GameFontHighlightSmall)
-	editbox:SetPoint("TOP", slider, "BOTTOM")
-	editbox:SetHeight(14)
-	editbox:SetWidth(70)
-	editbox:SetJustifyH("CENTER")
-	editbox:EnableMouse(true)
-	editbox:SetBackdrop(ManualBackdrop)
-	editbox:SetBackdropColor(0, 0, 0, 0.5)
-	editbox:SetBackdropBorderColor(0.3, 0.3, 0.30, 0.80)
-	editbox:SetScript("OnEnter", EditBox_OnEnter)
-	editbox:SetScript("OnLeave", EditBox_OnLeave)
-	editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
-	editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)
-
-	local widget = {
-		label       = label,
-		slider      = slider,
-		lowtext     = lowtext,
-		hightext    = hightext,
-		editbox     = editbox,
-		alignoffset = 25,
-		frame       = frame,
-		type        = Type
-	}
-	for method, func in pairs(methods) do
-		widget[method] = func
-	end
-	slider.obj, editbox.obj = widget, widget
-
-	return AceGUI:RegisterAsWidget(widget)
-end
-
-AceGUI:RegisterWidgetType(Type,Constructor,Version)
+--[[-----------------------------------------------------------------------------
+Slider Widget
+Graphical Slider, like, for Range values.
+-------------------------------------------------------------------------------]]
+local Type, Version = "Slider", 23
+local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
+if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
+
+-- Lua APIs
+local min, max, floor = math.min, math.max, math.floor
+local tonumber, pairs = tonumber, pairs
+
+-- WoW APIs
+local PlaySound = PlaySound
+local CreateFrame, UIParent = CreateFrame, UIParent
+
+--[[-----------------------------------------------------------------------------
+Support functions
+-------------------------------------------------------------------------------]]
+local function UpdateText(self)
+	local value = self.value or 0
+	if self.ispercent then
+		self.editbox:SetText(("%s%%"):format(floor(value * 1000 + 0.5) / 10))
+	else
+		self.editbox:SetText(floor(value * 100 + 0.5) / 100)
+	end
+end
+
+local function UpdateLabels(self)
+	local min_value, max_value = (self.min or 0), (self.max or 100)
+	if self.ispercent then
+		self.lowtext:SetFormattedText("%s%%", (min_value * 100))
+		self.hightext:SetFormattedText("%s%%", (max_value * 100))
+	else
+		self.lowtext:SetText(min_value)
+		self.hightext:SetText(max_value)
+	end
+end
+
+--[[-----------------------------------------------------------------------------
+Scripts
+-------------------------------------------------------------------------------]]
+local function Control_OnEnter(frame)
+	frame.obj:Fire("OnEnter")
+end
+
+local function Control_OnLeave(frame)
+	frame.obj:Fire("OnLeave")
+end
+
+local function Frame_OnMouseDown(frame)
+	frame.obj.slider:EnableMouseWheel(true)
+	AceGUI:ClearFocus()
+end
+
+local function Slider_OnValueChanged(frame, newvalue)
+	local self = frame.obj
+	if not frame.setup then
+		if self.step and self.step > 0 then
+			local min_value = self.min or 0
+			newvalue = floor((newvalue - min_value) / self.step + 0.5) * self.step + min_value
+		end
+		if newvalue ~= self.value and not self.disabled then
+			self.value = newvalue
+			self:Fire("OnValueChanged", newvalue)
+		end
+		if self.value then
+			UpdateText(self)
+		end
+	end
+end
+
+local function Slider_OnMouseUp(frame)
+	local self = frame.obj
+	self:Fire("OnMouseUp", self.value)
+end
+
+local function Slider_OnMouseWheel(frame, v)
+	local self = frame.obj
+	if not self.disabled then
+		local value = self.value
+		if v > 0 then
+			value = min(value + (self.step or 1), self.max)
+		else
+			value = max(value - (self.step or 1), self.min)
+		end
+		self.slider:SetValue(value)
+	end
+end
+
+local function EditBox_OnEscapePressed(frame)
+	frame:ClearFocus()
+end
+
+local function EditBox_OnEnterPressed(frame)
+	local self = frame.obj
+	local value = frame:GetText()
+	if self.ispercent then
+		value = value:gsub('%%', '')
+		value = tonumber(value) / 100
+	else
+		value = tonumber(value)
+	end
+
+	if value then
+		PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
+		self.slider:SetValue(value)
+		self:Fire("OnMouseUp", value)
+	end
+end
+
+local function EditBox_OnEnter(frame)
+	frame:SetBackdropBorderColor(0.5, 0.5, 0.5, 1)
+end
+
+local function EditBox_OnLeave(frame)
+	frame:SetBackdropBorderColor(0.3, 0.3, 0.3, 0.8)
+end
+
+--[[-----------------------------------------------------------------------------
+Methods
+-------------------------------------------------------------------------------]]
+local methods = {
+	["OnAcquire"] = function(self)
+		self:SetWidth(200)
+		self:SetHeight(44)
+		self:SetDisabled(false)
+		self:SetIsPercent(nil)
+		self:SetSliderValues(0,100,1)
+		self:SetValue(0)
+		self.slider:EnableMouseWheel(false)
+	end,
+
+	-- ["OnRelease"] = nil,
+
+	["SetDisabled"] = function(self, disabled)
+		self.disabled = disabled
+		if disabled then
+			self.slider:EnableMouse(false)
+			self.label:SetTextColor(.5, .5, .5)
+			self.hightext:SetTextColor(.5, .5, .5)
+			self.lowtext:SetTextColor(.5, .5, .5)
+			--self.valuetext:SetTextColor(.5, .5, .5)
+			self.editbox:SetTextColor(.5, .5, .5)
+			self.editbox:EnableMouse(false)
+			self.editbox:ClearFocus()
+		else
+			self.slider:EnableMouse(true)
+			self.label:SetTextColor(1, .82, 0)
+			self.hightext:SetTextColor(1, 1, 1)
+			self.lowtext:SetTextColor(1, 1, 1)
+			--self.valuetext:SetTextColor(1, 1, 1)
+			self.editbox:SetTextColor(1, 1, 1)
+			self.editbox:EnableMouse(true)
+		end
+	end,
+
+	["SetValue"] = function(self, value)
+		self.slider.setup = true
+		self.slider:SetValue(value)
+		self.value = value
+		UpdateText(self)
+		self.slider.setup = nil
+	end,
+
+	["GetValue"] = function(self)
+		return self.value
+	end,
+
+	["SetLabel"] = function(self, text)
+		self.label:SetText(text)
+	end,
+
+	["SetSliderValues"] = function(self, min_value, max_value, step)
+		local frame = self.slider
+		frame.setup = true
+		self.min = min_value
+		self.max = max_value
+		self.step = step
+		frame:SetMinMaxValues(min_value or 0,max_value or 100)
+		UpdateLabels(self)
+		frame:SetValueStep(step or 1)
+		if self.value then
+			frame:SetValue(self.value)
+		end
+		frame.setup = nil
+	end,
+
+	["SetIsPercent"] = function(self, value)
+		self.ispercent = value
+		UpdateLabels(self)
+		UpdateText(self)
+	end
+}
+
+--[[-----------------------------------------------------------------------------
+Constructor
+-------------------------------------------------------------------------------]]
+local SliderBackdrop  = {
+	bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
+	edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
+	tile = true, tileSize = 8, edgeSize = 8,
+	insets = { left = 3, right = 3, top = 6, bottom = 6 }
+}
+
+local ManualBackdrop = {
+	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
+	edgeFile = "Interface\\ChatFrame\\ChatFrameBackground",
+	tile = true, edgeSize = 1, tileSize = 5,
+}
+
+local function Constructor()
+	local frame = CreateFrame("Frame", nil, UIParent)
+
+	frame:EnableMouse(true)
+	frame:SetScript("OnMouseDown", Frame_OnMouseDown)
+
+	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
+	label:SetPoint("TOPLEFT")
+	label:SetPoint("TOPRIGHT")
+	label:SetJustifyH("CENTER")
+	label:SetHeight(15)
+
+	local slider = CreateFrame("Slider", nil, frame, "BackdropTemplate")
+	slider:SetOrientation("HORIZONTAL")
+	slider:SetHeight(15)
+	slider:SetHitRectInsets(0, 0, -10, 0)
+	slider:SetBackdrop(SliderBackdrop)
+	slider:SetThumbTexture("Interface\\Buttons\\UI-SliderBar-Button-Horizontal")
+	slider:SetPoint("TOP", label, "BOTTOM")
+	slider:SetPoint("LEFT", 3, 0)
+	slider:SetPoint("RIGHT", -3, 0)
+	slider:SetValue(0)
+	slider:SetScript("OnValueChanged",Slider_OnValueChanged)
+	slider:SetScript("OnEnter", Control_OnEnter)
+	slider:SetScript("OnLeave", Control_OnLeave)
+	slider:SetScript("OnMouseUp", Slider_OnMouseUp)
+	slider:SetScript("OnMouseWheel", Slider_OnMouseWheel)
+
+	local lowtext = slider:CreateFontString(nil, "ARTWORK", "GameFontHighlightSmall")
+	lowtext:SetPoint("TOPLEFT", slider, "BOTTOMLEFT", 2, 3)
+
+	local hightext = slider:CreateFontString(nil, "ARTWORK", "GameFontHighlightSmall")
+	hightext:SetPoint("TOPRIGHT", slider, "BOTTOMRIGHT", -2, 3)
+
+	local editbox = CreateFrame("EditBox", nil, frame, "BackdropTemplate")
+	editbox:SetAutoFocus(false)
+	editbox:SetFontObject(GameFontHighlightSmall)
+	editbox:SetPoint("TOP", slider, "BOTTOM")
+	editbox:SetHeight(14)
+	editbox:SetWidth(70)
+	editbox:SetJustifyH("CENTER")
+	editbox:EnableMouse(true)
+	editbox:SetBackdrop(ManualBackdrop)
+	editbox:SetBackdropColor(0, 0, 0, 0.5)
+	editbox:SetBackdropBorderColor(0.3, 0.3, 0.30, 0.80)
+	editbox:SetScript("OnEnter", EditBox_OnEnter)
+	editbox:SetScript("OnLeave", EditBox_OnLeave)
+	editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
+	editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)
+
+	local widget = {
+		label       = label,
+		slider      = slider,
+		lowtext     = lowtext,
+		hightext    = hightext,
+		editbox     = editbox,
+		alignoffset = 25,
+		frame       = frame,
+		type        = Type
+	}
+	for method, func in pairs(methods) do
+		widget[method] = func
+	end
+	slider.obj, editbox.obj = widget, widget
+
+	return AceGUI:RegisterAsWidget(widget)
+end
+
+AceGUI:RegisterWidgetType(Type,Constructor,Version)
diff --git a/Carbonite/Libs/AceHook-3.0/AceHook-3.0.lua b/Carbonite/Libs/AceHook-3.0/AceHook-3.0.lua
index 6bfc798..7d26d91 100644
--- a/Carbonite/Libs/AceHook-3.0/AceHook-3.0.lua
+++ b/Carbonite/Libs/AceHook-3.0/AceHook-3.0.lua
@@ -1,510 +1,510 @@
---- **AceHook-3.0** offers safe Hooking/Unhooking of functions, methods and frame scripts.
--- Using AceHook-3.0 is recommended when you need to unhook your hooks again, so the hook chain isn't broken
--- when you manually restore the original function.
---
--- **AceHook-3.0** can be embeded into your addon, either explicitly by calling AceHook:Embed(MyAddon) or by
--- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
--- and can be accessed directly, without having to explicitly call AceHook itself.\\
--- It is recommended to embed AceHook, otherwise you'll have to specify a custom `self` on all calls you
--- make into AceHook.
--- @class file
--- @name AceHook-3.0
--- @release $Id: AceHook-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
-local ACEHOOK_MAJOR, ACEHOOK_MINOR = "AceHook-3.0", 9
-local AceHook, oldminor = LibStub:NewLibrary(ACEHOOK_MAJOR, ACEHOOK_MINOR)
-
-if not AceHook then return end -- No upgrade needed
-
-AceHook.embeded = AceHook.embeded or {}
-AceHook.registry = AceHook.registry or setmetatable({}, {__index = function(tbl, key) tbl[key] = {} return tbl[key] end })
-AceHook.handlers = AceHook.handlers or {}
-AceHook.actives = AceHook.actives or {}
-AceHook.scripts = AceHook.scripts or {}
-AceHook.onceSecure = AceHook.onceSecure or {}
-AceHook.hooks = AceHook.hooks or {}
-
--- local upvalues
-local registry = AceHook.registry
-local handlers = AceHook.handlers
-local actives = AceHook.actives
-local scripts = AceHook.scripts
-local onceSecure = AceHook.onceSecure
-
--- Lua APIs
-local pairs, next, type = pairs, next, type
-local format = string.format
-local assert, error = assert, error
-
--- WoW APIs
-local issecurevariable, hooksecurefunc = issecurevariable, hooksecurefunc
-local _G = _G
-
--- functions for later definition
-local donothing, createHook, hook
-
-local protectedScripts = {
-	OnClick = true,
-}
-
--- upgrading of embeded is done at the bottom of the file
-
-local mixins = {
-	"Hook", "SecureHook",
-	"HookScript", "SecureHookScript",
-	"Unhook", "UnhookAll",
-	"IsHooked",
-	"RawHook", "RawHookScript"
-}
-
--- AceHook:Embed( target )
--- target (object) - target object to embed AceHook in
---
--- Embeds AceEevent into the target object making the functions from the mixins list available on target:..
-function AceHook:Embed( target )
-	for k, v in pairs( mixins ) do
-		target[v] = self[v]
-	end
-	self.embeded[target] = true
-	-- inject the hooks table safely
-	target.hooks = target.hooks or {}
-	return target
-end
-
--- AceHook:OnEmbedDisable( target )
--- target (object) - target object that is being disabled
---
--- Unhooks all hooks when the target disables.
--- this method should be called by the target manually or by an addon framework
-function AceHook:OnEmbedDisable( target )
-	target:UnhookAll()
-end
-
-function createHook(self, handler, orig, secure, failsafe)
-	local uid
-	local method = type(handler) == "string"
-	if failsafe and not secure then
-		-- failsafe hook creation
-		uid = function(...)
-			if actives[uid] then
-				if method then
-					self[handler](self, ...)
-				else
-					handler(...)
-				end
-			end
-			return orig(...)
-		end
-		-- /failsafe hook
-	else
-		-- all other hooks
-		uid = function(...)
-			if actives[uid] then
-				if method then
-					return self[handler](self, ...)
-				else
-					return handler(...)
-				end
-			elseif not secure then -- backup on non secure
-				return orig(...)
-			end
-		end
-		-- /hook
-	end
-	return uid
-end
-
-function donothing() end
-
-function hook(self, obj, method, handler, script, secure, raw, forceSecure, usage)
-	if not handler then handler = method end
-
-	-- These asserts make sure AceHooks's devs play by the rules.
-	assert(not script or type(script) == "boolean")
-	assert(not secure or type(secure) == "boolean")
-	assert(not raw or type(raw) == "boolean")
-	assert(not forceSecure or type(forceSecure) == "boolean")
-	assert(usage)
-
-	-- Error checking Battery!
-	if obj and type(obj) ~= "table" then
-		error(format("%s: 'object' - nil or table expected got %s", usage, type(obj)), 3)
-	end
-	if type(method) ~= "string" then
-		error(format("%s: 'method' - string expected got %s", usage, type(method)), 3)
-	end
-	if type(handler) ~= "string" and type(handler) ~= "function" then
-		error(format("%s: 'handler' - nil, string, or function expected got %s", usage, type(handler)), 3)
-	end
-	if type(handler) == "string" and type(self[handler]) ~= "function" then
-		error(format("%s: 'handler' - Handler specified does not exist at self[handler]", usage), 3)
-	end
-	if script then
-		if not obj or not obj.GetScript or not obj:HasScript(method) then
-			error(format("%s: You can only hook a script on a frame object", usage), 3)
-		end
-		if not secure and obj.IsProtected and obj:IsProtected() and protectedScripts[method] then
-			error(format("Cannot hook secure script %q; Use SecureHookScript(obj, method, [handler]) instead.", method), 3)
-		end
-	else
-		local issecure
-		if obj then
-			issecure = onceSecure[obj] and onceSecure[obj][method] or issecurevariable(obj, method)
-		else
-			issecure = onceSecure[method] or issecurevariable(method)
-		end
-		if issecure then
-			if forceSecure then
-				if obj then
-					onceSecure[obj] = onceSecure[obj] or {}
-					onceSecure[obj][method] = true
-				else
-					onceSecure[method] = true
-				end
-			elseif not secure then
-				error(format("%s: Attempt to hook secure function %s. Use `SecureHook' or add `true' to the argument list to override.", usage, method), 3)
-			end
-		end
-	end
-
-	local uid
-	if obj then
-		uid = registry[self][obj] and registry[self][obj][method]
-	else
-		uid = registry[self][method]
-	end
-
-	if uid then
-		if actives[uid] then
-			-- Only two sane choices exist here.  We either a) error 100% of the time or b) always unhook and then hook
-			-- choice b would likely lead to odd debuging conditions or other mysteries so we're going with a.
-			error(format("Attempting to rehook already active hook %s.", method))
-		end
-
-		if handlers[uid] == handler then -- turn on a decative hook, note enclosures break this ability, small memory leak
-			actives[uid] = true
-			return
-		elseif obj then -- is there any reason not to call unhook instead of doing the following several lines?
-			if self.hooks and self.hooks[obj] then
-				self.hooks[obj][method] = nil
-			end
-			registry[self][obj][method] = nil
-		else
-			if self.hooks then
-				self.hooks[method] = nil
-			end
-			registry[self][method] = nil
-		end
-		handlers[uid], actives[uid], scripts[uid] = nil, nil, nil
-	end
-
-	local orig
-	if script then
-		orig = obj:GetScript(method) or donothing
-	elseif obj then
-		orig = obj[method]
-	else
-		orig = _G[method]
-	end
-
-	if not orig then
-		error(format("%s: Attempting to hook a non existing target", usage), 3)
-	end
-
-	uid = createHook(self, handler, orig, secure, not (raw or secure))
-
-	if obj then
-		self.hooks[obj] = self.hooks[obj] or {}
-		registry[self][obj] = registry[self][obj] or {}
-		registry[self][obj][method] = uid
-
-		if not secure then
-			self.hooks[obj][method] = orig
-		end
-
-		if script then
-			if not secure then
-				obj:SetScript(method, uid)
-			else
-				obj:HookScript(method, uid)
-			end
-		else
-			if not secure then
-				obj[method] = uid
-			else
-				hooksecurefunc(obj, method, uid)
-			end
-		end
-	else
-		registry[self][method] = uid
-
-		if not secure then
-			_G[method] = uid
-			self.hooks[method] = orig
-		else
-			hooksecurefunc(method, uid)
-		end
-	end
-
-	actives[uid], handlers[uid], scripts[uid] = true, handler, script and true or nil
-end
-
---- Hook a function or a method on an object.
--- The hook created will be a "safe hook", that means that your handler will be called
--- before the hooked function ("Pre-Hook"), and you don't have to call the original function yourself,
--- however you cannot stop the execution of the function, or modify any of the arguments/return values.\\
--- This type of hook is typically used if you need to know if some function got called, and don't want to modify it.
--- @paramsig [object], method, [handler], [hookSecure]
--- @param object The object to hook a method from
--- @param method If object was specified, the name of the method, or the name of the function to hook.
--- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked function)
--- @param hookSecure If true, AceHook will allow hooking of secure functions.
--- @usage
--- -- create an addon with AceHook embeded
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
---
--- function MyAddon:OnEnable()
---   -- Hook ActionButton_UpdateHotkeys, overwriting the secure status
---   self:Hook("ActionButton_UpdateHotkeys", true)
--- end
---
--- function MyAddon:ActionButton_UpdateHotkeys(button, type)
---   print(button:GetName() .. " is updating its HotKey")
--- end
-function AceHook:Hook(object, method, handler, hookSecure)
-	if type(object) == "string" then
-		method, handler, hookSecure, object = object, method, handler, nil
-	end
-
-	if handler == true then
-		handler, hookSecure = nil, true
-	end
-
-	hook(self, object, method, handler, false, false, false, hookSecure or false, "Usage: Hook([object], method, [handler], [hookSecure])")
-end
-
---- RawHook a function or a method on an object.
--- The hook created will be a "raw hook", that means that your handler will completly replace
--- the original function, and your handler has to call the original function (or not, depending on your intentions).\\
--- The original function will be stored in `self.hooks[object][method]` or `self.hooks[functionName]` respectively.\\
--- This type of hook can be used for all purposes, and is usually the most common case when you need to modify arguments
--- or want to control execution of the original function.
--- @paramsig [object], method, [handler], [hookSecure]
--- @param object The object to hook a method from
--- @param method If object was specified, the name of the method, or the name of the function to hook.
--- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked function)
--- @param hookSecure If true, AceHook will allow hooking of secure functions.
--- @usage
--- -- create an addon with AceHook embeded
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
---
--- function MyAddon:OnEnable()
---   -- Hook ActionButton_UpdateHotkeys, overwriting the secure status
---   self:RawHook("ActionButton_UpdateHotkeys", true)
--- end
---
--- function MyAddon:ActionButton_UpdateHotkeys(button, type)
---   if button:GetName() == "MyButton" then
---     -- do stuff here
---   else
---     self.hooks.ActionButton_UpdateHotkeys(button, type)
---   end
--- end
-function AceHook:RawHook(object, method, handler, hookSecure)
-	if type(object) == "string" then
-		method, handler, hookSecure, object = object, method, handler, nil
-	end
-
-	if handler == true then
-		handler, hookSecure = nil, true
-	end
-
-	hook(self, object, method, handler, false, false, true, hookSecure or false,  "Usage: RawHook([object], method, [handler], [hookSecure])")
-end
-
---- SecureHook a function or a method on an object.
--- This function is a wrapper around the `hooksecurefunc` function in the WoW API. Using AceHook
--- extends the functionality of secure hooks, and adds the ability to unhook once the hook isn't
--- required anymore, or the addon is being disabled.\\
--- Secure Hooks should be used if the secure-status of the function is vital to its function,
--- and taint would block execution. Secure Hooks are always called after the original function was called
--- ("Post Hook"), and you cannot modify the arguments, return values or control the execution.
--- @paramsig [object], method, [handler]
--- @param object The object to hook a method from
--- @param method If object was specified, the name of the method, or the name of the function to hook.
--- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked function)
-function AceHook:SecureHook(object, method, handler)
-	if type(object) == "string" then
-		method, handler, object = object, method, nil
-	end
-
-	hook(self, object, method, handler, false, true, false, false,  "Usage: SecureHook([object], method, [handler])")
-end
-
---- Hook a script handler on a frame.
--- The hook created will be a "safe hook", that means that your handler will be called
--- before the hooked script ("Pre-Hook"), and you don't have to call the original function yourself,
--- however you cannot stop the execution of the function, or modify any of the arguments/return values.\\
--- This is the frame script equivalent of the :Hook safe-hook. It would typically be used to be notified
--- when a certain event happens to a frame.
--- @paramsig frame, script, [handler]
--- @param frame The Frame to hook the script on
--- @param script The script to hook
--- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked script)
--- @usage
--- -- create an addon with AceHook embeded
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
---
--- function MyAddon:OnEnable()
---   -- Hook the OnShow of FriendsFrame
---   self:HookScript(FriendsFrame, "OnShow", "FriendsFrameOnShow")
--- end
---
--- function MyAddon:FriendsFrameOnShow(frame)
---   print("The FriendsFrame was shown!")
--- end
-function AceHook:HookScript(frame, script, handler)
-	hook(self, frame, script, handler, true, false, false, false,  "Usage: HookScript(object, method, [handler])")
-end
-
---- RawHook a script handler on a frame.
--- The hook created will be a "raw hook", that means that your handler will completly replace
--- the original script, and your handler has to call the original script (or not, depending on your intentions).\\
--- The original script will be stored in `self.hooks[frame][script]`.\\
--- This type of hook can be used for all purposes, and is usually the most common case when you need to modify arguments
--- or want to control execution of the original script.
--- @paramsig frame, script, [handler]
--- @param frame The Frame to hook the script on
--- @param script The script to hook
--- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked script)
--- @usage
--- -- create an addon with AceHook embeded
--- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
---
--- function MyAddon:OnEnable()
---   -- Hook the OnShow of FriendsFrame
---   self:RawHookScript(FriendsFrame, "OnShow", "FriendsFrameOnShow")
--- end
---
--- function MyAddon:FriendsFrameOnShow(frame)
---   -- Call the original function
---   self.hooks[frame].OnShow(frame)
---   -- Do our processing
---   -- .. stuff
--- end
-function AceHook:RawHookScript(frame, script, handler)
-	hook(self, frame, script, handler, true, false, true, false, "Usage: RawHookScript(object, method, [handler])")
-end
-
---- SecureHook a script handler on a frame.
--- This function is a wrapper around the `frame:HookScript` function in the WoW API. Using AceHook
--- extends the functionality of secure hooks, and adds the ability to unhook once the hook isn't
--- required anymore, or the addon is being disabled.\\
--- Secure Hooks should be used if the secure-status of the function is vital to its function,
--- and taint would block execution. Secure Hooks are always called after the original function was called
--- ("Post Hook"), and you cannot modify the arguments, return values or control the execution.
--- @paramsig frame, script, [handler]
--- @param frame The Frame to hook the script on
--- @param script The script to hook
--- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked script)
-function AceHook:SecureHookScript(frame, script, handler)
-	hook(self, frame, script, handler, true, true, false, false, "Usage: SecureHookScript(object, method, [handler])")
-end
-
---- Unhook from the specified function, method or script.
--- @paramsig [obj], method
--- @param obj The object or frame to unhook from
--- @param method The name of the method, function or script to unhook from.
-function AceHook:Unhook(obj, method)
-	local usage = "Usage: Unhook([obj], method)"
-	if type(obj) == "string" then
-		method, obj = obj, nil
-	end
-
-	if obj and type(obj) ~= "table" then
-		error(format("%s: 'obj' - expecting nil or table got %s", usage, type(obj)), 2)
-	end
-	if type(method) ~= "string" then
-		error(format("%s: 'method' - expeting string got %s", usage, type(method)), 2)
-	end
-
-	local uid
-	if obj then
-		uid = registry[self][obj] and registry[self][obj][method]
-	else
-		uid = registry[self][method]
-	end
-
-	if not uid or not actives[uid] then
-		-- Declining to error on an unneeded unhook since the end effect is the same and this would just be annoying.
-		return false
-	end
-
-	actives[uid], handlers[uid] = nil, nil
-
-	if obj then
-		registry[self][obj][method] = nil
-		registry[self][obj] = next(registry[self][obj]) and registry[self][obj] or nil
-
-		-- if the hook reference doesnt exist, then its a secure hook, just bail out and dont do any unhooking
-		if not self.hooks[obj] or not self.hooks[obj][method] then return true end
-
-		if scripts[uid] and obj:GetScript(method) == uid then  -- unhooks scripts
-			obj:SetScript(method, self.hooks[obj][method] ~= donothing and self.hooks[obj][method] or nil)
-			scripts[uid] = nil
-		elseif obj and self.hooks[obj] and self.hooks[obj][method] and obj[method] == uid then -- unhooks methods
-			obj[method] = self.hooks[obj][method]
-		end
-
-		self.hooks[obj][method] = nil
-		self.hooks[obj] = next(self.hooks[obj]) and self.hooks[obj] or nil
-	else
-		registry[self][method] = nil
-
-		-- if self.hooks[method] doesn't exist, then this is a SecureHook, just bail out
-		if not self.hooks[method] then return true end
-
-		if self.hooks[method] and _G[method] == uid then -- unhooks functions
-			_G[method] = self.hooks[method]
-		end
-
-		self.hooks[method] = nil
-	end
-	return true
-end
-
---- Unhook all existing hooks for this addon.
-function AceHook:UnhookAll()
-	for key, value in pairs(registry[self]) do
-		if type(key) == "table" then
-			for method in pairs(value) do
-				AceHook.Unhook(self, key, method)
-			end
-		else
-			AceHook.Unhook(self, key)
-		end
-	end
-end
-
---- Check if the specific function, method or script is already hooked.
--- @paramsig [obj], method
--- @param obj The object or frame to unhook from
--- @param method The name of the method, function or script to unhook from.
-function AceHook:IsHooked(obj, method)
-	-- we don't check if registry[self] exists, this is done by evil magicks in the metatable
-	if type(obj) == "string" then
-		if registry[self][obj] and actives[registry[self][obj]] then
-			return true, handlers[registry[self][obj]]
-		end
-	else
-		if registry[self][obj] and registry[self][obj][method] and actives[registry[self][obj][method]] then
-			return true, handlers[registry[self][obj][method]]
-		end
-	end
-
-	return false, nil
-end
-
---- Upgrade our old embeded
-for target, v in pairs( AceHook.embeded ) do
-	AceHook:Embed( target )
-end
+--- **AceHook-3.0** offers safe Hooking/Unhooking of functions, methods and frame scripts.
+-- Using AceHook-3.0 is recommended when you need to unhook your hooks again, so the hook chain isn't broken
+-- when you manually restore the original function.
+--
+-- **AceHook-3.0** can be embeded into your addon, either explicitly by calling AceHook:Embed(MyAddon) or by
+-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
+-- and can be accessed directly, without having to explicitly call AceHook itself.\\
+-- It is recommended to embed AceHook, otherwise you'll have to specify a custom `self` on all calls you
+-- make into AceHook.
+-- @class file
+-- @name AceHook-3.0
+-- @release $Id: AceHook-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
+local ACEHOOK_MAJOR, ACEHOOK_MINOR = "AceHook-3.0", 9
+local AceHook, oldminor = LibStub:NewLibrary(ACEHOOK_MAJOR, ACEHOOK_MINOR)
+
+if not AceHook then return end -- No upgrade needed
+
+AceHook.embeded = AceHook.embeded or {}
+AceHook.registry = AceHook.registry or setmetatable({}, {__index = function(tbl, key) tbl[key] = {} return tbl[key] end })
+AceHook.handlers = AceHook.handlers or {}
+AceHook.actives = AceHook.actives or {}
+AceHook.scripts = AceHook.scripts or {}
+AceHook.onceSecure = AceHook.onceSecure or {}
+AceHook.hooks = AceHook.hooks or {}
+
+-- local upvalues
+local registry = AceHook.registry
+local handlers = AceHook.handlers
+local actives = AceHook.actives
+local scripts = AceHook.scripts
+local onceSecure = AceHook.onceSecure
+
+-- Lua APIs
+local pairs, next, type = pairs, next, type
+local format = string.format
+local assert, error = assert, error
+
+-- WoW APIs
+local issecurevariable, hooksecurefunc = issecurevariable, hooksecurefunc
+local _G = _G
+
+-- functions for later definition
+local donothing, createHook, hook
+
+local protectedScripts = {
+	OnClick = true,
+}
+
+-- upgrading of embeded is done at the bottom of the file
+
+local mixins = {
+	"Hook", "SecureHook",
+	"HookScript", "SecureHookScript",
+	"Unhook", "UnhookAll",
+	"IsHooked",
+	"RawHook", "RawHookScript"
+}
+
+-- AceHook:Embed( target )
+-- target (object) - target object to embed AceHook in
+--
+-- Embeds AceEevent into the target object making the functions from the mixins list available on target:..
+function AceHook:Embed( target )
+	for k, v in pairs( mixins ) do
+		target[v] = self[v]
+	end
+	self.embeded[target] = true
+	-- inject the hooks table safely
+	target.hooks = target.hooks or {}
+	return target
+end
+
+-- AceHook:OnEmbedDisable( target )
+-- target (object) - target object that is being disabled
+--
+-- Unhooks all hooks when the target disables.
+-- this method should be called by the target manually or by an addon framework
+function AceHook:OnEmbedDisable( target )
+	target:UnhookAll()
+end
+
+function createHook(self, handler, orig, secure, failsafe)
+	local uid
+	local method = type(handler) == "string"
+	if failsafe and not secure then
+		-- failsafe hook creation
+		uid = function(...)
+			if actives[uid] then
+				if method then
+					self[handler](self, ...)
+				else
+					handler(...)
+				end
+			end
+			return orig(...)
+		end
+		-- /failsafe hook
+	else
+		-- all other hooks
+		uid = function(...)
+			if actives[uid] then
+				if method then
+					return self[handler](self, ...)
+				else
+					return handler(...)
+				end
+			elseif not secure then -- backup on non secure
+				return orig(...)
+			end
+		end
+		-- /hook
+	end
+	return uid
+end
+
+function donothing() end
+
+function hook(self, obj, method, handler, script, secure, raw, forceSecure, usage)
+	if not handler then handler = method end
+
+	-- These asserts make sure AceHooks's devs play by the rules.
+	assert(not script or type(script) == "boolean")
+	assert(not secure or type(secure) == "boolean")
+	assert(not raw or type(raw) == "boolean")
+	assert(not forceSecure or type(forceSecure) == "boolean")
+	assert(usage)
+
+	-- Error checking Battery!
+	if obj and type(obj) ~= "table" then
+		error(format("%s: 'object' - nil or table expected got %s", usage, type(obj)), 3)
+	end
+	if type(method) ~= "string" then
+		error(format("%s: 'method' - string expected got %s", usage, type(method)), 3)
+	end
+	if type(handler) ~= "string" and type(handler) ~= "function" then
+		error(format("%s: 'handler' - nil, string, or function expected got %s", usage, type(handler)), 3)
+	end
+	if type(handler) == "string" and type(self[handler]) ~= "function" then
+		error(format("%s: 'handler' - Handler specified does not exist at self[handler]", usage), 3)
+	end
+	if script then
+		if not obj or not obj.GetScript or not obj:HasScript(method) then
+			error(format("%s: You can only hook a script on a frame object", usage), 3)
+		end
+		if not secure and obj.IsProtected and obj:IsProtected() and protectedScripts[method] then
+			error(format("Cannot hook secure script %q; Use SecureHookScript(obj, method, [handler]) instead.", method), 3)
+		end
+	else
+		local issecure
+		if obj then
+			issecure = onceSecure[obj] and onceSecure[obj][method] or issecurevariable(obj, method)
+		else
+			issecure = onceSecure[method] or issecurevariable(method)
+		end
+		if issecure then
+			if forceSecure then
+				if obj then
+					onceSecure[obj] = onceSecure[obj] or {}
+					onceSecure[obj][method] = true
+				else
+					onceSecure[method] = true
+				end
+			elseif not secure then
+				error(format("%s: Attempt to hook secure function %s. Use `SecureHook' or add `true' to the argument list to override.", usage, method), 3)
+			end
+		end
+	end
+
+	local uid
+	if obj then
+		uid = registry[self][obj] and registry[self][obj][method]
+	else
+		uid = registry[self][method]
+	end
+
+	if uid then
+		if actives[uid] then
+			-- Only two sane choices exist here.  We either a) error 100% of the time or b) always unhook and then hook
+			-- choice b would likely lead to odd debuging conditions or other mysteries so we're going with a.
+			error(format("Attempting to rehook already active hook %s.", method))
+		end
+
+		if handlers[uid] == handler then -- turn on a decative hook, note enclosures break this ability, small memory leak
+			actives[uid] = true
+			return
+		elseif obj then -- is there any reason not to call unhook instead of doing the following several lines?
+			if self.hooks and self.hooks[obj] then
+				self.hooks[obj][method] = nil
+			end
+			registry[self][obj][method] = nil
+		else
+			if self.hooks then
+				self.hooks[method] = nil
+			end
+			registry[self][method] = nil
+		end
+		handlers[uid], actives[uid], scripts[uid] = nil, nil, nil
+	end
+
+	local orig
+	if script then
+		orig = obj:GetScript(method) or donothing
+	elseif obj then
+		orig = obj[method]
+	else
+		orig = _G[method]
+	end
+
+	if not orig then
+		error(format("%s: Attempting to hook a non existing target", usage), 3)
+	end
+
+	uid = createHook(self, handler, orig, secure, not (raw or secure))
+
+	if obj then
+		self.hooks[obj] = self.hooks[obj] or {}
+		registry[self][obj] = registry[self][obj] or {}
+		registry[self][obj][method] = uid
+
+		if not secure then
+			self.hooks[obj][method] = orig
+		end
+
+		if script then
+			if not secure then
+				obj:SetScript(method, uid)
+			else
+				obj:HookScript(method, uid)
+			end
+		else
+			if not secure then
+				obj[method] = uid
+			else
+				hooksecurefunc(obj, method, uid)
+			end
+		end
+	else
+		registry[self][method] = uid
+
+		if not secure then
+			_G[method] = uid
+			self.hooks[method] = orig
+		else
+			hooksecurefunc(method, uid)
+		end
+	end
+
+	actives[uid], handlers[uid], scripts[uid] = true, handler, script and true or nil
+end
+
+--- Hook a function or a method on an object.
+-- The hook created will be a "safe hook", that means that your handler will be called
+-- before the hooked function ("Pre-Hook"), and you don't have to call the original function yourself,
+-- however you cannot stop the execution of the function, or modify any of the arguments/return values.\\
+-- This type of hook is typically used if you need to know if some function got called, and don't want to modify it.
+-- @paramsig [object], method, [handler], [hookSecure]
+-- @param object The object to hook a method from
+-- @param method If object was specified, the name of the method, or the name of the function to hook.
+-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked function)
+-- @param hookSecure If true, AceHook will allow hooking of secure functions.
+-- @usage
+-- -- create an addon with AceHook embeded
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
+--
+-- function MyAddon:OnEnable()
+--   -- Hook ActionButton_UpdateHotkeys, overwriting the secure status
+--   self:Hook("ActionButton_UpdateHotkeys", true)
+-- end
+--
+-- function MyAddon:ActionButton_UpdateHotkeys(button, type)
+--   print(button:GetName() .. " is updating its HotKey")
+-- end
+function AceHook:Hook(object, method, handler, hookSecure)
+	if type(object) == "string" then
+		method, handler, hookSecure, object = object, method, handler, nil
+	end
+
+	if handler == true then
+		handler, hookSecure = nil, true
+	end
+
+	hook(self, object, method, handler, false, false, false, hookSecure or false, "Usage: Hook([object], method, [handler], [hookSecure])")
+end
+
+--- RawHook a function or a method on an object.
+-- The hook created will be a "raw hook", that means that your handler will completly replace
+-- the original function, and your handler has to call the original function (or not, depending on your intentions).\\
+-- The original function will be stored in `self.hooks[object][method]` or `self.hooks[functionName]` respectively.\\
+-- This type of hook can be used for all purposes, and is usually the most common case when you need to modify arguments
+-- or want to control execution of the original function.
+-- @paramsig [object], method, [handler], [hookSecure]
+-- @param object The object to hook a method from
+-- @param method If object was specified, the name of the method, or the name of the function to hook.
+-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked function)
+-- @param hookSecure If true, AceHook will allow hooking of secure functions.
+-- @usage
+-- -- create an addon with AceHook embeded
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
+--
+-- function MyAddon:OnEnable()
+--   -- Hook ActionButton_UpdateHotkeys, overwriting the secure status
+--   self:RawHook("ActionButton_UpdateHotkeys", true)
+-- end
+--
+-- function MyAddon:ActionButton_UpdateHotkeys(button, type)
+--   if button:GetName() == "MyButton" then
+--     -- do stuff here
+--   else
+--     self.hooks.ActionButton_UpdateHotkeys(button, type)
+--   end
+-- end
+function AceHook:RawHook(object, method, handler, hookSecure)
+	if type(object) == "string" then
+		method, handler, hookSecure, object = object, method, handler, nil
+	end
+
+	if handler == true then
+		handler, hookSecure = nil, true
+	end
+
+	hook(self, object, method, handler, false, false, true, hookSecure or false,  "Usage: RawHook([object], method, [handler], [hookSecure])")
+end
+
+--- SecureHook a function or a method on an object.
+-- This function is a wrapper around the `hooksecurefunc` function in the WoW API. Using AceHook
+-- extends the functionality of secure hooks, and adds the ability to unhook once the hook isn't
+-- required anymore, or the addon is being disabled.\\
+-- Secure Hooks should be used if the secure-status of the function is vital to its function,
+-- and taint would block execution. Secure Hooks are always called after the original function was called
+-- ("Post Hook"), and you cannot modify the arguments, return values or control the execution.
+-- @paramsig [object], method, [handler]
+-- @param object The object to hook a method from
+-- @param method If object was specified, the name of the method, or the name of the function to hook.
+-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked function)
+function AceHook:SecureHook(object, method, handler)
+	if type(object) == "string" then
+		method, handler, object = object, method, nil
+	end
+
+	hook(self, object, method, handler, false, true, false, false,  "Usage: SecureHook([object], method, [handler])")
+end
+
+--- Hook a script handler on a frame.
+-- The hook created will be a "safe hook", that means that your handler will be called
+-- before the hooked script ("Pre-Hook"), and you don't have to call the original function yourself,
+-- however you cannot stop the execution of the function, or modify any of the arguments/return values.\\
+-- This is the frame script equivalent of the :Hook safe-hook. It would typically be used to be notified
+-- when a certain event happens to a frame.
+-- @paramsig frame, script, [handler]
+-- @param frame The Frame to hook the script on
+-- @param script The script to hook
+-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked script)
+-- @usage
+-- -- create an addon with AceHook embeded
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
+--
+-- function MyAddon:OnEnable()
+--   -- Hook the OnShow of FriendsFrame
+--   self:HookScript(FriendsFrame, "OnShow", "FriendsFrameOnShow")
+-- end
+--
+-- function MyAddon:FriendsFrameOnShow(frame)
+--   print("The FriendsFrame was shown!")
+-- end
+function AceHook:HookScript(frame, script, handler)
+	hook(self, frame, script, handler, true, false, false, false,  "Usage: HookScript(object, method, [handler])")
+end
+
+--- RawHook a script handler on a frame.
+-- The hook created will be a "raw hook", that means that your handler will completly replace
+-- the original script, and your handler has to call the original script (or not, depending on your intentions).\\
+-- The original script will be stored in `self.hooks[frame][script]`.\\
+-- This type of hook can be used for all purposes, and is usually the most common case when you need to modify arguments
+-- or want to control execution of the original script.
+-- @paramsig frame, script, [handler]
+-- @param frame The Frame to hook the script on
+-- @param script The script to hook
+-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked script)
+-- @usage
+-- -- create an addon with AceHook embeded
+-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
+--
+-- function MyAddon:OnEnable()
+--   -- Hook the OnShow of FriendsFrame
+--   self:RawHookScript(FriendsFrame, "OnShow", "FriendsFrameOnShow")
+-- end
+--
+-- function MyAddon:FriendsFrameOnShow(frame)
+--   -- Call the original function
+--   self.hooks[frame].OnShow(frame)
+--   -- Do our processing
+--   -- .. stuff
+-- end
+function AceHook:RawHookScript(frame, script, handler)
+	hook(self, frame, script, handler, true, false, true, false, "Usage: RawHookScript(object, method, [handler])")
+end
+
+--- SecureHook a script handler on a frame.
+-- This function is a wrapper around the `frame:HookScript` function in the WoW API. Using AceHook
+-- extends the functionality of secure hooks, and adds the ability to unhook once the hook isn't
+-- required anymore, or the addon is being disabled.\\
+-- Secure Hooks should be used if the secure-status of the function is vital to its function,
+-- and taint would block execution. Secure Hooks are always called after the original function was called
+-- ("Post Hook"), and you cannot modify the arguments, return values or control the execution.
+-- @paramsig frame, script, [handler]
+-- @param frame The Frame to hook the script on
+-- @param script The script to hook
+-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked script)
+function AceHook:SecureHookScript(frame, script, handler)
+	hook(self, frame, script, handler, true, true, false, false, "Usage: SecureHookScript(object, method, [handler])")
+end
+
+--- Unhook from the specified function, method or script.
+-- @paramsig [obj], method
+-- @param obj The object or frame to unhook from
+-- @param method The name of the method, function or script to unhook from.
+function AceHook:Unhook(obj, method)
+	local usage = "Usage: Unhook([obj], method)"
+	if type(obj) == "string" then
+		method, obj = obj, nil
+	end
+
+	if obj and type(obj) ~= "table" then
+		error(format("%s: 'obj' - expecting nil or table got %s", usage, type(obj)), 2)
+	end
+	if type(method) ~= "string" then
+		error(format("%s: 'method' - expeting string got %s", usage, type(method)), 2)
+	end
+
+	local uid
+	if obj then
+		uid = registry[self][obj] and registry[self][obj][method]
+	else
+		uid = registry[self][method]
+	end
+
+	if not uid or not actives[uid] then
+		-- Declining to error on an unneeded unhook since the end effect is the same and this would just be annoying.
+		return false
+	end
+
+	actives[uid], handlers[uid] = nil, nil
+
+	if obj then
+		registry[self][obj][method] = nil
+		registry[self][obj] = next(registry[self][obj]) and registry[self][obj] or nil
+
+		-- if the hook reference doesnt exist, then its a secure hook, just bail out and dont do any unhooking
+		if not self.hooks[obj] or not self.hooks[obj][method] then return true end
+
+		if scripts[uid] and obj:GetScript(method) == uid then  -- unhooks scripts
+			obj:SetScript(method, self.hooks[obj][method] ~= donothing and self.hooks[obj][method] or nil)
+			scripts[uid] = nil
+		elseif obj and self.hooks[obj] and self.hooks[obj][method] and obj[method] == uid then -- unhooks methods
+			obj[method] = self.hooks[obj][method]
+		end
+
+		self.hooks[obj][method] = nil
+		self.hooks[obj] = next(self.hooks[obj]) and self.hooks[obj] or nil
+	else
+		registry[self][method] = nil
+
+		-- if self.hooks[method] doesn't exist, then this is a SecureHook, just bail out
+		if not self.hooks[method] then return true end
+
+		if self.hooks[method] and _G[method] == uid then -- unhooks functions
+			_G[method] = self.hooks[method]
+		end
+
+		self.hooks[method] = nil
+	end
+	return true
+end
+
+--- Unhook all existing hooks for this addon.
+function AceHook:UnhookAll()
+	for key, value in pairs(registry[self]) do
+		if type(key) == "table" then
+			for method in pairs(value) do
+				AceHook.Unhook(self, key, method)
+			end
+		else
+			AceHook.Unhook(self, key)
+		end
+	end
+end
+
+--- Check if the specific function, method or script is already hooked.
+-- @paramsig [obj], method
+-- @param obj The object or frame to unhook from
+-- @param method The name of the method, function or script to unhook from.
+function AceHook:IsHooked(obj, method)
+	-- we don't check if registry[self] exists, this is done by evil magicks in the metatable
+	if type(obj) == "string" then
+		if registry[self][obj] and actives[registry[self][obj]] then
+			return true, handlers[registry[self][obj]]
+		end
+	else
+		if registry[self][obj] and registry[self][obj][method] and actives[registry[self][obj][method]] then
+			return true, handlers[registry[self][obj][method]]
+		end
+	end
+
+	return false, nil
+end
+
+--- Upgrade our old embeded
+for target, v in pairs( AceHook.embeded ) do
+	AceHook:Embed( target )
+end
diff --git a/Carbonite/Libs/AceHook-3.0/AceHook-3.0.xml b/Carbonite/Libs/AceHook-3.0/AceHook-3.0.xml
index ea2ae25..fe51336 100644
--- a/Carbonite/Libs/AceHook-3.0/AceHook-3.0.xml
+++ b/Carbonite/Libs/AceHook-3.0/AceHook-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceHook-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceHook-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceLocale-3.0/AceLocale-3.0.lua b/Carbonite/Libs/AceLocale-3.0/AceLocale-3.0.lua
index e67f82c..d69aa73 100644
--- a/Carbonite/Libs/AceLocale-3.0/AceLocale-3.0.lua
+++ b/Carbonite/Libs/AceLocale-3.0/AceLocale-3.0.lua
@@ -1,133 +1,133 @@
---- **AceLocale-3.0** manages localization in addons, allowing for multiple locale to be registered with fallback to the base locale for untranslated strings.
--- @class file
--- @name AceLocale-3.0
--- @release $Id: AceLocale-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
-local MAJOR,MINOR = "AceLocale-3.0", 6
-
-local AceLocale, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceLocale then return end -- no upgrade needed
-
--- Lua APIs
-local assert, tostring, error = assert, tostring, error
-local getmetatable, setmetatable, rawset, rawget = getmetatable, setmetatable, rawset, rawget
-
-local gameLocale = GetLocale()
-if gameLocale == "enGB" then
-	gameLocale = "enUS"
-end
-
-AceLocale.apps = AceLocale.apps or {}          -- array of ["AppName"]=localetableref
-AceLocale.appnames = AceLocale.appnames or {}  -- array of [localetableref]="AppName"
-
--- This metatable is used on all tables returned from GetLocale
-local readmeta = {
-	__index = function(self, key) -- requesting totally unknown entries: fire off a nonbreaking error and return key
-		rawset(self, key, key)      -- only need to see the warning once, really
-		geterrorhandler()(MAJOR..": "..tostring(AceLocale.appnames[self])..": Missing entry for '"..tostring(key).."'")
-		return key
-	end
-}
-
--- This metatable is used on all tables returned from GetLocale if the silent flag is true, it does not issue a warning on unknown keys
-local readmetasilent = {
-	__index = function(self, key) -- requesting totally unknown entries: return key
-		rawset(self, key, key)      -- only need to invoke this function once
-		return key
-	end
-}
-
--- Remember the locale table being registered right now (it gets set by :NewLocale())
--- NOTE: Do never try to register 2 locale tables at once and mix their definition.
-local registering
-
--- local assert false function
-local assertfalse = function() assert(false) end
-
--- This metatable proxy is used when registering nondefault locales
-local writeproxy = setmetatable({}, {
-	__newindex = function(self, key, value)
-		rawset(registering, key, value == true and key or value) -- assigning values: replace 'true' with key string
-	end,
-	__index = assertfalse
-})
-
--- This metatable proxy is used when registering the default locale.
--- It refuses to overwrite existing values
--- Reason 1: Allows loading locales in any order
--- Reason 2: If 2 modules have the same string, but only the first one to be
---           loaded has a translation for the current locale, the translation
---           doesn't get overwritten.
---
-local writedefaultproxy = setmetatable({}, {
-	__newindex = function(self, key, value)
-		if not rawget(registering, key) then
-			rawset(registering, key, value == true and key or value)
-		end
-	end,
-	__index = assertfalse
-})
-
---- Register a new locale (or extend an existing one) for the specified application.
--- :NewLocale will return a table you can fill your locale into, or nil if the locale isn't needed for the players
--- game locale.
--- @paramsig application, locale[, isDefault[, silent]]
--- @param application Unique name of addon / module
--- @param locale Name of the locale to register, e.g. "enUS", "deDE", etc.
--- @param isDefault If this is the default locale being registered (your addon is written in this language, generally enUS)
--- @param silent If true, the locale will not issue warnings for missing keys. Must be set on the first locale registered. If set to "raw", nils will be returned for unknown keys (no metatable used).
--- @usage
--- -- enUS.lua
--- local L = LibStub("AceLocale-3.0"):NewLocale("TestLocale", "enUS", true)
--- L["string1"] = true
---
--- -- deDE.lua
--- local L = LibStub("AceLocale-3.0"):NewLocale("TestLocale", "deDE")
--- if not L then return end
--- L["string1"] = "Zeichenkette1"
--- @return Locale Table to add localizations to, or nil if the current locale is not required.
-function AceLocale:NewLocale(application, locale, isDefault, silent)
-
-	-- GAME_LOCALE allows translators to test translations of addons without having that wow client installed
-	local activeGameLocale = GAME_LOCALE or gameLocale
-
-	local app = AceLocale.apps[application]
-
-	if silent and app and getmetatable(app) ~= readmetasilent then
-		geterrorhandler()("Usage: NewLocale(application, locale[, isDefault[, silent]]): 'silent' must be specified for the first locale registered")
-	end
-
-	if not app then
-		if silent=="raw" then
-			app = {}
-		else
-			app = setmetatable({}, silent and readmetasilent or readmeta)
-		end
-		AceLocale.apps[application] = app
-		AceLocale.appnames[app] = application
-	end
-
-	if locale ~= activeGameLocale and not isDefault then
-		return -- nop, we don't need these translations
-	end
-
-	registering = app -- remember globally for writeproxy and writedefaultproxy
-
-	if isDefault then
-		return writedefaultproxy
-	end
-
-	return writeproxy
-end
-
---- Returns localizations for the current locale (or default locale if translations are missing).
--- Errors if nothing is registered (spank developer, not just a missing translation)
--- @param application Unique name of addon / module
--- @param silent If true, the locale is optional, silently return nil if it's not found (defaults to false, optional)
--- @return The locale table for the current language.
-function AceLocale:GetLocale(application, silent)
-	if not silent and not AceLocale.apps[application] then
-		error("Usage: GetLocale(application[, silent]): 'application' - No locales registered for '"..tostring(application).."'", 2)
-	end
-	return AceLocale.apps[application]
-end
+--- **AceLocale-3.0** manages localization in addons, allowing for multiple locale to be registered with fallback to the base locale for untranslated strings.
+-- @class file
+-- @name AceLocale-3.0
+-- @release $Id: AceLocale-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
+local MAJOR,MINOR = "AceLocale-3.0", 6
+
+local AceLocale, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceLocale then return end -- no upgrade needed
+
+-- Lua APIs
+local assert, tostring, error = assert, tostring, error
+local getmetatable, setmetatable, rawset, rawget = getmetatable, setmetatable, rawset, rawget
+
+local gameLocale = GetLocale()
+if gameLocale == "enGB" then
+	gameLocale = "enUS"
+end
+
+AceLocale.apps = AceLocale.apps or {}          -- array of ["AppName"]=localetableref
+AceLocale.appnames = AceLocale.appnames or {}  -- array of [localetableref]="AppName"
+
+-- This metatable is used on all tables returned from GetLocale
+local readmeta = {
+	__index = function(self, key) -- requesting totally unknown entries: fire off a nonbreaking error and return key
+		rawset(self, key, key)      -- only need to see the warning once, really
+		geterrorhandler()(MAJOR..": "..tostring(AceLocale.appnames[self])..": Missing entry for '"..tostring(key).."'")
+		return key
+	end
+}
+
+-- This metatable is used on all tables returned from GetLocale if the silent flag is true, it does not issue a warning on unknown keys
+local readmetasilent = {
+	__index = function(self, key) -- requesting totally unknown entries: return key
+		rawset(self, key, key)      -- only need to invoke this function once
+		return key
+	end
+}
+
+-- Remember the locale table being registered right now (it gets set by :NewLocale())
+-- NOTE: Do never try to register 2 locale tables at once and mix their definition.
+local registering
+
+-- local assert false function
+local assertfalse = function() assert(false) end
+
+-- This metatable proxy is used when registering nondefault locales
+local writeproxy = setmetatable({}, {
+	__newindex = function(self, key, value)
+		rawset(registering, key, value == true and key or value) -- assigning values: replace 'true' with key string
+	end,
+	__index = assertfalse
+})
+
+-- This metatable proxy is used when registering the default locale.
+-- It refuses to overwrite existing values
+-- Reason 1: Allows loading locales in any order
+-- Reason 2: If 2 modules have the same string, but only the first one to be
+--           loaded has a translation for the current locale, the translation
+--           doesn't get overwritten.
+--
+local writedefaultproxy = setmetatable({}, {
+	__newindex = function(self, key, value)
+		if not rawget(registering, key) then
+			rawset(registering, key, value == true and key or value)
+		end
+	end,
+	__index = assertfalse
+})
+
+--- Register a new locale (or extend an existing one) for the specified application.
+-- :NewLocale will return a table you can fill your locale into, or nil if the locale isn't needed for the players
+-- game locale.
+-- @paramsig application, locale[, isDefault[, silent]]
+-- @param application Unique name of addon / module
+-- @param locale Name of the locale to register, e.g. "enUS", "deDE", etc.
+-- @param isDefault If this is the default locale being registered (your addon is written in this language, generally enUS)
+-- @param silent If true, the locale will not issue warnings for missing keys. Must be set on the first locale registered. If set to "raw", nils will be returned for unknown keys (no metatable used).
+-- @usage
+-- -- enUS.lua
+-- local L = LibStub("AceLocale-3.0"):NewLocale("TestLocale", "enUS", true)
+-- L["string1"] = true
+--
+-- -- deDE.lua
+-- local L = LibStub("AceLocale-3.0"):NewLocale("TestLocale", "deDE")
+-- if not L then return end
+-- L["string1"] = "Zeichenkette1"
+-- @return Locale Table to add localizations to, or nil if the current locale is not required.
+function AceLocale:NewLocale(application, locale, isDefault, silent)
+
+	-- GAME_LOCALE allows translators to test translations of addons without having that wow client installed
+	local activeGameLocale = GAME_LOCALE or gameLocale
+
+	local app = AceLocale.apps[application]
+
+	if silent and app and getmetatable(app) ~= readmetasilent then
+		geterrorhandler()("Usage: NewLocale(application, locale[, isDefault[, silent]]): 'silent' must be specified for the first locale registered")
+	end
+
+	if not app then
+		if silent=="raw" then
+			app = {}
+		else
+			app = setmetatable({}, silent and readmetasilent or readmeta)
+		end
+		AceLocale.apps[application] = app
+		AceLocale.appnames[app] = application
+	end
+
+	if locale ~= activeGameLocale and not isDefault then
+		return -- nop, we don't need these translations
+	end
+
+	registering = app -- remember globally for writeproxy and writedefaultproxy
+
+	if isDefault then
+		return writedefaultproxy
+	end
+
+	return writeproxy
+end
+
+--- Returns localizations for the current locale (or default locale if translations are missing).
+-- Errors if nothing is registered (spank developer, not just a missing translation)
+-- @param application Unique name of addon / module
+-- @param silent If true, the locale is optional, silently return nil if it's not found (defaults to false, optional)
+-- @return The locale table for the current language.
+function AceLocale:GetLocale(application, silent)
+	if not silent and not AceLocale.apps[application] then
+		error("Usage: GetLocale(application[, silent]): 'application' - No locales registered for '"..tostring(application).."'", 2)
+	end
+	return AceLocale.apps[application]
+end
diff --git a/Carbonite/Libs/AceLocale-3.0/AceLocale-3.0.xml b/Carbonite/Libs/AceLocale-3.0/AceLocale-3.0.xml
index a4cf340..bf023f0 100644
--- a/Carbonite/Libs/AceLocale-3.0/AceLocale-3.0.xml
+++ b/Carbonite/Libs/AceLocale-3.0/AceLocale-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceLocale-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceLocale-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceSerializer-3.0/AceSerializer-3.0.lua b/Carbonite/Libs/AceSerializer-3.0/AceSerializer-3.0.lua
index 74dbe6b..25b3fb1 100644
--- a/Carbonite/Libs/AceSerializer-3.0/AceSerializer-3.0.lua
+++ b/Carbonite/Libs/AceSerializer-3.0/AceSerializer-3.0.lua
@@ -1,287 +1,287 @@
---- **AceSerializer-3.0** can serialize any variable (except functions or userdata) into a string format,
--- that can be send over the addon comm channel. AceSerializer was designed to keep all data intact, especially
--- very large numbers or floating point numbers, and table structures. The only caveat currently is, that multiple
--- references to the same table will be send individually.
---
--- **AceSerializer-3.0** can be embeded into your addon, either explicitly by calling AceSerializer:Embed(MyAddon) or by
--- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
--- and can be accessed directly, without having to explicitly call AceSerializer itself.\\
--- It is recommended to embed AceSerializer, otherwise you'll have to specify a custom `self` on all calls you
--- make into AceSerializer.
--- @class file
--- @name AceSerializer-3.0
--- @release $Id: AceSerializer-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
-local MAJOR,MINOR = "AceSerializer-3.0", 5
-local AceSerializer, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceSerializer then return end
-
--- Lua APIs
-local strbyte, strchar, gsub, gmatch, format = string.byte, string.char, string.gsub, string.gmatch, string.format
-local assert, error, pcall = assert, error, pcall
-local type, tostring, tonumber = type, tostring, tonumber
-local pairs, select, frexp = pairs, select, math.frexp
-local tconcat = table.concat
-
--- quick copies of string representations of wonky numbers
-local inf = math.huge
-
-local serNaN  -- can't do this in 4.3, see ace3 ticket 268
-local serInf, serInfMac = "1.#INF", "inf"
-local serNegInf, serNegInfMac = "-1.#INF", "-inf"
-
-
--- Serialization functions
-
-local function SerializeStringHelper(ch)	-- Used by SerializeValue for strings
-	-- We use \126 ("~") as an escape character for all nonprints plus a few more
-	local n = strbyte(ch)
-	if n==30 then           -- v3 / ticket 115: catch a nonprint that ends up being "~^" when encoded... DOH
-		return "\126\122"
-	elseif n<=32 then 			-- nonprint + space
-		return "\126"..strchar(n+64)
-	elseif n==94 then		-- value separator
-		return "\126\125"
-	elseif n==126 then		-- our own escape character
-		return "\126\124"
-	elseif n==127 then		-- nonprint (DEL)
-		return "\126\123"
-	else
-		assert(false)	-- can't be reached if caller uses a sane regex
-	end
-end
-
-local function SerializeValue(v, res, nres)
-	-- We use "^" as a value separator, followed by one byte for type indicator
-	local t=type(v)
-
-	if t=="string" then		-- ^S = string (escaped to remove nonprints, "^"s, etc)
-		res[nres+1] = "^S"
-		res[nres+2] = gsub(v,"[%c \94\126\127]", SerializeStringHelper)
-		nres=nres+2
-
-	elseif t=="number" then	-- ^N = number (just tostring()ed) or ^F (float components)
-		local str = tostring(v)
-		if tonumber(str)==v  --[[not in 4.3 or str==serNaN]] then
-			-- translates just fine, transmit as-is
-			res[nres+1] = "^N"
-			res[nres+2] = str
-			nres=nres+2
-		elseif v == inf or v == -inf then
-			res[nres+1] = "^N"
-			res[nres+2] = v == inf and serInf or serNegInf
-			nres=nres+2
-		else
-			local m,e = frexp(v)
-			res[nres+1] = "^F"
-			res[nres+2] = format("%.0f",m*2^53)	-- force mantissa to become integer (it's originally 0.5--0.9999)
-			res[nres+3] = "^f"
-			res[nres+4] = tostring(e-53)	-- adjust exponent to counteract mantissa manipulation
-			nres=nres+4
-		end
-
-	elseif t=="table" then	-- ^T...^t = table (list of key,value pairs)
-		nres=nres+1
-		res[nres] = "^T"
-		for key,value in pairs(v) do
-			nres = SerializeValue(key, res, nres)
-			nres = SerializeValue(value, res, nres)
-		end
-		nres=nres+1
-		res[nres] = "^t"
-
-	elseif t=="boolean" then	-- ^B = true, ^b = false
-		nres=nres+1
-		if v then
-			res[nres] = "^B"	-- true
-		else
-			res[nres] = "^b"	-- false
-		end
-
-	elseif t=="nil" then		-- ^Z = nil (zero, "N" was taken :P)
-		nres=nres+1
-		res[nres] = "^Z"
-
-	else
-		error(MAJOR..": Cannot serialize a value of type '"..t.."'")	-- can't produce error on right level, this is wildly recursive
-	end
-
-	return nres
-end
-
-
-
-local serializeTbl = { "^1" }	-- "^1" = Hi, I'm data serialized by AceSerializer protocol rev 1
-
---- Serialize the data passed into the function.
--- Takes a list of values (strings, numbers, booleans, nils, tables)
--- and returns it in serialized form (a string).\\
--- May throw errors on invalid data types.
--- @param ... List of values to serialize
--- @return The data in its serialized form (string)
-function AceSerializer:Serialize(...)
-	local nres = 1
-
-	for i=1,select("#", ...) do
-		local v = select(i, ...)
-		nres = SerializeValue(v, serializeTbl, nres)
-	end
-
-	serializeTbl[nres+1] = "^^"	-- "^^" = End of serialized data
-
-	return tconcat(serializeTbl, "", 1, nres+1)
-end
-
--- Deserialization functions
-local function DeserializeStringHelper(escape)
-	if escape<"~\122" then
-		return strchar(strbyte(escape,2,2)-64)
-	elseif escape=="~\122" then	-- v3 / ticket 115: special case encode since 30+64=94 ("^") - OOPS.
-		return "\030"
-	elseif escape=="~\123" then
-		return "\127"
-	elseif escape=="~\124" then
-		return "\126"
-	elseif escape=="~\125" then
-		return "\94"
-	end
-	error("DeserializeStringHelper got called for '"..escape.."'?!?")  -- can't be reached unless regex is screwed up
-end
-
-local function DeserializeNumberHelper(number)
-	--[[ not in 4.3 if number == serNaN then
-		return 0/0
-	else]]if number == serNegInf or number == serNegInfMac then
-		return -inf
-	elseif number == serInf or number == serInfMac then
-		return inf
-	else
-		return tonumber(number)
-	end
-end
-
--- DeserializeValue: worker function for :Deserialize()
--- It works in two modes:
---   Main (top-level) mode: Deserialize a list of values and return them all
---   Recursive (table) mode: Deserialize only a single value (_may_ of course be another table with lots of subvalues in it)
---
--- The function _always_ works recursively due to having to build a list of values to return
---
--- Callers are expected to pcall(DeserializeValue) to trap errors
-
-local function DeserializeValue(iter,single,ctl,data)
-
-	if not single then
-		ctl,data = iter()
-	end
-
-	if not ctl then
-		error("Supplied data misses AceSerializer terminator ('^^')")
-	end
-
-	if ctl=="^^" then
-		-- ignore extraneous data
-		return
-	end
-
-	local res
-
-	if ctl=="^S" then
-		res = gsub(data, "~.", DeserializeStringHelper)
-	elseif ctl=="^N" then
-		res = DeserializeNumberHelper(data)
-		if not res then
-			error("Invalid serialized number: '"..tostring(data).."'")
-		end
-	elseif ctl=="^F" then     -- ^F<mantissa>^f<exponent>
-		local ctl2,e = iter()
-		if ctl2~="^f" then
-			error("Invalid serialized floating-point number, expected '^f', not '"..tostring(ctl2).."'")
-		end
-		local m=tonumber(data)
-		e=tonumber(e)
-		if not (m and e) then
-			error("Invalid serialized floating-point number, expected mantissa and exponent, got '"..tostring(m).."' and '"..tostring(e).."'")
-		end
-		res = m*(2^e)
-	elseif ctl=="^B" then	-- yeah yeah ignore data portion
-		res = true
-	elseif ctl=="^b" then   -- yeah yeah ignore data portion
-		res = false
-	elseif ctl=="^Z" then	-- yeah yeah ignore data portion
-		res = nil
-	elseif ctl=="^T" then
-		-- ignore ^T's data, future extensibility?
-		res = {}
-		local k,v
-		while true do
-			ctl,data = iter()
-			if ctl=="^t" then break end	-- ignore ^t's data
-			k = DeserializeValue(iter,true,ctl,data)
-			if k==nil then
-				error("Invalid AceSerializer table format (no table end marker)")
-			end
-			ctl,data = iter()
-			v = DeserializeValue(iter,true,ctl,data)
-			if v==nil then
-				error("Invalid AceSerializer table format (no table end marker)")
-			end
-			res[k]=v
-		end
-	else
-		error("Invalid AceSerializer control code '"..ctl.."'")
-	end
-
-	if not single then
-		return res,DeserializeValue(iter)
-	else
-		return res
-	end
-end
-
---- Deserializes the data into its original values.
--- Accepts serialized data, ignoring all control characters and whitespace.
--- @param str The serialized data (from :Serialize)
--- @return true followed by a list of values, OR false followed by an error message
-function AceSerializer:Deserialize(str)
-	str = gsub(str, "[%c ]", "")	-- ignore all control characters; nice for embedding in email and stuff
-
-	local iter = gmatch(str, "(^.)([^^]*)")	-- Any ^x followed by string of non-^
-	local ctl,data = iter()
-	if not ctl or ctl~="^1" then
-		-- we purposefully ignore the data portion of the start code, it can be used as an extension mechanism
-		return false, "Supplied data is not AceSerializer data (rev 1)"
-	end
-
-	return pcall(DeserializeValue, iter)
-end
-
-
-----------------------------------------
--- Base library stuff
-----------------------------------------
-
-AceSerializer.internals = {	-- for test scripts
-	SerializeValue = SerializeValue,
-	SerializeStringHelper = SerializeStringHelper,
-}
-
-local mixins = {
-	"Serialize",
-	"Deserialize",
-}
-
-AceSerializer.embeds = AceSerializer.embeds or {}
-
-function AceSerializer:Embed(target)
-	for k, v in pairs(mixins) do
-		target[v] = self[v]
-	end
-	self.embeds[target] = true
-	return target
-end
-
--- Update embeds
-for target, v in pairs(AceSerializer.embeds) do
-	AceSerializer:Embed(target)
-end
+--- **AceSerializer-3.0** can serialize any variable (except functions or userdata) into a string format,
+-- that can be send over the addon comm channel. AceSerializer was designed to keep all data intact, especially
+-- very large numbers or floating point numbers, and table structures. The only caveat currently is, that multiple
+-- references to the same table will be send individually.
+--
+-- **AceSerializer-3.0** can be embeded into your addon, either explicitly by calling AceSerializer:Embed(MyAddon) or by
+-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
+-- and can be accessed directly, without having to explicitly call AceSerializer itself.\\
+-- It is recommended to embed AceSerializer, otherwise you'll have to specify a custom `self` on all calls you
+-- make into AceSerializer.
+-- @class file
+-- @name AceSerializer-3.0
+-- @release $Id: AceSerializer-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
+local MAJOR,MINOR = "AceSerializer-3.0", 5
+local AceSerializer, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceSerializer then return end
+
+-- Lua APIs
+local strbyte, strchar, gsub, gmatch, format = string.byte, string.char, string.gsub, string.gmatch, string.format
+local assert, error, pcall = assert, error, pcall
+local type, tostring, tonumber = type, tostring, tonumber
+local pairs, select, frexp = pairs, select, math.frexp
+local tconcat = table.concat
+
+-- quick copies of string representations of wonky numbers
+local inf = math.huge
+
+local serNaN  -- can't do this in 4.3, see ace3 ticket 268
+local serInf, serInfMac = "1.#INF", "inf"
+local serNegInf, serNegInfMac = "-1.#INF", "-inf"
+
+
+-- Serialization functions
+
+local function SerializeStringHelper(ch)	-- Used by SerializeValue for strings
+	-- We use \126 ("~") as an escape character for all nonprints plus a few more
+	local n = strbyte(ch)
+	if n==30 then           -- v3 / ticket 115: catch a nonprint that ends up being "~^" when encoded... DOH
+		return "\126\122"
+	elseif n<=32 then 			-- nonprint + space
+		return "\126"..strchar(n+64)
+	elseif n==94 then		-- value separator
+		return "\126\125"
+	elseif n==126 then		-- our own escape character
+		return "\126\124"
+	elseif n==127 then		-- nonprint (DEL)
+		return "\126\123"
+	else
+		assert(false)	-- can't be reached if caller uses a sane regex
+	end
+end
+
+local function SerializeValue(v, res, nres)
+	-- We use "^" as a value separator, followed by one byte for type indicator
+	local t=type(v)
+
+	if t=="string" then		-- ^S = string (escaped to remove nonprints, "^"s, etc)
+		res[nres+1] = "^S"
+		res[nres+2] = gsub(v,"[%c \94\126\127]", SerializeStringHelper)
+		nres=nres+2
+
+	elseif t=="number" then	-- ^N = number (just tostring()ed) or ^F (float components)
+		local str = tostring(v)
+		if tonumber(str)==v  --[[not in 4.3 or str==serNaN]] then
+			-- translates just fine, transmit as-is
+			res[nres+1] = "^N"
+			res[nres+2] = str
+			nres=nres+2
+		elseif v == inf or v == -inf then
+			res[nres+1] = "^N"
+			res[nres+2] = v == inf and serInf or serNegInf
+			nres=nres+2
+		else
+			local m,e = frexp(v)
+			res[nres+1] = "^F"
+			res[nres+2] = format("%.0f",m*2^53)	-- force mantissa to become integer (it's originally 0.5--0.9999)
+			res[nres+3] = "^f"
+			res[nres+4] = tostring(e-53)	-- adjust exponent to counteract mantissa manipulation
+			nres=nres+4
+		end
+
+	elseif t=="table" then	-- ^T...^t = table (list of key,value pairs)
+		nres=nres+1
+		res[nres] = "^T"
+		for key,value in pairs(v) do
+			nres = SerializeValue(key, res, nres)
+			nres = SerializeValue(value, res, nres)
+		end
+		nres=nres+1
+		res[nres] = "^t"
+
+	elseif t=="boolean" then	-- ^B = true, ^b = false
+		nres=nres+1
+		if v then
+			res[nres] = "^B"	-- true
+		else
+			res[nres] = "^b"	-- false
+		end
+
+	elseif t=="nil" then		-- ^Z = nil (zero, "N" was taken :P)
+		nres=nres+1
+		res[nres] = "^Z"
+
+	else
+		error(MAJOR..": Cannot serialize a value of type '"..t.."'")	-- can't produce error on right level, this is wildly recursive
+	end
+
+	return nres
+end
+
+
+
+local serializeTbl = { "^1" }	-- "^1" = Hi, I'm data serialized by AceSerializer protocol rev 1
+
+--- Serialize the data passed into the function.
+-- Takes a list of values (strings, numbers, booleans, nils, tables)
+-- and returns it in serialized form (a string).\\
+-- May throw errors on invalid data types.
+-- @param ... List of values to serialize
+-- @return The data in its serialized form (string)
+function AceSerializer:Serialize(...)
+	local nres = 1
+
+	for i=1,select("#", ...) do
+		local v = select(i, ...)
+		nres = SerializeValue(v, serializeTbl, nres)
+	end
+
+	serializeTbl[nres+1] = "^^"	-- "^^" = End of serialized data
+
+	return tconcat(serializeTbl, "", 1, nres+1)
+end
+
+-- Deserialization functions
+local function DeserializeStringHelper(escape)
+	if escape<"~\122" then
+		return strchar(strbyte(escape,2,2)-64)
+	elseif escape=="~\122" then	-- v3 / ticket 115: special case encode since 30+64=94 ("^") - OOPS.
+		return "\030"
+	elseif escape=="~\123" then
+		return "\127"
+	elseif escape=="~\124" then
+		return "\126"
+	elseif escape=="~\125" then
+		return "\94"
+	end
+	error("DeserializeStringHelper got called for '"..escape.."'?!?")  -- can't be reached unless regex is screwed up
+end
+
+local function DeserializeNumberHelper(number)
+	--[[ not in 4.3 if number == serNaN then
+		return 0/0
+	else]]if number == serNegInf or number == serNegInfMac then
+		return -inf
+	elseif number == serInf or number == serInfMac then
+		return inf
+	else
+		return tonumber(number)
+	end
+end
+
+-- DeserializeValue: worker function for :Deserialize()
+-- It works in two modes:
+--   Main (top-level) mode: Deserialize a list of values and return them all
+--   Recursive (table) mode: Deserialize only a single value (_may_ of course be another table with lots of subvalues in it)
+--
+-- The function _always_ works recursively due to having to build a list of values to return
+--
+-- Callers are expected to pcall(DeserializeValue) to trap errors
+
+local function DeserializeValue(iter,single,ctl,data)
+
+	if not single then
+		ctl,data = iter()
+	end
+
+	if not ctl then
+		error("Supplied data misses AceSerializer terminator ('^^')")
+	end
+
+	if ctl=="^^" then
+		-- ignore extraneous data
+		return
+	end
+
+	local res
+
+	if ctl=="^S" then
+		res = gsub(data, "~.", DeserializeStringHelper)
+	elseif ctl=="^N" then
+		res = DeserializeNumberHelper(data)
+		if not res then
+			error("Invalid serialized number: '"..tostring(data).."'")
+		end
+	elseif ctl=="^F" then     -- ^F<mantissa>^f<exponent>
+		local ctl2,e = iter()
+		if ctl2~="^f" then
+			error("Invalid serialized floating-point number, expected '^f', not '"..tostring(ctl2).."'")
+		end
+		local m=tonumber(data)
+		e=tonumber(e)
+		if not (m and e) then
+			error("Invalid serialized floating-point number, expected mantissa and exponent, got '"..tostring(m).."' and '"..tostring(e).."'")
+		end
+		res = m*(2^e)
+	elseif ctl=="^B" then	-- yeah yeah ignore data portion
+		res = true
+	elseif ctl=="^b" then   -- yeah yeah ignore data portion
+		res = false
+	elseif ctl=="^Z" then	-- yeah yeah ignore data portion
+		res = nil
+	elseif ctl=="^T" then
+		-- ignore ^T's data, future extensibility?
+		res = {}
+		local k,v
+		while true do
+			ctl,data = iter()
+			if ctl=="^t" then break end	-- ignore ^t's data
+			k = DeserializeValue(iter,true,ctl,data)
+			if k==nil then
+				error("Invalid AceSerializer table format (no table end marker)")
+			end
+			ctl,data = iter()
+			v = DeserializeValue(iter,true,ctl,data)
+			if v==nil then
+				error("Invalid AceSerializer table format (no table end marker)")
+			end
+			res[k]=v
+		end
+	else
+		error("Invalid AceSerializer control code '"..ctl.."'")
+	end
+
+	if not single then
+		return res,DeserializeValue(iter)
+	else
+		return res
+	end
+end
+
+--- Deserializes the data into its original values.
+-- Accepts serialized data, ignoring all control characters and whitespace.
+-- @param str The serialized data (from :Serialize)
+-- @return true followed by a list of values, OR false followed by an error message
+function AceSerializer:Deserialize(str)
+	str = gsub(str, "[%c ]", "")	-- ignore all control characters; nice for embedding in email and stuff
+
+	local iter = gmatch(str, "(^.)([^^]*)")	-- Any ^x followed by string of non-^
+	local ctl,data = iter()
+	if not ctl or ctl~="^1" then
+		-- we purposefully ignore the data portion of the start code, it can be used as an extension mechanism
+		return false, "Supplied data is not AceSerializer data (rev 1)"
+	end
+
+	return pcall(DeserializeValue, iter)
+end
+
+
+----------------------------------------
+-- Base library stuff
+----------------------------------------
+
+AceSerializer.internals = {	-- for test scripts
+	SerializeValue = SerializeValue,
+	SerializeStringHelper = SerializeStringHelper,
+}
+
+local mixins = {
+	"Serialize",
+	"Deserialize",
+}
+
+AceSerializer.embeds = AceSerializer.embeds or {}
+
+function AceSerializer:Embed(target)
+	for k, v in pairs(mixins) do
+		target[v] = self[v]
+	end
+	self.embeds[target] = true
+	return target
+end
+
+-- Update embeds
+for target, v in pairs(AceSerializer.embeds) do
+	AceSerializer:Embed(target)
+end
diff --git a/Carbonite/Libs/AceSerializer-3.0/AceSerializer-3.0.xml b/Carbonite/Libs/AceSerializer-3.0/AceSerializer-3.0.xml
index f44106d..677d08e 100644
--- a/Carbonite/Libs/AceSerializer-3.0/AceSerializer-3.0.xml
+++ b/Carbonite/Libs/AceSerializer-3.0/AceSerializer-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceSerializer-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceSerializer-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceTab-3.0/AceTab-3.0.lua b/Carbonite/Libs/AceTab-3.0/AceTab-3.0.lua
index b4fb963..fd0bc2f 100644
--- a/Carbonite/Libs/AceTab-3.0/AceTab-3.0.lua
+++ b/Carbonite/Libs/AceTab-3.0/AceTab-3.0.lua
@@ -1,441 +1,441 @@
---- AceTab-3.0 provides support for tab-completion.
--- Note: This library is not yet finalized.
--- @class file
--- @name AceTab-3.0
--- @release $Id: AceTab-3.0.lua 1287 2022-09-25 09:15:57Z nevcairiel $
-
-local ACETAB_MAJOR, ACETAB_MINOR = 'AceTab-3.0', 9
-local AceTab, oldminor = LibStub:NewLibrary(ACETAB_MAJOR, ACETAB_MINOR)
-
-if not AceTab then return end -- No upgrade needed
-
-AceTab.registry = AceTab.registry or {}
-
--- local upvalues
-local _G = _G
-local pairs = pairs
-local ipairs = ipairs
-local type = type
-local registry = AceTab.registry
-
-local strfind = string.find
-local strsub = string.sub
-local strlower = string.lower
-local strformat = string.format
-local strmatch = string.match
-
-local function printf(...)
-	DEFAULT_CHAT_FRAME:AddMessage(strformat(...))
-end
-
-local function getTextBeforeCursor(this, start)
-	return strsub(this:GetText(), start or 1, this:GetCursorPosition())
-end
-
--- Hook OnTabPressed and OnTextChanged for the frame, give it an empty matches table, and set its curMatch to 0, if we haven't done so already.
-local function hookFrame(f)
-	if f.hookedByAceTab3 then return end
-	f.hookedByAceTab3 = true
-	if f == ChatEdit_GetActiveWindow() then
-		local origCTP = ChatEdit_CustomTabPressed
-		function ChatEdit_CustomTabPressed(...)
-			if AceTab:OnTabPressed(f) then
-				return origCTP(...)
-			else
-				return true
-			end
-		end
-	else
-		local origOTP = f:GetScript('OnTabPressed')
-		if type(origOTP) ~= 'function' then
-			origOTP = function() end
-		end
-		f:SetScript('OnTabPressed', function(...)
-			if AceTab:OnTabPressed(f) then
-				return origOTP(...)
-			end
-		end)
-	end
-	f.at3curMatch = 0
-	f.at3matches = {}
-end
-
-local fallbacks, notfallbacks = {}, {}  -- classifies completions into those which have preconditions and those which do not.  Those without preconditions are only considered if no other completions have matches.
-local pmolengths = {}  -- holds the number of characters to overwrite according to pmoverwrite and the current prematch
--- ------------------------------------------------------------------------------
--- RegisterTabCompletion( descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite )
--- See http://www.wowace.com/wiki/AceTab-2.0 for detailed API documentation
---
--- descriptor	string					Unique identifier for this tab completion set
---
--- prematches	string|table|nil		String match(es) AFTER which this tab completion will apply.
---										AceTab will ignore tabs NOT preceded by the string(s).
---										If no value is passed, will check all tabs pressed in the specified editframe(s) UNLESS a more-specific tab complete applies.
---
--- wordlist		function|table			Function that will be passed a table into which it will insert strings corresponding to all possible completions, or an equivalent table.
---										The text in the editbox, the position of the start of the word to be completed, and the uncompleted partial word
---										are passed as second, third, and fourth arguments, to facilitate pre-filtering or conditional formatting, if desired.
---
--- usagefunc	function|boolean|nil	Usage statement function.  Defaults to the wordlist, one per line.  A boolean true squelches usage output.
---
--- listenframes	string|table|nil		EditFrames to monitor.  Defaults to ChatFrameEditBox.
---
--- postfunc		function|nil			Post-processing function.  If supplied, matches will be passed through this function after they've been identified as a match.
---
--- pmoverwrite	boolean|number|nil		Offset the beginning of the completion string in the editbox when making a completion.  Passing a boolean true indicates that we want to overwrite
---										the entire prematch string, and passing a number will overwrite that many characters prior to the cursor.
---										This is useful when you want to use the prematch as an indicator character, but ultimately do not want it as part of the text, itself.
---
--- no return
--- ------------------------------------------------------------------------------
-function AceTab:RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite)
-	-- Arg checks
-	if type(descriptor) ~= 'string' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'descriptor' - string expected.", 3) end
-	if prematches and type(prematches) ~= 'string' and type(prematches) ~= 'table' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'prematches' - string, table, or nil expected.", 3) end
-	if type(wordlist) ~= 'function' and type(wordlist) ~= 'table' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'wordlist' - function or table expected.", 3) end
-	if usagefunc and type(usagefunc) ~= 'function' and type(usagefunc) ~= 'boolean' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'usagefunc' - function or boolean expected.", 3) end
-	if listenframes and type(listenframes) ~= 'string' and type(listenframes) ~= 'table' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'listenframes' - string or table expected.", 3) end
-	if postfunc and type(postfunc) ~= 'function' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'postfunc' - function expected.", 3) end
-	if pmoverwrite and type(pmoverwrite) ~= 'boolean' and type(pmoverwrite) ~= 'number' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'pmoverwrite' - boolean or number expected.", 3) end
-
-	local pmtable
-
-	if type(prematches) == 'table' then
-		pmtable = prematches
-		notfallbacks[descriptor] = true
-	else
-		pmtable = {}
-		-- Mark this group as a fallback group if no value was passed.
-		if not prematches then
-			pmtable[1] = ""
-			fallbacks[descriptor] = true
-		-- Make prematches into a one-element table if it was passed as a string.
-		elseif type(prematches) == 'string' then
-			pmtable[1] = prematches
-			if prematches == "" then
-				fallbacks[descriptor] = true
-			else
-				notfallbacks[descriptor] = true
-			end
-		end
-	end
-
-	-- Make listenframes into a one-element table if it was not passed a table of frames.
-	if not listenframes then  -- default
-		listenframes = {}
-		for i = 1, NUM_CHAT_WINDOWS do
-			listenframes[i] = _G["ChatFrame"..i.."EditBox"]
-		end
-	elseif type(listenframes) ~= 'table' or type(listenframes[0]) == 'userdata' and type(listenframes.IsObjectType) == 'function' then  -- single frame or framename
-		listenframes = { listenframes }
-	end
-
-	-- Hook each registered listenframe and give it a matches table.
-	for _, f in pairs(listenframes) do
-		if type(f) == 'string' then
-			f = _G[f]
-		end
-		if type(f) ~= 'table' or type(f[0]) ~= 'userdata' or type(f.IsObjectType) ~= 'function' then
-			error(strformat(ACETAB_MAJOR..": Cannot register frame %q; it does not exist", f:GetName()))
-		end
-		if f then
-			if f:GetObjectType() ~= 'EditBox' then
-				error(strformat(ACETAB_MAJOR..": Cannot register frame %q; it is not an EditBox", f:GetName()))
-			else
-				hookFrame(f)
-			end
-		end
-	end
-
-	-- Everything checks out; register this completion.
-	if not registry[descriptor] then
-		registry[descriptor] = { prematches = pmtable, wordlist = wordlist, usagefunc = usagefunc, listenframes = listenframes, postfunc = postfunc, pmoverwrite = pmoverwrite }
-	end
-end
-
-function AceTab:IsTabCompletionRegistered(descriptor)
-	return registry and registry[descriptor]
-end
-
-function AceTab:UnregisterTabCompletion(descriptor)
-	registry[descriptor] = nil
-	pmolengths[descriptor] = nil
-	fallbacks[descriptor] = nil
-	notfallbacks[descriptor] = nil
-end
-
--- ------------------------------------------------------------------------------
--- gcbs( s1, s2 )
---
--- s1		string		First string to be compared
---
--- s2		string		Second string to be compared
---
--- returns the greatest common substring beginning s1 and s2
--- ------------------------------------------------------------------------------
-local function gcbs(s1, s2)
-	if not s1 and not s2 then return end
-	if not s1 then s1 = s2 end
-	if not s2 then s2 = s1 end
-	if #s2 < #s1 then
-		s1, s2 = s2, s1
-	end
-	if strfind(strlower(s2), "^"..strlower(s1)) then
-		return s1
-	else
-		return gcbs(strsub(s1, 1, -2), s2)
-	end
-end
-
-local cursor  -- Holds cursor position.  Set in :OnTabPressed().
--- ------------------------------------------------------------------------------
--- cycleTab()
--- For when a tab press has multiple possible completions, we need to allow the user to press tab repeatedly to cycle through them.
--- If we have multiple possible completions, all tab presses after the first will call this function to cycle through and insert the different possible matches.
--- This function will stop being called after OnTextChanged() is triggered by something other than AceTab (i.e. the user inputs a character).
--- ------------------------------------------------------------------------------
-local previousLength, cMatch, matched, postmatch
-local function cycleTab(this)
-	cMatch = 0  -- Counter across all sets.  The pseudo-index relevant to this value and corresponding to the current match is held in this.at3curMatch
-	matched = false
-
-	-- Check each completion group registered to this frame.
-	for desc, compgrp in pairs(this.at3matches) do
-
-		-- Loop through the valid completions for this set.
-		for m, pm in pairs(compgrp) do
-			cMatch = cMatch + 1
-			if cMatch == this.at3curMatch then  -- we're back to where we left off last time through the combined list
-				this.at3lastMatch = m
-				this.at3lastWord = pm
-				this.at3curMatch = cMatch + 1 -- save the new cMatch index
-				matched = true
-				break
-			end
-		end
-		if matched then break end
-	end
-
-	-- If our index is beyond the end of the list, reset the original uncompleted substring and let the cycle start over next time tab is pressed.
-	if not matched then
-		this.at3lastMatch = this.at3origMatch
-		this.at3lastWord = this.at3origWord
-		this.at3curMatch = 1
-	end
-
-	-- Insert the completion.
-	this:HighlightText(this.at3matchStart-1, cursor)
-	this:Insert(this.at3lastWord or '')
-	this.at3_last_precursor = getTextBeforeCursor(this) or ''
-end
-
-local IsSecureCmd = IsSecureCmd
-
-local candUsage = {}
-local numMatches = 0
-local firstMatch, hasNonFallback, allGCBS, setGCBS, usage
-local text_precursor, text_all, text_pmendToCursor
-
--- Fill the this.at3matches[descriptor] tables with matching completion pairs for each entry, based on
--- the partial string preceding the cursor position and using the corresponding registered wordlist.
---
--- The entries of the matches tables are of the format raw_match = formatted_match, where raw_match is the plaintext completion and
--- formatted_match is the match after being formatted/altered/processed by the registered postfunc.
--- If no postfunc exists, then the formatted and raw matches are the same.
-local pms, pme, pmt, prematchStart, prematchEnd, text_prematch, entry
-local function fillMatches(this, desc, fallback)
-	entry = registry[desc]
-	-- See what frames are registered for this completion group.  If the frame in which we pressed tab is one of them, then we start building matches.
-	for _, f in ipairs(entry.listenframes) do
-		if f == this then
-
-			-- Try each precondition string registered for this completion group.
-			for _, prematch in ipairs(entry.prematches) do
-
-				-- Test if our prematch string is satisfied.
-				-- If it is, then we find its last occurence prior to the cursor, calculate and store its pmoverwrite value (if applicable), and start considering completions.
-				if fallback then prematch = "%s" end
-
-				-- Find the last occurence of the prematch before the cursor.
-				pms, pme, pmt = nil, 1, ''
-				text_prematch, prematchEnd, prematchStart = nil, nil, nil
-				while true do
-					pms, pme, pmt = strfind(text_precursor, "("..prematch..")", pme)
-					if pms then
-						prematchStart, prematchEnd, text_prematch = pms, pme, pmt
-						pme = pme + 1
-					else
-						break
-					end
-				end
-
-				if not prematchStart and fallback then
-					prematchStart, prematchEnd, text_prematch = 0, 0, ''
-				end
-				if prematchStart then
-					-- text_pmendToCursor should be the sub-word/phrase to be completed.
-					text_pmendToCursor = strsub(text_precursor, prematchEnd + 1)
-
-					-- How many characters should we eliminate before the completion before writing it in.
-					pmolengths[desc] = entry.pmoverwrite == true and #text_prematch or entry.pmoverwrite or 0
-
-					-- This is where we will insert completions, taking the prematch overwrite into account.
-					this.at3matchStart = prematchEnd + 1 - (pmolengths[desc] or 0)
-
-					-- We're either a non-fallback set or all completions thus far have been fallback sets, and the precondition matches.
-					-- Create cands from the registered wordlist, filling it with all potential (unfiltered) completion strings.
-					local wordlist = entry.wordlist
-					local cands = type(wordlist) == 'table' and wordlist or {}
-					if type(wordlist) == 'function' then
-						wordlist(cands, text_all, prematchEnd + 1, text_pmendToCursor)
-					end
-					if cands ~= false then
-						local matches = this.at3matches[desc] or {}
-						for i in pairs(matches) do matches[i] = nil end
-
-						-- Check each of the entries in cands to see if it completes the word before the cursor.
-						-- Finally, increment our match count and set firstMatch, if appropriate.
-						for _, m in ipairs(cands) do
-							if strfind(strlower(m), strlower(text_pmendToCursor), 1, 1) == 1 then  -- we have a matching completion!
-								hasNonFallback = hasNonFallback or (not fallback)
-								matches[m] = entry.postfunc and entry.postfunc(m, prematchEnd + 1, text_all) or m
-								numMatches = numMatches + 1
-								if numMatches == 1 then
-									firstMatch = matches[m]
-								end
-							end
-						end
-						this.at3matches[desc] = numMatches > 0 and matches or nil
-					end
-				end
-			end
-		end
-	end
-end
-
-function AceTab:OnTabPressed(this)
-	if this:GetText() == '' then return true end
-
-	-- allow Blizzard to handle slash commands, themselves
-	if this == ChatEdit_GetActiveWindow() then
-		local command = this:GetText()
-		if strfind(command, "^/[%a%d_]+$") then
-			return true
-		end
-		local cmd = strmatch(command, "^/[%a%d_]+")
-		if cmd and IsSecureCmd(cmd) then
-			return true
-		end
-	end
-
-	cursor = this:GetCursorPosition()
-
-	text_all = this:GetText()
-	text_precursor = getTextBeforeCursor(this) or ''
-
-	-- If we've already found some matches and haven't done anything since the last tab press, then (continue) cycling matches.
-	-- Otherwise, reset this frame's matches and proceed to creating our list of possible completions.
-	this.at3lastMatch = this.at3curMatch > 0 and (this.at3lastMatch or this.at3origWord)
-	-- Detects if we've made any edits since the last tab press.  If not, continue cycling completions.
-	if text_precursor == this.at3_last_precursor then
-		return cycleTab(this)
-	else
-		for i in pairs(this.at3matches) do this.at3matches[i] = nil end
-		this.at3curMatch = 0
-		this.at3origWord = nil
-		this.at3origMatch = nil
-		this.at3lastWord = nil
-		this.at3lastMatch = nil
-		this.at3_last_precursor = text_precursor
-	end
-
-	numMatches = 0
-	firstMatch = nil
-	hasNonFallback = false
-	for i in pairs(pmolengths) do pmolengths[i] = nil end
-
-	for desc in pairs(notfallbacks) do
-		fillMatches(this, desc)
-	end
-	if not hasNonFallback then
-		for desc in pairs(fallbacks) do
-			fillMatches(this, desc, true)
-		end
-	end
-
-	if not firstMatch then
-		this.at3_last_precursor = "\0"
-		return true
-	end
-
-	-- We want to replace the entire word with our completion, so highlight it up to the cursor.
-	-- If only one match exists, then stick it in there and append a space.
-	if numMatches == 1 then
-		-- HighlightText takes the value AFTER which the highlighting starts, so we have to subtract 1 to have it start before the first character.
-		this:HighlightText(this.at3matchStart-1, cursor)
-
-		this:Insert(firstMatch)
-		this:Insert(" ")
-	else
-		-- Otherwise, we want to begin cycling through the valid completions.
-		-- Beginning a cycle also causes the usage statement to be printed, if one exists.
-
-		-- Print usage statements for each possible completion (and gather up the GCBS of all matches while we're walking the tables).
-		allGCBS = nil
-		for desc, matches in pairs(this.at3matches) do
-			-- Don't print usage statements for fallback completion groups if we have 'real' completion groups with matches.
-			if hasNonFallback and fallbacks[desc] then break end
-
-			-- Use the group's description as a heading for its usage statements.
-			DEFAULT_CHAT_FRAME:AddMessage(desc..":")
-
-			local usagefunc = registry[desc].usagefunc
-			if not usagefunc then
-				-- No special usage processing; just print a list of the (formatted) matches.
-				for m, fm in pairs(matches) do
-					DEFAULT_CHAT_FRAME:AddMessage(fm)
-					allGCBS = gcbs(allGCBS, m)
-				end
-			else
-				-- Print a usage statement based on the corresponding registered usagefunc.
-				-- candUsage is the table passed to usagefunc to be filled with candidate = usage_statement pairs.
-				if type(usagefunc) == 'function' then
-					for i in pairs(candUsage) do candUsage[i] = nil end
-
-					-- usagefunc takes the greatest common substring of valid matches as one of its args, so let's find that now.
-					-- TODO: Make the GCBS function accept a vararg or table, after which we can just pass in the list of matches.
-					setGCBS = nil
-					for m in pairs(matches) do
-						setGCBS = gcbs(setGCBS, m)
-					end
-					allGCBS = gcbs(allGCBS, setGCBS)
-					usage = usagefunc(candUsage, matches, setGCBS, strsub(text_precursor, 1, prematchEnd))
-
-					-- If the usagefunc returns a string, then the entire usage statement has been taken care of by usagefunc, and we need only to print it...
-					if type(usage) == 'string' then
-						DEFAULT_CHAT_FRAME:AddMessage(usage)
-
-					-- ...otherwise, it should have filled candUsage with candidate-usage statement pairs, and we need to print the matching ones.
-					elseif next(candUsage) and numMatches > 0 then
-						for m, fm in pairs(matches) do
-							if candUsage[m] then DEFAULT_CHAT_FRAME:AddMessage(strformat("%s - %s", fm, candUsage[m])) end
-						end
-					end
-				end
-			end
-
-			if next(matches) then
-				-- Replace the original string with the greatest common substring of all valid completions.
-				this.at3curMatch = 1
-				this.at3origWord = strsub(text_precursor, this.at3matchStart, this.at3matchStart + pmolengths[desc] - 1) .. allGCBS or ""
-				this.at3origMatch = allGCBS or ""
-				this.at3lastWord = this.at3origWord
-				this.at3lastMatch = this.at3origMatch
-
-				this:HighlightText(this.at3matchStart-1, cursor)
-				this:Insert(this.at3origWord)
-				this.at3_last_precursor = getTextBeforeCursor(this) or ''
-			end
-		end
-	end
-end
+--- AceTab-3.0 provides support for tab-completion.
+-- Note: This library is not yet finalized.
+-- @class file
+-- @name AceTab-3.0
+-- @release $Id: AceTab-3.0.lua 1287 2022-09-25 09:15:57Z nevcairiel $
+
+local ACETAB_MAJOR, ACETAB_MINOR = 'AceTab-3.0', 9
+local AceTab, oldminor = LibStub:NewLibrary(ACETAB_MAJOR, ACETAB_MINOR)
+
+if not AceTab then return end -- No upgrade needed
+
+AceTab.registry = AceTab.registry or {}
+
+-- local upvalues
+local _G = _G
+local pairs = pairs
+local ipairs = ipairs
+local type = type
+local registry = AceTab.registry
+
+local strfind = string.find
+local strsub = string.sub
+local strlower = string.lower
+local strformat = string.format
+local strmatch = string.match
+
+local function printf(...)
+	DEFAULT_CHAT_FRAME:AddMessage(strformat(...))
+end
+
+local function getTextBeforeCursor(this, start)
+	return strsub(this:GetText(), start or 1, this:GetCursorPosition())
+end
+
+-- Hook OnTabPressed and OnTextChanged for the frame, give it an empty matches table, and set its curMatch to 0, if we haven't done so already.
+local function hookFrame(f)
+	if f.hookedByAceTab3 then return end
+	f.hookedByAceTab3 = true
+	if f == ChatEdit_GetActiveWindow() then
+		local origCTP = ChatEdit_CustomTabPressed
+		function ChatEdit_CustomTabPressed(...)
+			if AceTab:OnTabPressed(f) then
+				return origCTP(...)
+			else
+				return true
+			end
+		end
+	else
+		local origOTP = f:GetScript('OnTabPressed')
+		if type(origOTP) ~= 'function' then
+			origOTP = function() end
+		end
+		f:SetScript('OnTabPressed', function(...)
+			if AceTab:OnTabPressed(f) then
+				return origOTP(...)
+			end
+		end)
+	end
+	f.at3curMatch = 0
+	f.at3matches = {}
+end
+
+local fallbacks, notfallbacks = {}, {}  -- classifies completions into those which have preconditions and those which do not.  Those without preconditions are only considered if no other completions have matches.
+local pmolengths = {}  -- holds the number of characters to overwrite according to pmoverwrite and the current prematch
+-- ------------------------------------------------------------------------------
+-- RegisterTabCompletion( descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite )
+-- See http://www.wowace.com/wiki/AceTab-2.0 for detailed API documentation
+--
+-- descriptor	string					Unique identifier for this tab completion set
+--
+-- prematches	string|table|nil		String match(es) AFTER which this tab completion will apply.
+--										AceTab will ignore tabs NOT preceded by the string(s).
+--										If no value is passed, will check all tabs pressed in the specified editframe(s) UNLESS a more-specific tab complete applies.
+--
+-- wordlist		function|table			Function that will be passed a table into which it will insert strings corresponding to all possible completions, or an equivalent table.
+--										The text in the editbox, the position of the start of the word to be completed, and the uncompleted partial word
+--										are passed as second, third, and fourth arguments, to facilitate pre-filtering or conditional formatting, if desired.
+--
+-- usagefunc	function|boolean|nil	Usage statement function.  Defaults to the wordlist, one per line.  A boolean true squelches usage output.
+--
+-- listenframes	string|table|nil		EditFrames to monitor.  Defaults to ChatFrameEditBox.
+--
+-- postfunc		function|nil			Post-processing function.  If supplied, matches will be passed through this function after they've been identified as a match.
+--
+-- pmoverwrite	boolean|number|nil		Offset the beginning of the completion string in the editbox when making a completion.  Passing a boolean true indicates that we want to overwrite
+--										the entire prematch string, and passing a number will overwrite that many characters prior to the cursor.
+--										This is useful when you want to use the prematch as an indicator character, but ultimately do not want it as part of the text, itself.
+--
+-- no return
+-- ------------------------------------------------------------------------------
+function AceTab:RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite)
+	-- Arg checks
+	if type(descriptor) ~= 'string' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'descriptor' - string expected.", 3) end
+	if prematches and type(prematches) ~= 'string' and type(prematches) ~= 'table' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'prematches' - string, table, or nil expected.", 3) end
+	if type(wordlist) ~= 'function' and type(wordlist) ~= 'table' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'wordlist' - function or table expected.", 3) end
+	if usagefunc and type(usagefunc) ~= 'function' and type(usagefunc) ~= 'boolean' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'usagefunc' - function or boolean expected.", 3) end
+	if listenframes and type(listenframes) ~= 'string' and type(listenframes) ~= 'table' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'listenframes' - string or table expected.", 3) end
+	if postfunc and type(postfunc) ~= 'function' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'postfunc' - function expected.", 3) end
+	if pmoverwrite and type(pmoverwrite) ~= 'boolean' and type(pmoverwrite) ~= 'number' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'pmoverwrite' - boolean or number expected.", 3) end
+
+	local pmtable
+
+	if type(prematches) == 'table' then
+		pmtable = prematches
+		notfallbacks[descriptor] = true
+	else
+		pmtable = {}
+		-- Mark this group as a fallback group if no value was passed.
+		if not prematches then
+			pmtable[1] = ""
+			fallbacks[descriptor] = true
+		-- Make prematches into a one-element table if it was passed as a string.
+		elseif type(prematches) == 'string' then
+			pmtable[1] = prematches
+			if prematches == "" then
+				fallbacks[descriptor] = true
+			else
+				notfallbacks[descriptor] = true
+			end
+		end
+	end
+
+	-- Make listenframes into a one-element table if it was not passed a table of frames.
+	if not listenframes then  -- default
+		listenframes = {}
+		for i = 1, NUM_CHAT_WINDOWS do
+			listenframes[i] = _G["ChatFrame"..i.."EditBox"]
+		end
+	elseif type(listenframes) ~= 'table' or type(listenframes[0]) == 'userdata' and type(listenframes.IsObjectType) == 'function' then  -- single frame or framename
+		listenframes = { listenframes }
+	end
+
+	-- Hook each registered listenframe and give it a matches table.
+	for _, f in pairs(listenframes) do
+		if type(f) == 'string' then
+			f = _G[f]
+		end
+		if type(f) ~= 'table' or type(f[0]) ~= 'userdata' or type(f.IsObjectType) ~= 'function' then
+			error(strformat(ACETAB_MAJOR..": Cannot register frame %q; it does not exist", f:GetName()))
+		end
+		if f then
+			if f:GetObjectType() ~= 'EditBox' then
+				error(strformat(ACETAB_MAJOR..": Cannot register frame %q; it is not an EditBox", f:GetName()))
+			else
+				hookFrame(f)
+			end
+		end
+	end
+
+	-- Everything checks out; register this completion.
+	if not registry[descriptor] then
+		registry[descriptor] = { prematches = pmtable, wordlist = wordlist, usagefunc = usagefunc, listenframes = listenframes, postfunc = postfunc, pmoverwrite = pmoverwrite }
+	end
+end
+
+function AceTab:IsTabCompletionRegistered(descriptor)
+	return registry and registry[descriptor]
+end
+
+function AceTab:UnregisterTabCompletion(descriptor)
+	registry[descriptor] = nil
+	pmolengths[descriptor] = nil
+	fallbacks[descriptor] = nil
+	notfallbacks[descriptor] = nil
+end
+
+-- ------------------------------------------------------------------------------
+-- gcbs( s1, s2 )
+--
+-- s1		string		First string to be compared
+--
+-- s2		string		Second string to be compared
+--
+-- returns the greatest common substring beginning s1 and s2
+-- ------------------------------------------------------------------------------
+local function gcbs(s1, s2)
+	if not s1 and not s2 then return end
+	if not s1 then s1 = s2 end
+	if not s2 then s2 = s1 end
+	if #s2 < #s1 then
+		s1, s2 = s2, s1
+	end
+	if strfind(strlower(s2), "^"..strlower(s1)) then
+		return s1
+	else
+		return gcbs(strsub(s1, 1, -2), s2)
+	end
+end
+
+local cursor  -- Holds cursor position.  Set in :OnTabPressed().
+-- ------------------------------------------------------------------------------
+-- cycleTab()
+-- For when a tab press has multiple possible completions, we need to allow the user to press tab repeatedly to cycle through them.
+-- If we have multiple possible completions, all tab presses after the first will call this function to cycle through and insert the different possible matches.
+-- This function will stop being called after OnTextChanged() is triggered by something other than AceTab (i.e. the user inputs a character).
+-- ------------------------------------------------------------------------------
+local previousLength, cMatch, matched, postmatch
+local function cycleTab(this)
+	cMatch = 0  -- Counter across all sets.  The pseudo-index relevant to this value and corresponding to the current match is held in this.at3curMatch
+	matched = false
+
+	-- Check each completion group registered to this frame.
+	for desc, compgrp in pairs(this.at3matches) do
+
+		-- Loop through the valid completions for this set.
+		for m, pm in pairs(compgrp) do
+			cMatch = cMatch + 1
+			if cMatch == this.at3curMatch then  -- we're back to where we left off last time through the combined list
+				this.at3lastMatch = m
+				this.at3lastWord = pm
+				this.at3curMatch = cMatch + 1 -- save the new cMatch index
+				matched = true
+				break
+			end
+		end
+		if matched then break end
+	end
+
+	-- If our index is beyond the end of the list, reset the original uncompleted substring and let the cycle start over next time tab is pressed.
+	if not matched then
+		this.at3lastMatch = this.at3origMatch
+		this.at3lastWord = this.at3origWord
+		this.at3curMatch = 1
+	end
+
+	-- Insert the completion.
+	this:HighlightText(this.at3matchStart-1, cursor)
+	this:Insert(this.at3lastWord or '')
+	this.at3_last_precursor = getTextBeforeCursor(this) or ''
+end
+
+local IsSecureCmd = IsSecureCmd
+
+local candUsage = {}
+local numMatches = 0
+local firstMatch, hasNonFallback, allGCBS, setGCBS, usage
+local text_precursor, text_all, text_pmendToCursor
+
+-- Fill the this.at3matches[descriptor] tables with matching completion pairs for each entry, based on
+-- the partial string preceding the cursor position and using the corresponding registered wordlist.
+--
+-- The entries of the matches tables are of the format raw_match = formatted_match, where raw_match is the plaintext completion and
+-- formatted_match is the match after being formatted/altered/processed by the registered postfunc.
+-- If no postfunc exists, then the formatted and raw matches are the same.
+local pms, pme, pmt, prematchStart, prematchEnd, text_prematch, entry
+local function fillMatches(this, desc, fallback)
+	entry = registry[desc]
+	-- See what frames are registered for this completion group.  If the frame in which we pressed tab is one of them, then we start building matches.
+	for _, f in ipairs(entry.listenframes) do
+		if f == this then
+
+			-- Try each precondition string registered for this completion group.
+			for _, prematch in ipairs(entry.prematches) do
+
+				-- Test if our prematch string is satisfied.
+				-- If it is, then we find its last occurence prior to the cursor, calculate and store its pmoverwrite value (if applicable), and start considering completions.
+				if fallback then prematch = "%s" end
+
+				-- Find the last occurence of the prematch before the cursor.
+				pms, pme, pmt = nil, 1, ''
+				text_prematch, prematchEnd, prematchStart = nil, nil, nil
+				while true do
+					pms, pme, pmt = strfind(text_precursor, "("..prematch..")", pme)
+					if pms then
+						prematchStart, prematchEnd, text_prematch = pms, pme, pmt
+						pme = pme + 1
+					else
+						break
+					end
+				end
+
+				if not prematchStart and fallback then
+					prematchStart, prematchEnd, text_prematch = 0, 0, ''
+				end
+				if prematchStart then
+					-- text_pmendToCursor should be the sub-word/phrase to be completed.
+					text_pmendToCursor = strsub(text_precursor, prematchEnd + 1)
+
+					-- How many characters should we eliminate before the completion before writing it in.
+					pmolengths[desc] = entry.pmoverwrite == true and #text_prematch or entry.pmoverwrite or 0
+
+					-- This is where we will insert completions, taking the prematch overwrite into account.
+					this.at3matchStart = prematchEnd + 1 - (pmolengths[desc] or 0)
+
+					-- We're either a non-fallback set or all completions thus far have been fallback sets, and the precondition matches.
+					-- Create cands from the registered wordlist, filling it with all potential (unfiltered) completion strings.
+					local wordlist = entry.wordlist
+					local cands = type(wordlist) == 'table' and wordlist or {}
+					if type(wordlist) == 'function' then
+						wordlist(cands, text_all, prematchEnd + 1, text_pmendToCursor)
+					end
+					if cands ~= false then
+						local matches = this.at3matches[desc] or {}
+						for i in pairs(matches) do matches[i] = nil end
+
+						-- Check each of the entries in cands to see if it completes the word before the cursor.
+						-- Finally, increment our match count and set firstMatch, if appropriate.
+						for _, m in ipairs(cands) do
+							if strfind(strlower(m), strlower(text_pmendToCursor), 1, 1) == 1 then  -- we have a matching completion!
+								hasNonFallback = hasNonFallback or (not fallback)
+								matches[m] = entry.postfunc and entry.postfunc(m, prematchEnd + 1, text_all) or m
+								numMatches = numMatches + 1
+								if numMatches == 1 then
+									firstMatch = matches[m]
+								end
+							end
+						end
+						this.at3matches[desc] = numMatches > 0 and matches or nil
+					end
+				end
+			end
+		end
+	end
+end
+
+function AceTab:OnTabPressed(this)
+	if this:GetText() == '' then return true end
+
+	-- allow Blizzard to handle slash commands, themselves
+	if this == ChatEdit_GetActiveWindow() then
+		local command = this:GetText()
+		if strfind(command, "^/[%a%d_]+$") then
+			return true
+		end
+		local cmd = strmatch(command, "^/[%a%d_]+")
+		if cmd and IsSecureCmd(cmd) then
+			return true
+		end
+	end
+
+	cursor = this:GetCursorPosition()
+
+	text_all = this:GetText()
+	text_precursor = getTextBeforeCursor(this) or ''
+
+	-- If we've already found some matches and haven't done anything since the last tab press, then (continue) cycling matches.
+	-- Otherwise, reset this frame's matches and proceed to creating our list of possible completions.
+	this.at3lastMatch = this.at3curMatch > 0 and (this.at3lastMatch or this.at3origWord)
+	-- Detects if we've made any edits since the last tab press.  If not, continue cycling completions.
+	if text_precursor == this.at3_last_precursor then
+		return cycleTab(this)
+	else
+		for i in pairs(this.at3matches) do this.at3matches[i] = nil end
+		this.at3curMatch = 0
+		this.at3origWord = nil
+		this.at3origMatch = nil
+		this.at3lastWord = nil
+		this.at3lastMatch = nil
+		this.at3_last_precursor = text_precursor
+	end
+
+	numMatches = 0
+	firstMatch = nil
+	hasNonFallback = false
+	for i in pairs(pmolengths) do pmolengths[i] = nil end
+
+	for desc in pairs(notfallbacks) do
+		fillMatches(this, desc)
+	end
+	if not hasNonFallback then
+		for desc in pairs(fallbacks) do
+			fillMatches(this, desc, true)
+		end
+	end
+
+	if not firstMatch then
+		this.at3_last_precursor = "\0"
+		return true
+	end
+
+	-- We want to replace the entire word with our completion, so highlight it up to the cursor.
+	-- If only one match exists, then stick it in there and append a space.
+	if numMatches == 1 then
+		-- HighlightText takes the value AFTER which the highlighting starts, so we have to subtract 1 to have it start before the first character.
+		this:HighlightText(this.at3matchStart-1, cursor)
+
+		this:Insert(firstMatch)
+		this:Insert(" ")
+	else
+		-- Otherwise, we want to begin cycling through the valid completions.
+		-- Beginning a cycle also causes the usage statement to be printed, if one exists.
+
+		-- Print usage statements for each possible completion (and gather up the GCBS of all matches while we're walking the tables).
+		allGCBS = nil
+		for desc, matches in pairs(this.at3matches) do
+			-- Don't print usage statements for fallback completion groups if we have 'real' completion groups with matches.
+			if hasNonFallback and fallbacks[desc] then break end
+
+			-- Use the group's description as a heading for its usage statements.
+			DEFAULT_CHAT_FRAME:AddMessage(desc..":")
+
+			local usagefunc = registry[desc].usagefunc
+			if not usagefunc then
+				-- No special usage processing; just print a list of the (formatted) matches.
+				for m, fm in pairs(matches) do
+					DEFAULT_CHAT_FRAME:AddMessage(fm)
+					allGCBS = gcbs(allGCBS, m)
+				end
+			else
+				-- Print a usage statement based on the corresponding registered usagefunc.
+				-- candUsage is the table passed to usagefunc to be filled with candidate = usage_statement pairs.
+				if type(usagefunc) == 'function' then
+					for i in pairs(candUsage) do candUsage[i] = nil end
+
+					-- usagefunc takes the greatest common substring of valid matches as one of its args, so let's find that now.
+					-- TODO: Make the GCBS function accept a vararg or table, after which we can just pass in the list of matches.
+					setGCBS = nil
+					for m in pairs(matches) do
+						setGCBS = gcbs(setGCBS, m)
+					end
+					allGCBS = gcbs(allGCBS, setGCBS)
+					usage = usagefunc(candUsage, matches, setGCBS, strsub(text_precursor, 1, prematchEnd))
+
+					-- If the usagefunc returns a string, then the entire usage statement has been taken care of by usagefunc, and we need only to print it...
+					if type(usage) == 'string' then
+						DEFAULT_CHAT_FRAME:AddMessage(usage)
+
+					-- ...otherwise, it should have filled candUsage with candidate-usage statement pairs, and we need to print the matching ones.
+					elseif next(candUsage) and numMatches > 0 then
+						for m, fm in pairs(matches) do
+							if candUsage[m] then DEFAULT_CHAT_FRAME:AddMessage(strformat("%s - %s", fm, candUsage[m])) end
+						end
+					end
+				end
+			end
+
+			if next(matches) then
+				-- Replace the original string with the greatest common substring of all valid completions.
+				this.at3curMatch = 1
+				this.at3origWord = strsub(text_precursor, this.at3matchStart, this.at3matchStart + pmolengths[desc] - 1) .. allGCBS or ""
+				this.at3origMatch = allGCBS or ""
+				this.at3lastWord = this.at3origWord
+				this.at3lastMatch = this.at3origMatch
+
+				this:HighlightText(this.at3matchStart-1, cursor)
+				this:Insert(this.at3origWord)
+				this.at3_last_precursor = getTextBeforeCursor(this) or ''
+			end
+		end
+	end
+end
diff --git a/Carbonite/Libs/AceTab-3.0/AceTab-3.0.xml b/Carbonite/Libs/AceTab-3.0/AceTab-3.0.xml
index 5de88f4..2e50904 100644
--- a/Carbonite/Libs/AceTab-3.0/AceTab-3.0.xml
+++ b/Carbonite/Libs/AceTab-3.0/AceTab-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceTab-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceTab-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/AceTimer-3.0/AceTimer-3.0.lua b/Carbonite/Libs/AceTimer-3.0/AceTimer-3.0.lua
index c337398..8776da2 100644
--- a/Carbonite/Libs/AceTimer-3.0/AceTimer-3.0.lua
+++ b/Carbonite/Libs/AceTimer-3.0/AceTimer-3.0.lua
@@ -1,278 +1,278 @@
---- **AceTimer-3.0** provides a central facility for registering timers.
--- AceTimer supports one-shot timers and repeating timers. All timers are stored in an efficient
--- data structure that allows easy dispatching and fast rescheduling. Timers can be registered
--- or canceled at any time, even from within a running timer, without conflict or large overhead.\\
--- AceTimer is currently limited to firing timers at a frequency of 0.01s as this is what the WoW timer API
--- restricts us to.
---
--- All `:Schedule` functions will return a handle to the current timer, which you will need to store if you
--- need to cancel the timer you just registered.
---
--- **AceTimer-3.0** can be embeded into your addon, either explicitly by calling AceTimer:Embed(MyAddon) or by
--- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
--- and can be accessed directly, without having to explicitly call AceTimer itself.\\
--- It is recommended to embed AceTimer, otherwise you'll have to specify a custom `self` on all calls you
--- make into AceTimer.
--- @class file
--- @name AceTimer-3.0
--- @release $Id: AceTimer-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
-
-local MAJOR, MINOR = "AceTimer-3.0", 17 -- Bump minor on changes
-local AceTimer, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not AceTimer then return end -- No upgrade needed
-AceTimer.activeTimers = AceTimer.activeTimers or {} -- Active timer list
-local activeTimers = AceTimer.activeTimers -- Upvalue our private data
-
--- Lua APIs
-local type, unpack, next, error, select = type, unpack, next, error, select
--- WoW APIs
-local GetTime, C_TimerAfter = GetTime, C_Timer.After
-
-local function new(self, loop, func, delay, ...)
-	if delay < 0.01 then
-		delay = 0.01 -- Restrict to the lowest time that the C_Timer API allows us
-	end
-
-	local timer = {
-		object = self,
-		func = func,
-		looping = loop,
-		argsCount = select("#", ...),
-		delay = delay,
-		ends = GetTime() + delay,
-		...
-	}
-
-	activeTimers[timer] = timer
-
-	-- Create new timer closure to wrap the "timer" object
-	timer.callback = function()
-		if not timer.cancelled then
-			if type(timer.func) == "string" then
-				-- We manually set the unpack count to prevent issues with an arg set that contains nil and ends with nil
-				-- e.g. local t = {1, 2, nil, 3, nil} print(#t) will result in 2, instead of 5. This fixes said issue.
-				timer.object[timer.func](timer.object, unpack(timer, 1, timer.argsCount))
-			else
-				timer.func(unpack(timer, 1, timer.argsCount))
-			end
-
-			if timer.looping and not timer.cancelled then
-				-- Compensate delay to get a perfect average delay, even if individual times don't match up perfectly
-				-- due to fps differences
-				local time = GetTime()
-				local ndelay = timer.delay - (time - timer.ends)
-				-- Ensure the delay doesn't go below the threshold
-				if ndelay < 0.01 then ndelay = 0.01 end
-				C_TimerAfter(ndelay, timer.callback)
-				timer.ends = time + ndelay
-			else
-				activeTimers[timer.handle or timer] = nil
-			end
-		end
-	end
-
-	C_TimerAfter(delay, timer.callback)
-	return timer
-end
-
---- Schedule a new one-shot timer.
--- The timer will fire once in `delay` seconds, unless canceled before.
--- @param callback Callback function for the timer pulse (funcref or method name).
--- @param delay Delay for the timer, in seconds.
--- @param ... An optional, unlimited amount of arguments to pass to the callback function.
--- @usage
--- MyAddOn = LibStub("AceAddon-3.0"):NewAddon("MyAddOn", "AceTimer-3.0")
---
--- function MyAddOn:OnEnable()
---   self:ScheduleTimer("TimerFeedback", 5)
--- end
---
--- function MyAddOn:TimerFeedback()
---   print("5 seconds passed")
--- end
-function AceTimer:ScheduleTimer(func, delay, ...)
-	if not func or not delay then
-		error(MAJOR..": ScheduleTimer(callback, delay, args...): 'callback' and 'delay' must have set values.", 2)
-	end
-	if type(func) == "string" then
-		if type(self) ~= "table" then
-			error(MAJOR..": ScheduleTimer(callback, delay, args...): 'self' - must be a table.", 2)
-		elseif not self[func] then
-			error(MAJOR..": ScheduleTimer(callback, delay, args...): Tried to register '"..func.."' as the callback, but it doesn't exist in the module.", 2)
-		end
-	end
-	return new(self, nil, func, delay, ...)
-end
-
---- Schedule a repeating timer.
--- The timer will fire every `delay` seconds, until canceled.
--- @param callback Callback function for the timer pulse (funcref or method name).
--- @param delay Delay for the timer, in seconds.
--- @param ... An optional, unlimited amount of arguments to pass to the callback function.
--- @usage
--- MyAddOn = LibStub("AceAddon-3.0"):NewAddon("MyAddOn", "AceTimer-3.0")
---
--- function MyAddOn:OnEnable()
---   self.timerCount = 0
---   self.testTimer = self:ScheduleRepeatingTimer("TimerFeedback", 5)
--- end
---
--- function MyAddOn:TimerFeedback()
---   self.timerCount = self.timerCount + 1
---   print(("%d seconds passed"):format(5 * self.timerCount))
---   -- run 30 seconds in total
---   if self.timerCount == 6 then
---     self:CancelTimer(self.testTimer)
---   end
--- end
-function AceTimer:ScheduleRepeatingTimer(func, delay, ...)
-	if not func or not delay then
-		error(MAJOR..": ScheduleRepeatingTimer(callback, delay, args...): 'callback' and 'delay' must have set values.", 2)
-	end
-	if type(func) == "string" then
-		if type(self) ~= "table" then
-			error(MAJOR..": ScheduleRepeatingTimer(callback, delay, args...): 'self' - must be a table.", 2)
-		elseif not self[func] then
-			error(MAJOR..": ScheduleRepeatingTimer(callback, delay, args...): Tried to register '"..func.."' as the callback, but it doesn't exist in the module.", 2)
-		end
-	end
-	return new(self, true, func, delay, ...)
-end
-
---- Cancels a timer with the given id, registered by the same addon object as used for `:ScheduleTimer`
--- Both one-shot and repeating timers can be canceled with this function, as long as the `id` is valid
--- and the timer has not fired yet or was canceled before.
--- @param id The id of the timer, as returned by `:ScheduleTimer` or `:ScheduleRepeatingTimer`
-function AceTimer:CancelTimer(id)
-	local timer = activeTimers[id]
-
-	if not timer then
-		return false
-	else
-		timer.cancelled = true
-		activeTimers[id] = nil
-		return true
-	end
-end
-
---- Cancels all timers registered to the current addon object ('self')
-function AceTimer:CancelAllTimers()
-	for k,v in next, activeTimers do
-		if v.object == self then
-			AceTimer.CancelTimer(self, k)
-		end
-	end
-end
-
---- Returns the time left for a timer with the given id, registered by the current addon object ('self').
--- This function will return 0 when the id is invalid.
--- @param id The id of the timer, as returned by `:ScheduleTimer` or `:ScheduleRepeatingTimer`
--- @return The time left on the timer.
-function AceTimer:TimeLeft(id)
-	local timer = activeTimers[id]
-	if not timer then
-		return 0
-	else
-		return timer.ends - GetTime()
-	end
-end
-
-
--- ---------------------------------------------------------------------
--- Upgrading
-
--- Upgrade from old hash-bucket based timers to C_Timer.After timers.
-if oldminor and oldminor < 10 then
-	-- disable old timer logic
-	AceTimer.frame:SetScript("OnUpdate", nil)
-	AceTimer.frame:SetScript("OnEvent", nil)
-	AceTimer.frame:UnregisterAllEvents()
-	-- convert timers
-	for object,timers in next, AceTimer.selfs do
-		for handle,timer in next, timers do
-			if type(timer) == "table" and timer.callback then
-				local newTimer
-				if timer.delay then
-					newTimer = AceTimer.ScheduleRepeatingTimer(timer.object, timer.callback, timer.delay, timer.arg)
-				else
-					newTimer = AceTimer.ScheduleTimer(timer.object, timer.callback, timer.when - GetTime(), timer.arg)
-				end
-				-- Use the old handle for old timers
-				activeTimers[newTimer] = nil
-				activeTimers[handle] = newTimer
-				newTimer.handle = handle
-			end
-		end
-	end
-	AceTimer.selfs = nil
-	AceTimer.hash = nil
-	AceTimer.debug = nil
-elseif oldminor and oldminor < 17 then
-	-- Upgrade from old animation based timers to C_Timer.After timers.
-	AceTimer.inactiveTimers = nil
-	AceTimer.frame = nil
-	local oldTimers = AceTimer.activeTimers
-	-- Clear old timer table and update upvalue
-	AceTimer.activeTimers = {}
-	activeTimers = AceTimer.activeTimers
-	for handle, timer in next, oldTimers do
-		local newTimer
-		-- Stop the old timer animation
-		local duration, elapsed = timer:GetDuration(), timer:GetElapsed()
-		timer:GetParent():Stop()
-		if timer.looping then
-			newTimer = AceTimer.ScheduleRepeatingTimer(timer.object, timer.func, duration, unpack(timer.args, 1, timer.argsCount))
-		else
-			newTimer = AceTimer.ScheduleTimer(timer.object, timer.func, duration - elapsed, unpack(timer.args, 1, timer.argsCount))
-		end
-		-- Use the old handle for old timers
-		activeTimers[newTimer] = nil
-		activeTimers[handle] = newTimer
-		newTimer.handle = handle
-	end
-
-	-- Migrate transitional handles
-	if oldminor < 13 and AceTimer.hashCompatTable then
-		for handle, id in next, AceTimer.hashCompatTable do
-			local t = activeTimers[id]
-			if t then
-				activeTimers[id] = nil
-				activeTimers[handle] = t
-				t.handle = handle
-			end
-		end
-		AceTimer.hashCompatTable = nil
-	end
-end
-
--- ---------------------------------------------------------------------
--- Embed handling
-
-AceTimer.embeds = AceTimer.embeds or {}
-
-local mixins = {
-	"ScheduleTimer", "ScheduleRepeatingTimer",
-	"CancelTimer", "CancelAllTimers",
-	"TimeLeft"
-}
-
-function AceTimer:Embed(target)
-	AceTimer.embeds[target] = true
-	for _,v in next, mixins do
-		target[v] = AceTimer[v]
-	end
-	return target
-end
-
--- AceTimer:OnEmbedDisable(target)
--- target (object) - target object that AceTimer is embedded in.
---
--- cancel all timers registered for the object
-function AceTimer:OnEmbedDisable(target)
-	target:CancelAllTimers()
-end
-
-for addon in next, AceTimer.embeds do
-	AceTimer:Embed(addon)
-end
+--- **AceTimer-3.0** provides a central facility for registering timers.
+-- AceTimer supports one-shot timers and repeating timers. All timers are stored in an efficient
+-- data structure that allows easy dispatching and fast rescheduling. Timers can be registered
+-- or canceled at any time, even from within a running timer, without conflict or large overhead.\\
+-- AceTimer is currently limited to firing timers at a frequency of 0.01s as this is what the WoW timer API
+-- restricts us to.
+--
+-- All `:Schedule` functions will return a handle to the current timer, which you will need to store if you
+-- need to cancel the timer you just registered.
+--
+-- **AceTimer-3.0** can be embeded into your addon, either explicitly by calling AceTimer:Embed(MyAddon) or by
+-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
+-- and can be accessed directly, without having to explicitly call AceTimer itself.\\
+-- It is recommended to embed AceTimer, otherwise you'll have to specify a custom `self` on all calls you
+-- make into AceTimer.
+-- @class file
+-- @name AceTimer-3.0
+-- @release $Id: AceTimer-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
+
+local MAJOR, MINOR = "AceTimer-3.0", 17 -- Bump minor on changes
+local AceTimer, oldminor = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not AceTimer then return end -- No upgrade needed
+AceTimer.activeTimers = AceTimer.activeTimers or {} -- Active timer list
+local activeTimers = AceTimer.activeTimers -- Upvalue our private data
+
+-- Lua APIs
+local type, unpack, next, error, select = type, unpack, next, error, select
+-- WoW APIs
+local GetTime, C_TimerAfter = GetTime, C_Timer.After
+
+local function new(self, loop, func, delay, ...)
+	if delay < 0.01 then
+		delay = 0.01 -- Restrict to the lowest time that the C_Timer API allows us
+	end
+
+	local timer = {
+		object = self,
+		func = func,
+		looping = loop,
+		argsCount = select("#", ...),
+		delay = delay,
+		ends = GetTime() + delay,
+		...
+	}
+
+	activeTimers[timer] = timer
+
+	-- Create new timer closure to wrap the "timer" object
+	timer.callback = function()
+		if not timer.cancelled then
+			if type(timer.func) == "string" then
+				-- We manually set the unpack count to prevent issues with an arg set that contains nil and ends with nil
+				-- e.g. local t = {1, 2, nil, 3, nil} print(#t) will result in 2, instead of 5. This fixes said issue.
+				timer.object[timer.func](timer.object, unpack(timer, 1, timer.argsCount))
+			else
+				timer.func(unpack(timer, 1, timer.argsCount))
+			end
+
+			if timer.looping and not timer.cancelled then
+				-- Compensate delay to get a perfect average delay, even if individual times don't match up perfectly
+				-- due to fps differences
+				local time = GetTime()
+				local ndelay = timer.delay - (time - timer.ends)
+				-- Ensure the delay doesn't go below the threshold
+				if ndelay < 0.01 then ndelay = 0.01 end
+				C_TimerAfter(ndelay, timer.callback)
+				timer.ends = time + ndelay
+			else
+				activeTimers[timer.handle or timer] = nil
+			end
+		end
+	end
+
+	C_TimerAfter(delay, timer.callback)
+	return timer
+end
+
+--- Schedule a new one-shot timer.
+-- The timer will fire once in `delay` seconds, unless canceled before.
+-- @param callback Callback function for the timer pulse (funcref or method name).
+-- @param delay Delay for the timer, in seconds.
+-- @param ... An optional, unlimited amount of arguments to pass to the callback function.
+-- @usage
+-- MyAddOn = LibStub("AceAddon-3.0"):NewAddon("MyAddOn", "AceTimer-3.0")
+--
+-- function MyAddOn:OnEnable()
+--   self:ScheduleTimer("TimerFeedback", 5)
+-- end
+--
+-- function MyAddOn:TimerFeedback()
+--   print("5 seconds passed")
+-- end
+function AceTimer:ScheduleTimer(func, delay, ...)
+	if not func or not delay then
+		error(MAJOR..": ScheduleTimer(callback, delay, args...): 'callback' and 'delay' must have set values.", 2)
+	end
+	if type(func) == "string" then
+		if type(self) ~= "table" then
+			error(MAJOR..": ScheduleTimer(callback, delay, args...): 'self' - must be a table.", 2)
+		elseif not self[func] then
+			error(MAJOR..": ScheduleTimer(callback, delay, args...): Tried to register '"..func.."' as the callback, but it doesn't exist in the module.", 2)
+		end
+	end
+	return new(self, nil, func, delay, ...)
+end
+
+--- Schedule a repeating timer.
+-- The timer will fire every `delay` seconds, until canceled.
+-- @param callback Callback function for the timer pulse (funcref or method name).
+-- @param delay Delay for the timer, in seconds.
+-- @param ... An optional, unlimited amount of arguments to pass to the callback function.
+-- @usage
+-- MyAddOn = LibStub("AceAddon-3.0"):NewAddon("MyAddOn", "AceTimer-3.0")
+--
+-- function MyAddOn:OnEnable()
+--   self.timerCount = 0
+--   self.testTimer = self:ScheduleRepeatingTimer("TimerFeedback", 5)
+-- end
+--
+-- function MyAddOn:TimerFeedback()
+--   self.timerCount = self.timerCount + 1
+--   print(("%d seconds passed"):format(5 * self.timerCount))
+--   -- run 30 seconds in total
+--   if self.timerCount == 6 then
+--     self:CancelTimer(self.testTimer)
+--   end
+-- end
+function AceTimer:ScheduleRepeatingTimer(func, delay, ...)
+	if not func or not delay then
+		error(MAJOR..": ScheduleRepeatingTimer(callback, delay, args...): 'callback' and 'delay' must have set values.", 2)
+	end
+	if type(func) == "string" then
+		if type(self) ~= "table" then
+			error(MAJOR..": ScheduleRepeatingTimer(callback, delay, args...): 'self' - must be a table.", 2)
+		elseif not self[func] then
+			error(MAJOR..": ScheduleRepeatingTimer(callback, delay, args...): Tried to register '"..func.."' as the callback, but it doesn't exist in the module.", 2)
+		end
+	end
+	return new(self, true, func, delay, ...)
+end
+
+--- Cancels a timer with the given id, registered by the same addon object as used for `:ScheduleTimer`
+-- Both one-shot and repeating timers can be canceled with this function, as long as the `id` is valid
+-- and the timer has not fired yet or was canceled before.
+-- @param id The id of the timer, as returned by `:ScheduleTimer` or `:ScheduleRepeatingTimer`
+function AceTimer:CancelTimer(id)
+	local timer = activeTimers[id]
+
+	if not timer then
+		return false
+	else
+		timer.cancelled = true
+		activeTimers[id] = nil
+		return true
+	end
+end
+
+--- Cancels all timers registered to the current addon object ('self')
+function AceTimer:CancelAllTimers()
+	for k,v in next, activeTimers do
+		if v.object == self then
+			AceTimer.CancelTimer(self, k)
+		end
+	end
+end
+
+--- Returns the time left for a timer with the given id, registered by the current addon object ('self').
+-- This function will return 0 when the id is invalid.
+-- @param id The id of the timer, as returned by `:ScheduleTimer` or `:ScheduleRepeatingTimer`
+-- @return The time left on the timer.
+function AceTimer:TimeLeft(id)
+	local timer = activeTimers[id]
+	if not timer then
+		return 0
+	else
+		return timer.ends - GetTime()
+	end
+end
+
+
+-- ---------------------------------------------------------------------
+-- Upgrading
+
+-- Upgrade from old hash-bucket based timers to C_Timer.After timers.
+if oldminor and oldminor < 10 then
+	-- disable old timer logic
+	AceTimer.frame:SetScript("OnUpdate", nil)
+	AceTimer.frame:SetScript("OnEvent", nil)
+	AceTimer.frame:UnregisterAllEvents()
+	-- convert timers
+	for object,timers in next, AceTimer.selfs do
+		for handle,timer in next, timers do
+			if type(timer) == "table" and timer.callback then
+				local newTimer
+				if timer.delay then
+					newTimer = AceTimer.ScheduleRepeatingTimer(timer.object, timer.callback, timer.delay, timer.arg)
+				else
+					newTimer = AceTimer.ScheduleTimer(timer.object, timer.callback, timer.when - GetTime(), timer.arg)
+				end
+				-- Use the old handle for old timers
+				activeTimers[newTimer] = nil
+				activeTimers[handle] = newTimer
+				newTimer.handle = handle
+			end
+		end
+	end
+	AceTimer.selfs = nil
+	AceTimer.hash = nil
+	AceTimer.debug = nil
+elseif oldminor and oldminor < 17 then
+	-- Upgrade from old animation based timers to C_Timer.After timers.
+	AceTimer.inactiveTimers = nil
+	AceTimer.frame = nil
+	local oldTimers = AceTimer.activeTimers
+	-- Clear old timer table and update upvalue
+	AceTimer.activeTimers = {}
+	activeTimers = AceTimer.activeTimers
+	for handle, timer in next, oldTimers do
+		local newTimer
+		-- Stop the old timer animation
+		local duration, elapsed = timer:GetDuration(), timer:GetElapsed()
+		timer:GetParent():Stop()
+		if timer.looping then
+			newTimer = AceTimer.ScheduleRepeatingTimer(timer.object, timer.func, duration, unpack(timer.args, 1, timer.argsCount))
+		else
+			newTimer = AceTimer.ScheduleTimer(timer.object, timer.func, duration - elapsed, unpack(timer.args, 1, timer.argsCount))
+		end
+		-- Use the old handle for old timers
+		activeTimers[newTimer] = nil
+		activeTimers[handle] = newTimer
+		newTimer.handle = handle
+	end
+
+	-- Migrate transitional handles
+	if oldminor < 13 and AceTimer.hashCompatTable then
+		for handle, id in next, AceTimer.hashCompatTable do
+			local t = activeTimers[id]
+			if t then
+				activeTimers[id] = nil
+				activeTimers[handle] = t
+				t.handle = handle
+			end
+		end
+		AceTimer.hashCompatTable = nil
+	end
+end
+
+-- ---------------------------------------------------------------------
+-- Embed handling
+
+AceTimer.embeds = AceTimer.embeds or {}
+
+local mixins = {
+	"ScheduleTimer", "ScheduleRepeatingTimer",
+	"CancelTimer", "CancelAllTimers",
+	"TimeLeft"
+}
+
+function AceTimer:Embed(target)
+	AceTimer.embeds[target] = true
+	for _,v in next, mixins do
+		target[v] = AceTimer[v]
+	end
+	return target
+end
+
+-- AceTimer:OnEmbedDisable(target)
+-- target (object) - target object that AceTimer is embedded in.
+--
+-- cancel all timers registered for the object
+function AceTimer:OnEmbedDisable(target)
+	target:CancelAllTimers()
+end
+
+for addon in next, AceTimer.embeds do
+	AceTimer:Embed(addon)
+end
diff --git a/Carbonite/Libs/AceTimer-3.0/AceTimer-3.0.xml b/Carbonite/Libs/AceTimer-3.0/AceTimer-3.0.xml
index 1987d78..d5aee81 100644
--- a/Carbonite/Libs/AceTimer-3.0/AceTimer-3.0.xml
+++ b/Carbonite/Libs/AceTimer-3.0/AceTimer-3.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="AceTimer-3.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="AceTimer-3.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/CallbackHandler-1.0/CallbackHandler-1.0.lua b/Carbonite/Libs/CallbackHandler-1.0/CallbackHandler-1.0.lua
index 01287bd..6b32193 100644
--- a/Carbonite/Libs/CallbackHandler-1.0/CallbackHandler-1.0.lua
+++ b/Carbonite/Libs/CallbackHandler-1.0/CallbackHandler-1.0.lua
@@ -1,202 +1,202 @@
---[[ $Id: CallbackHandler-1.0.lua 1298 2022-12-12 15:10:10Z nevcairiel $ ]]
-local MAJOR, MINOR = "CallbackHandler-1.0", 8
-local CallbackHandler = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not CallbackHandler then return end -- No upgrade needed
-
-local meta = {__index = function(tbl, key) tbl[key] = {} return tbl[key] end}
-
--- Lua APIs
-local securecallfunction, error = securecallfunction, error
-local setmetatable, rawget = setmetatable, rawget
-local next, select, pairs, type, tostring = next, select, pairs, type, tostring
-
-
-local function Dispatch(handlers, ...)
-	local index, method = next(handlers)
-	if not method then return end
-	repeat
-		securecallfunction(method, ...)
-		index, method = next(handlers, index)
-	until not method
-end
-
---------------------------------------------------------------------------
--- CallbackHandler:New
---
---   target            - target object to embed public APIs in
---   RegisterName      - name of the callback registration API, default "RegisterCallback"
---   UnregisterName    - name of the callback unregistration API, default "UnregisterCallback"
---   UnregisterAllName - name of the API to unregister all callbacks, default "UnregisterAllCallbacks". false == don't publish this API.
-
-function CallbackHandler.New(_self, target, RegisterName, UnregisterName, UnregisterAllName)
-
-	RegisterName = RegisterName or "RegisterCallback"
-	UnregisterName = UnregisterName or "UnregisterCallback"
-	if UnregisterAllName==nil then	-- false is used to indicate "don't want this method"
-		UnregisterAllName = "UnregisterAllCallbacks"
-	end
-
-	-- we declare all objects and exported APIs inside this closure to quickly gain access
-	-- to e.g. function names, the "target" parameter, etc
-
-
-	-- Create the registry object
-	local events = setmetatable({}, meta)
-	local registry = { recurse=0, events=events }
-
-	-- registry:Fire() - fires the given event/message into the registry
-	function registry:Fire(eventname, ...)
-		if not rawget(events, eventname) or not next(events[eventname]) then return end
-		local oldrecurse = registry.recurse
-		registry.recurse = oldrecurse + 1
-
-		Dispatch(events[eventname], eventname, ...)
-
-		registry.recurse = oldrecurse
-
-		if registry.insertQueue and oldrecurse==0 then
-			-- Something in one of our callbacks wanted to register more callbacks; they got queued
-			for event,callbacks in pairs(registry.insertQueue) do
-				local first = not rawget(events, event) or not next(events[event])	-- test for empty before. not test for one member after. that one member may have been overwritten.
-				for object,func in pairs(callbacks) do
-					events[event][object] = func
-					-- fire OnUsed callback?
-					if first and registry.OnUsed then
-						registry.OnUsed(registry, target, event)
-						first = nil
-					end
-				end
-			end
-			registry.insertQueue = nil
-		end
-	end
-
-	-- Registration of a callback, handles:
-	--   self["method"], leads to self["method"](self, ...)
-	--   self with function ref, leads to functionref(...)
-	--   "addonId" (instead of self) with function ref, leads to functionref(...)
-	-- all with an optional arg, which, if present, gets passed as first argument (after self if present)
-	target[RegisterName] = function(self, eventname, method, ... --[[actually just a single arg]])
-		if type(eventname) ~= "string" then
-			error("Usage: "..RegisterName.."(eventname, method[, arg]): 'eventname' - string expected.", 2)
-		end
-
-		method = method or eventname
-
-		local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.
-
-		if type(method) ~= "string" and type(method) ~= "function" then
-			error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - string or function expected.", 2)
-		end
-
-		local regfunc
-
-		if type(method) == "string" then
-			-- self["method"] calling style
-			if type(self) ~= "table" then
-				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): self was not a table?", 2)
-			elseif self==target then
-				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): do not use Library:"..RegisterName.."(), use your own 'self'", 2)
-			elseif type(self[method]) ~= "function" then
-				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - method '"..tostring(method).."' not found on self.", 2)
-			end
-
-			if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
-				local arg=select(1,...)
-				regfunc = function(...) self[method](self,arg,...) end
-			else
-				regfunc = function(...) self[method](self,...) end
-			end
-		else
-			-- function ref with self=object or self="addonId" or self=thread
-			if type(self)~="table" and type(self)~="string" and type(self)~="thread" then
-				error("Usage: "..RegisterName.."(self or \"addonId\", eventname, method): 'self or addonId': table or string or thread expected.", 2)
-			end
-
-			if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
-				local arg=select(1,...)
-				regfunc = function(...) method(arg,...) end
-			else
-				regfunc = method
-			end
-		end
-
-
-		if events[eventname][self] or registry.recurse<1 then
-		-- if registry.recurse<1 then
-			-- we're overwriting an existing entry, or not currently recursing. just set it.
-			events[eventname][self] = regfunc
-			-- fire OnUsed callback?
-			if registry.OnUsed and first then
-				registry.OnUsed(registry, target, eventname)
-			end
-		else
-			-- we're currently processing a callback in this registry, so delay the registration of this new entry!
-			-- yes, we're a bit wasteful on garbage, but this is a fringe case, so we're picking low implementation overhead over garbage efficiency
-			registry.insertQueue = registry.insertQueue or setmetatable({},meta)
-			registry.insertQueue[eventname][self] = regfunc
-		end
-	end
-
-	-- Unregister a callback
-	target[UnregisterName] = function(self, eventname)
-		if not self or self==target then
-			error("Usage: "..UnregisterName.."(eventname): bad 'self'", 2)
-		end
-		if type(eventname) ~= "string" then
-			error("Usage: "..UnregisterName.."(eventname): 'eventname' - string expected.", 2)
-		end
-		if rawget(events, eventname) and events[eventname][self] then
-			events[eventname][self] = nil
-			-- Fire OnUnused callback?
-			if registry.OnUnused and not next(events[eventname]) then
-				registry.OnUnused(registry, target, eventname)
-			end
-		end
-		if registry.insertQueue and rawget(registry.insertQueue, eventname) and registry.insertQueue[eventname][self] then
-			registry.insertQueue[eventname][self] = nil
-		end
-	end
-
-	-- OPTIONAL: Unregister all callbacks for given selfs/addonIds
-	if UnregisterAllName then
-		target[UnregisterAllName] = function(...)
-			if select("#",...)<1 then
-				error("Usage: "..UnregisterAllName.."([whatFor]): missing 'self' or \"addonId\" to unregister events for.", 2)
-			end
-			if select("#",...)==1 and ...==target then
-				error("Usage: "..UnregisterAllName.."([whatFor]): supply a meaningful 'self' or \"addonId\"", 2)
-			end
-
-
-			for i=1,select("#",...) do
-				local self = select(i,...)
-				if registry.insertQueue then
-					for eventname, callbacks in pairs(registry.insertQueue) do
-						if callbacks[self] then
-							callbacks[self] = nil
-						end
-					end
-				end
-				for eventname, callbacks in pairs(events) do
-					if callbacks[self] then
-						callbacks[self] = nil
-						-- Fire OnUnused callback?
-						if registry.OnUnused and not next(callbacks) then
-							registry.OnUnused(registry, target, eventname)
-						end
-					end
-				end
-			end
-		end
-	end
-
-	return registry
-end
-
-
--- CallbackHandler purposefully does NOT do explicit embedding. Nor does it
--- try to upgrade old implicit embeds since the system is selfcontained and
--- relies on closures to work.
-
+--[[ $Id: CallbackHandler-1.0.lua 1298 2022-12-12 15:10:10Z nevcairiel $ ]]
+local MAJOR, MINOR = "CallbackHandler-1.0", 8
+local CallbackHandler = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not CallbackHandler then return end -- No upgrade needed
+
+local meta = {__index = function(tbl, key) tbl[key] = {} return tbl[key] end}
+
+-- Lua APIs
+local securecallfunction, error = securecallfunction, error
+local setmetatable, rawget = setmetatable, rawget
+local next, select, pairs, type, tostring = next, select, pairs, type, tostring
+
+
+local function Dispatch(handlers, ...)
+	local index, method = next(handlers)
+	if not method then return end
+	repeat
+		securecallfunction(method, ...)
+		index, method = next(handlers, index)
+	until not method
+end
+
+--------------------------------------------------------------------------
+-- CallbackHandler:New
+--
+--   target            - target object to embed public APIs in
+--   RegisterName      - name of the callback registration API, default "RegisterCallback"
+--   UnregisterName    - name of the callback unregistration API, default "UnregisterCallback"
+--   UnregisterAllName - name of the API to unregister all callbacks, default "UnregisterAllCallbacks". false == don't publish this API.
+
+function CallbackHandler.New(_self, target, RegisterName, UnregisterName, UnregisterAllName)
+
+	RegisterName = RegisterName or "RegisterCallback"
+	UnregisterName = UnregisterName or "UnregisterCallback"
+	if UnregisterAllName==nil then	-- false is used to indicate "don't want this method"
+		UnregisterAllName = "UnregisterAllCallbacks"
+	end
+
+	-- we declare all objects and exported APIs inside this closure to quickly gain access
+	-- to e.g. function names, the "target" parameter, etc
+
+
+	-- Create the registry object
+	local events = setmetatable({}, meta)
+	local registry = { recurse=0, events=events }
+
+	-- registry:Fire() - fires the given event/message into the registry
+	function registry:Fire(eventname, ...)
+		if not rawget(events, eventname) or not next(events[eventname]) then return end
+		local oldrecurse = registry.recurse
+		registry.recurse = oldrecurse + 1
+
+		Dispatch(events[eventname], eventname, ...)
+
+		registry.recurse = oldrecurse
+
+		if registry.insertQueue and oldrecurse==0 then
+			-- Something in one of our callbacks wanted to register more callbacks; they got queued
+			for event,callbacks in pairs(registry.insertQueue) do
+				local first = not rawget(events, event) or not next(events[event])	-- test for empty before. not test for one member after. that one member may have been overwritten.
+				for object,func in pairs(callbacks) do
+					events[event][object] = func
+					-- fire OnUsed callback?
+					if first and registry.OnUsed then
+						registry.OnUsed(registry, target, event)
+						first = nil
+					end
+				end
+			end
+			registry.insertQueue = nil
+		end
+	end
+
+	-- Registration of a callback, handles:
+	--   self["method"], leads to self["method"](self, ...)
+	--   self with function ref, leads to functionref(...)
+	--   "addonId" (instead of self) with function ref, leads to functionref(...)
+	-- all with an optional arg, which, if present, gets passed as first argument (after self if present)
+	target[RegisterName] = function(self, eventname, method, ... --[[actually just a single arg]])
+		if type(eventname) ~= "string" then
+			error("Usage: "..RegisterName.."(eventname, method[, arg]): 'eventname' - string expected.", 2)
+		end
+
+		method = method or eventname
+
+		local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.
+
+		if type(method) ~= "string" and type(method) ~= "function" then
+			error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - string or function expected.", 2)
+		end
+
+		local regfunc
+
+		if type(method) == "string" then
+			-- self["method"] calling style
+			if type(self) ~= "table" then
+				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): self was not a table?", 2)
+			elseif self==target then
+				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): do not use Library:"..RegisterName.."(), use your own 'self'", 2)
+			elseif type(self[method]) ~= "function" then
+				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - method '"..tostring(method).."' not found on self.", 2)
+			end
+
+			if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
+				local arg=select(1,...)
+				regfunc = function(...) self[method](self,arg,...) end
+			else
+				regfunc = function(...) self[method](self,...) end
+			end
+		else
+			-- function ref with self=object or self="addonId" or self=thread
+			if type(self)~="table" and type(self)~="string" and type(self)~="thread" then
+				error("Usage: "..RegisterName.."(self or \"addonId\", eventname, method): 'self or addonId': table or string or thread expected.", 2)
+			end
+
+			if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
+				local arg=select(1,...)
+				regfunc = function(...) method(arg,...) end
+			else
+				regfunc = method
+			end
+		end
+
+
+		if events[eventname][self] or registry.recurse<1 then
+		-- if registry.recurse<1 then
+			-- we're overwriting an existing entry, or not currently recursing. just set it.
+			events[eventname][self] = regfunc
+			-- fire OnUsed callback?
+			if registry.OnUsed and first then
+				registry.OnUsed(registry, target, eventname)
+			end
+		else
+			-- we're currently processing a callback in this registry, so delay the registration of this new entry!
+			-- yes, we're a bit wasteful on garbage, but this is a fringe case, so we're picking low implementation overhead over garbage efficiency
+			registry.insertQueue = registry.insertQueue or setmetatable({},meta)
+			registry.insertQueue[eventname][self] = regfunc
+		end
+	end
+
+	-- Unregister a callback
+	target[UnregisterName] = function(self, eventname)
+		if not self or self==target then
+			error("Usage: "..UnregisterName.."(eventname): bad 'self'", 2)
+		end
+		if type(eventname) ~= "string" then
+			error("Usage: "..UnregisterName.."(eventname): 'eventname' - string expected.", 2)
+		end
+		if rawget(events, eventname) and events[eventname][self] then
+			events[eventname][self] = nil
+			-- Fire OnUnused callback?
+			if registry.OnUnused and not next(events[eventname]) then
+				registry.OnUnused(registry, target, eventname)
+			end
+		end
+		if registry.insertQueue and rawget(registry.insertQueue, eventname) and registry.insertQueue[eventname][self] then
+			registry.insertQueue[eventname][self] = nil
+		end
+	end
+
+	-- OPTIONAL: Unregister all callbacks for given selfs/addonIds
+	if UnregisterAllName then
+		target[UnregisterAllName] = function(...)
+			if select("#",...)<1 then
+				error("Usage: "..UnregisterAllName.."([whatFor]): missing 'self' or \"addonId\" to unregister events for.", 2)
+			end
+			if select("#",...)==1 and ...==target then
+				error("Usage: "..UnregisterAllName.."([whatFor]): supply a meaningful 'self' or \"addonId\"", 2)
+			end
+
+
+			for i=1,select("#",...) do
+				local self = select(i,...)
+				if registry.insertQueue then
+					for eventname, callbacks in pairs(registry.insertQueue) do
+						if callbacks[self] then
+							callbacks[self] = nil
+						end
+					end
+				end
+				for eventname, callbacks in pairs(events) do
+					if callbacks[self] then
+						callbacks[self] = nil
+						-- Fire OnUnused callback?
+						if registry.OnUnused and not next(callbacks) then
+							registry.OnUnused(registry, target, eventname)
+						end
+					end
+				end
+			end
+		end
+	end
+
+	return registry
+end
+
+
+-- CallbackHandler purposefully does NOT do explicit embedding. Nor does it
+-- try to upgrade old implicit embeds since the system is selfcontained and
+-- relies on closures to work.
+
diff --git a/Carbonite/Libs/CallbackHandler-1.0/CallbackHandler-1.0.xml b/Carbonite/Libs/CallbackHandler-1.0/CallbackHandler-1.0.xml
index a5b22a7..c107f88 100644
--- a/Carbonite/Libs/CallbackHandler-1.0/CallbackHandler-1.0.xml
+++ b/Carbonite/Libs/CallbackHandler-1.0/CallbackHandler-1.0.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="CallbackHandler-1.0.lua"/>
-</Ui>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="CallbackHandler-1.0.lua"/>
+</Ui>
diff --git a/Carbonite/Libs/LibQTip-1.0/LibQTip-1.0.lua b/Carbonite/Libs/LibQTip-1.0/LibQTip-1.0.lua
index 8c1e17f..c236b32 100644
--- a/Carbonite/Libs/LibQTip-1.0/LibQTip-1.0.lua
+++ b/Carbonite/Libs/LibQTip-1.0/LibQTip-1.0.lua
@@ -1,1583 +1,1583 @@
-local MAJOR = "LibQTip-1.0RS"
-local MINOR = 49 -- Should be manually increased
-local LibStub = _G.LibStub
-
-assert(LibStub, MAJOR .. " requires LibStub")
-
-local lib, oldMinor = LibStub:NewLibrary(MAJOR, MINOR)
-
-if not lib then
-    return
-end -- No upgrade needed
-
-------------------------------------------------------------------------------
--- Upvalued globals
-------------------------------------------------------------------------------
-local table = _G.table
-local tinsert = table.insert
-local tremove = table.remove
-local wipe = table.wipe
-
-local error = error
-local math = math
-local min, max = math.min, math.max
-local next = next
-local pairs, ipairs = pairs, ipairs
-local select = select
-local setmetatable = setmetatable
-local tonumber, tostring = tonumber, tostring
-local type = type
-
-local CreateFrame = _G.CreateFrame
-local GameTooltip = _G.GameTooltip
-local UIParent = _G.UIParent
-
-local geterrorhandler = _G.geterrorhandler
-
-------------------------------------------------------------------------------
--- Tables and locals
-------------------------------------------------------------------------------
-lib.frameMetatable = lib.frameMetatable or {__index = CreateFrame("Frame")}
-
-lib.tipPrototype = lib.tipPrototype or setmetatable({}, lib.frameMetatable)
-lib.tipMetatable = lib.tipMetatable or {__index = lib.tipPrototype}
-
-lib.providerPrototype = lib.providerPrototype or {}
-lib.providerMetatable = lib.providerMetatable or {__index = lib.providerPrototype}
-
-lib.cellPrototype = lib.cellPrototype or setmetatable({}, lib.frameMetatable)
-lib.cellMetatable = lib.cellMetatable or {__index = lib.cellPrototype}
-
-lib.activeTooltips = lib.activeTooltips or {}
-
-lib.tooltipHeap = lib.tooltipHeap or {}
-lib.frameHeap = lib.frameHeap or {}
-lib.timerHeap = lib.timerHeap or {}
-lib.tableHeap = lib.tableHeap or {}
-
-lib.onReleaseHandlers = lib.onReleaseHandlers or {}
-
-local tipPrototype = lib.tipPrototype
-local tipMetatable = lib.tipMetatable
-
-local providerPrototype = lib.providerPrototype
-local providerMetatable = lib.providerMetatable
-
-local cellPrototype = lib.cellPrototype
-local cellMetatable = lib.cellMetatable
-
-local activeTooltips = lib.activeTooltips
-
-local highlightFrame = CreateFrame("Frame", nil, UIParent)
-highlightFrame:SetFrameStrata("TOOLTIP")
-highlightFrame:Hide()
-
-local DEFAULT_HIGHLIGHT_TEXTURE_PATH = [[Interface\QuestFrame\UI-QuestTitleHighlight]]
-
-local highlightTexture = highlightFrame:CreateTexture(nil, "OVERLAY")
-highlightTexture:SetTexture(DEFAULT_HIGHLIGHT_TEXTURE_PATH)
-highlightTexture:SetBlendMode("ADD")
-highlightTexture:SetAllPoints(highlightFrame)
-
-------------------------------------------------------------------------------
--- Private methods for Caches and Tooltip
-------------------------------------------------------------------------------
-local AcquireTooltip, ReleaseTooltip
-local AcquireCell, ReleaseCell
-local AcquireTable, ReleaseTable
-
-local InitializeTooltip, SetTooltipSize, ResetTooltipSize, FixCellSizes
-local ClearTooltipScripts
-local SetFrameScript, ClearFrameScripts
-
-------------------------------------------------------------------------------
--- Cache debugging.
-------------------------------------------------------------------------------
--- @debug @
-local usedTables, usedFrames, usedTooltips = 0, 0, 0
---@end-debug@
-
-------------------------------------------------------------------------------
--- Internal constants to tweak the layout
-------------------------------------------------------------------------------
-local TOOLTIP_PADDING = 10
-local CELL_MARGIN_H = 6
-local CELL_MARGIN_V = 3
-
-------------------------------------------------------------------------------
--- Public library API
-------------------------------------------------------------------------------
---- Create or retrieve the tooltip with the given key.
--- If additional arguments are passed, they are passed to :SetColumnLayout for the acquired tooltip.
--- @name LibQTip:Acquire(key[, numColumns, column1Justification, column2justification, ...])
--- @param key string or table - the tooltip key. Any value that can be used as a table key is accepted though you should try to provide unique keys to avoid conflicts.
--- Numbers and booleans should be avoided and strings should be carefully chosen to avoid namespace clashes - no "MyTooltip" - you have been warned!
--- @return tooltip Frame object - the acquired tooltip.
--- @usage Acquire a tooltip with at least 5 columns, justification : left, center, left, left, left
--- <pre>local tip = LibStub('LibQTip-1.0'):Acquire('MyFooBarTooltip', 5, "LEFT", "CENTER")</pre>
-function lib:Acquire(key, ...)
-    if key == nil then
-        error("attempt to use a nil key", 2)
-    end
-
-    local tooltip = activeTooltips[key]
-
-    if not tooltip then
-        tooltip = AcquireTooltip()
-        InitializeTooltip(tooltip, key)
-        activeTooltips[key] = tooltip
-    end
-
-    if select("#", ...) > 0 then
-        -- Here we catch any error to properly report it for the calling code
-        local ok, msg = pcall(tooltip.SetColumnLayout, tooltip, ...)
-
-        if not ok then
-            error(msg, 2)
-        end
-    end
-
-    return tooltip
-end
-
-function lib:Release(tooltip)
-    local key = tooltip and tooltip.key
-
-    if not key or activeTooltips[key] ~= tooltip then
-        return
-    end
-
-    ReleaseTooltip(tooltip)
-    activeTooltips[key] = nil
-end
-
-function lib:IsAcquired(key)
-    if key == nil then
-        error("attempt to use a nil key", 2)
-    end
-
-    return not (not activeTooltips[key])
-end
-
-function lib:IterateTooltips()
-    return pairs(activeTooltips)
-end
-
-------------------------------------------------------------------------------
--- Frame cache (for lines and columns)
-------------------------------------------------------------------------------
-local frameHeap = lib.frameHeap
-
-local function AcquireFrame(parent)
-    local frame = tremove(frameHeap) or CreateFrame("Frame", nil, nil, BackdropTemplateMixin and "BackdropTemplate")
-    frame:SetParent(parent)
-    --[===[@debug@
-    usedFrames = usedFrames + 1
-    --@end-debug@]===]
-    return frame
-end
-
-local function ReleaseFrame(frame)
-    frame:Hide()
-    frame:SetParent(nil)
-    frame:ClearAllPoints()
-    frame:SetBackdrop(nil)
-
-    ClearFrameScripts(frame)
-
-    tinsert(frameHeap, frame)
-    --[===[@debug@
-    usedFrames = usedFrames - 1
-    --@end-debug@]===]
-end
-
-------------------------------------------------------------------------------
--- Timer cache
-------------------------------------------------------------------------------
-local timerHeap = lib.timerHeap
-
-local function AcquireTimer(parent)
-    local frame = tremove(timerHeap) or CreateFrame("Frame")
-    frame:SetParent(parent)
-    return frame
-end
-
-local function ReleaseTimer(frame)
-    frame:Hide()
-    frame:SetParent(nil)
-
-    ClearFrameScripts(frame)
-
-    tinsert(timerHeap, frame)
-end
-
-------------------------------------------------------------------------------
--- Dirty layout handler
-------------------------------------------------------------------------------
-lib.layoutCleaner = lib.layoutCleaner or CreateFrame("Frame")
-
-local layoutCleaner = lib.layoutCleaner
-layoutCleaner.registry = layoutCleaner.registry or {}
-
-function layoutCleaner:RegisterForCleanup(tooltip)
-    self.registry[tooltip] = true
-    self:Show()
-end
-
-function layoutCleaner:CleanupLayouts()
-    self:Hide()
-
-    for tooltip in pairs(self.registry) do
-        FixCellSizes(tooltip)
-    end
-
-    wipe(self.registry)
-end
-
-layoutCleaner:SetScript("OnUpdate", layoutCleaner.CleanupLayouts)
-
-------------------------------------------------------------------------------
--- CellProvider and Cell
-------------------------------------------------------------------------------
-function providerPrototype:AcquireCell()
-    local cell = tremove(self.heap)
-
-    if not cell then
-        cell = CreateFrame("Frame", nil, UIParent, BackdropTemplateMixin and "BackdropTemplate")
-        setmetatable(cell, self.cellMetatable)
-
-        if type(cell.InitializeCell) == "function" then
-            cell:InitializeCell()
-        end
-    end
-
-    self.cells[cell] = true
-
-    return cell
-end
-
-function providerPrototype:ReleaseCell(cell)
-    if not self.cells[cell] then
-        return
-    end
-
-    if type(cell.ReleaseCell) == "function" then
-        cell:ReleaseCell()
-    end
-
-    self.cells[cell] = nil
-    tinsert(self.heap, cell)
-end
-
-function providerPrototype:GetCellPrototype()
-    return self.cellPrototype, self.cellMetatable
-end
-
-function providerPrototype:IterateCells()
-    return pairs(self.cells)
-end
-
-function lib:CreateCellProvider(baseProvider)
-    local cellBaseMetatable, cellBasePrototype
-
-    if baseProvider and baseProvider.GetCellPrototype then
-        cellBasePrototype, cellBaseMetatable = baseProvider:GetCellPrototype()
-    else
-        cellBaseMetatable = cellMetatable
-    end
-
-    local newCellPrototype = setmetatable({}, cellBaseMetatable)
-    local newCellProvider = setmetatable({}, providerMetatable)
-
-    newCellProvider.heap = {}
-    newCellProvider.cells = {}
-    newCellProvider.cellPrototype = newCellPrototype
-    newCellProvider.cellMetatable = {__index = newCellPrototype}
-
-    return newCellProvider, newCellPrototype, cellBasePrototype
-end
-
-------------------------------------------------------------------------------
--- Basic label provider
-------------------------------------------------------------------------------
-if not lib.LabelProvider then
-    lib.LabelProvider, lib.LabelPrototype = lib:CreateCellProvider()
-end
-
-local labelProvider = lib.LabelProvider
-local labelPrototype = lib.LabelPrototype
-
-function labelPrototype:InitializeCell()
-    self.fontString = self:CreateFontString()
-    self.fontString:SetFontObject(_G.GameTooltipText)
-end
-
-function labelPrototype:SetupCell(tooltip, value, justification, font, leftPadding, rightPadding, maxWidth, minWidth, ...)
-    local fontString = self.fontString
-    local line = tooltip.lines[self._line]
-
-    -- detatch fs from cell for size calculations
-    fontString:ClearAllPoints()
-    fontString:SetFontObject(font or (line.is_header and tooltip:GetHeaderFont() or tooltip:GetFont()))
-    fontString:SetJustifyH(justification)
-    fontString:SetText(tostring(value))
-
-    leftPadding = leftPadding or 0
-    rightPadding = rightPadding or 0
-
-    local width = fontString:GetStringWidth() + leftPadding + rightPadding
-
-    if maxWidth and minWidth and (maxWidth < minWidth) then
-        error("maximum width cannot be lower than minimum width: " .. tostring(maxWidth) .. " < " .. tostring(minWidth), 2)
-    end
-
-    if maxWidth and (maxWidth < (leftPadding + rightPadding)) then
-        error("maximum width cannot be lower than the sum of paddings: " .. tostring(maxWidth) .. " < " .. tostring(leftPadding) .. " + " .. tostring(rightPadding), 2)
-    end
-
-    if minWidth and width < minWidth then
-        width = minWidth
-    end
-
-    if maxWidth and maxWidth < width then
-        width = maxWidth
-    end
-
-    fontString:SetWidth(width - (leftPadding + rightPadding))
-    -- Use GetHeight() instead of GetStringHeight() so lines which are longer than width will wrap.
-    local height = fontString:GetHeight()
-
-    -- reanchor fs to cell
-    fontString:SetWidth(0)
-    fontString:SetPoint("TOPLEFT", self, "TOPLEFT", leftPadding, 0)
-    fontString:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -rightPadding, 0)
-    --~ 	fs:SetPoint("TOPRIGHT", self, "TOPRIGHT", -r_pad, 0)
-
-    self._paddingL = leftPadding
-    self._paddingR = rightPadding
-
-    return width, height
-end
-
-function labelPrototype:getContentHeight()
-    local fontString = self.fontString
-    fontString:SetWidth(self:GetWidth() - (self._paddingL + self._paddingR))
-
-    local height = self.fontString:GetHeight()
-    fontString:SetWidth(0)
-
-    return height
-end
-
-function labelPrototype:GetPosition()
-    return self._line, self._column
-end
-
-------------------------------------------------------------------------------
--- Tooltip cache
-------------------------------------------------------------------------------
-local tooltipHeap = lib.tooltipHeap
-
--- Returns a tooltip
-function AcquireTooltip()
-    local tooltip = tremove(tooltipHeap)
-
-    if not tooltip then
-        local template = (TooltipBackdropTemplateMixin and "TooltipBackdropTemplate") or (BackdropTemplateMixin and "BackdropTemplate")
-        tooltip = CreateFrame("Frame", nil, UIParent, template)
-
-        local scrollFrame = CreateFrame("ScrollFrame", nil, tooltip)
-        scrollFrame:SetPoint("TOP", tooltip, "TOP", 0, -TOOLTIP_PADDING)
-        scrollFrame:SetPoint("BOTTOM", tooltip, "BOTTOM", 0, TOOLTIP_PADDING)
-        scrollFrame:SetPoint("LEFT", tooltip, "LEFT", TOOLTIP_PADDING, 0)
-        scrollFrame:SetPoint("RIGHT", tooltip, "RIGHT", -TOOLTIP_PADDING, 0)
-        tooltip.scrollFrame = scrollFrame
-
-        local scrollChild = CreateFrame("Frame", nil, tooltip.scrollFrame)
-        scrollFrame:SetScrollChild(scrollChild)
-        tooltip.scrollChild = scrollChild
-
-        setmetatable(tooltip, tipMetatable)
-    end
-
-    --[===[@debug@
-    usedTooltips = usedTooltips + 1
-    --@end-debug@]===]
-    return tooltip
-end
-
--- Cleans the tooltip and stores it in the cache
-function ReleaseTooltip(tooltip)
-    if tooltip.releasing then
-        return
-    end
-
-    tooltip.releasing = true
-    tooltip:Hide()
-
-    local releaseHandler = lib.onReleaseHandlers[tooltip]
-
-    if releaseHandler then
-        lib.onReleaseHandlers[tooltip] = nil
-
-        local success, errorMessage = pcall(releaseHandler, tooltip)
-
-        if not success then
-            geterrorhandler()(errorMessage)
-        end
-    elseif tooltip.OnRelease then
-        local success, errorMessage = pcall(tooltip.OnRelease, tooltip)
-        if not success then
-            geterrorhandler()(errorMessage)
-        end
-
-        tooltip.OnRelease = nil
-    end
-
-    tooltip.releasing = nil
-    tooltip.key = nil
-    tooltip.step = nil
-
-    ClearTooltipScripts(tooltip)
-
-    tooltip:SetAutoHideDelay(nil)
-    tooltip:ClearAllPoints()
-    tooltip:Clear()
-
-    if tooltip.slider then
-        tooltip.slider:SetValue(0)
-        tooltip.slider:Hide()
-        tooltip.scrollFrame:SetPoint("RIGHT", tooltip, "RIGHT", -TOOLTIP_PADDING, 0)
-        tooltip:EnableMouseWheel(false)
-    end
-
-    for i, column in ipairs(tooltip.columns) do
-        tooltip.columns[i] = ReleaseFrame(column)
-    end
-
-    tooltip.columns = ReleaseTable(tooltip.columns)
-    tooltip.lines = ReleaseTable(tooltip.lines)
-    tooltip.colspans = ReleaseTable(tooltip.colspans)
-
-    layoutCleaner.registry[tooltip] = nil
-
-    if TooltipBackdropTemplateMixin and not tooltip.NineSlice then
-        -- don't recycle outdated tooltips into heap
-        tooltip = nil
-    end
-
-    if tooltip then
-        tinsert(tooltipHeap, tooltip)
-    end
-
-    highlightTexture:SetTexture(DEFAULT_HIGHLIGHT_TEXTURE_PATH)
-    highlightTexture:SetTexCoord(0, 1, 0, 1)
-
-    --[===[@debug@
-    usedTooltips = usedTooltips - 1
-    --@end-debug@]===]
-end
-
-------------------------------------------------------------------------------
--- Cell 'cache' (just a wrapper to the provider's cache)
-------------------------------------------------------------------------------
--- Returns a cell for the given tooltip from the given provider
-function AcquireCell(tooltip, provider)
-    local cell = provider:AcquireCell(tooltip)
-
-    cell:SetParent(tooltip.scrollChild)
-    cell:SetFrameLevel(tooltip.scrollChild:GetFrameLevel() + 3)
-    cell._provider = provider
-
-    return cell
-end
-
--- Cleans the cell hands it to its provider for storing
-function ReleaseCell(cell)
-    if cell.fontString and cell.r then
-        cell.fontString:SetTextColor(cell.r, cell.g, cell.b, cell.a)
-    end
-
-    cell._font = nil
-    cell._justification = nil
-    cell._colSpan = nil
-    cell._line = nil
-    cell._column = nil
-
-    cell:Hide()
-    cell:ClearAllPoints()
-    cell:SetParent(nil)
-    cell:SetBackdrop(nil)
-
-    ClearFrameScripts(cell)
-
-    cell._provider:ReleaseCell(cell)
-    cell._provider = nil
-end
-
-------------------------------------------------------------------------------
--- Table cache
-------------------------------------------------------------------------------
-local tableHeap = lib.tableHeap
-
--- Returns a table
-function AcquireTable()
-    local tbl = tremove(tableHeap) or {}
-    --[===[@debug@
-    usedTables = usedTables + 1
-    --@end-debug@]===]
-    return tbl
-end
-
--- Cleans the table and stores it in the cache
-function ReleaseTable(tableInstance)
-    wipe(tableInstance)
-    tinsert(tableHeap, tableInstance)
-    --[===[@debug@
-    usedTables = usedTables - 1
-    --@end-debug@]===]
-end
-
-------------------------------------------------------------------------------
--- Tooltip prototype
-------------------------------------------------------------------------------
-function InitializeTooltip(tooltip, key)
-    ----------------------------------------------------------------------
-    -- (Re)set frame settings
-    ----------------------------------------------------------------------
-    if TooltipBackdropTemplateMixin then
-        tooltip.layoutType = GameTooltip.layoutType
-        NineSlicePanelMixin.OnLoad(tooltip.NineSlice)
-        if GameTooltip.layoutType then
-            tooltip.NineSlice:SetCenterColor(GameTooltip.NineSlice:GetCenterColor())
-            tooltip.NineSlice:SetBorderColor(GameTooltip.NineSlice:GetBorderColor())
-        end
-    else
-        local backdrop = GameTooltip:GetBackdrop()
-
-        tooltip:SetBackdrop(backdrop)
-
-        if backdrop then
-            tooltip:SetBackdropColor(GameTooltip:GetBackdropColor())
-            tooltip:SetBackdropBorderColor(GameTooltip:GetBackdropBorderColor())
-        end
-    end
-
-    tooltip:SetScale(GameTooltip:GetScale())
-    tooltip:SetAlpha(1)
-    tooltip:SetFrameStrata("TOOLTIP")
-    tooltip:SetClampedToScreen(false)
-
-    ----------------------------------------------------------------------
-    -- Internal data. Since it's possible to Acquire twice without calling
-    -- release, check for pre-existence.
-    ----------------------------------------------------------------------
-    tooltip.key = key
-    tooltip.columns = tooltip.columns or AcquireTable()
-    tooltip.lines = tooltip.lines or AcquireTable()
-    tooltip.colspans = tooltip.colspans or AcquireTable()
-    tooltip.regularFont = _G.GameTooltipText
-    tooltip.headerFont = _G.GameTooltipHeaderText
-    tooltip.labelProvider = labelProvider
-    tooltip.cell_margin_h = tooltip.cell_margin_h or CELL_MARGIN_H
-    tooltip.cell_margin_v = tooltip.cell_margin_v or CELL_MARGIN_V
-
-    ----------------------------------------------------------------------
-    -- Finishing procedures
-    ----------------------------------------------------------------------
-    tooltip:SetAutoHideDelay(nil)
-    tooltip:Hide()
-    ResetTooltipSize(tooltip)
-end
-
-function tipPrototype:SetDefaultProvider(myProvider)
-    if not myProvider then
-        return
-    end
-
-    self.labelProvider = myProvider
-end
-
-function tipPrototype:GetDefaultProvider()
-    return self.labelProvider
-end
-
-local function checkJustification(justification, level, silent)
-    if justification ~= "LEFT" and justification ~= "CENTER" and justification ~= "RIGHT" then
-        if silent then
-            return false
-        end
-        error("invalid justification, must one of LEFT, CENTER or RIGHT, not: " .. tostring(justification), level + 1)
-    end
-
-    return true
-end
-
-function tipPrototype:SetColumnLayout(numColumns, ...)
-    if type(numColumns) ~= "number" or numColumns < 1 then
-        error("number of columns must be a positive number, not: " .. tostring(numColumns), 2)
-    end
-
-    for i = 1, numColumns do
-        local justification = select(i, ...) or "LEFT"
-
-        checkJustification(justification, 2)
-
-        if self.columns[i] then
-            self.columns[i].justification = justification
-        else
-            self:AddColumn(justification)
-        end
-    end
-end
-
-function tipPrototype:AddColumn(justification)
-    justification = justification or "LEFT"
-    checkJustification(justification, 2)
-
-    local colNum = #self.columns + 1
-    local column = self.columns[colNum] or AcquireFrame(self.scrollChild)
-
-    column:SetFrameLevel(self.scrollChild:GetFrameLevel() + 1)
-    column.justification = justification
-    column.width = 0
-    column:SetWidth(1)
-    column:SetPoint("TOP", self.scrollChild)
-    column:SetPoint("BOTTOM", self.scrollChild)
-
-    if colNum > 1 then
-        local h_margin = self.cell_margin_h or CELL_MARGIN_H
-
-        column:SetPoint("LEFT", self.columns[colNum - 1], "RIGHT", h_margin, 0)
-        SetTooltipSize(self, self.width + h_margin, self.height)
-    else
-        column:SetPoint("LEFT", self.scrollChild)
-    end
-
-    column:Show()
-    self.columns[colNum] = column
-
-    return colNum
-end
-
-------------------------------------------------------------------------------
--- Convenient methods
-------------------------------------------------------------------------------
-function tipPrototype:Release()
-    lib:Release(self)
-end
-
-function tipPrototype:IsAcquiredBy(key)
-    return key ~= nil and self.key == key
-end
-
-------------------------------------------------------------------------------
--- Script hooks
-------------------------------------------------------------------------------
-local RawSetScript = lib.frameMetatable.__index.SetScript
-
-function ClearTooltipScripts(tooltip)
-    if tooltip.scripts then
-        for scriptType in pairs(tooltip.scripts) do
-            RawSetScript(tooltip, scriptType, nil)
-        end
-
-        tooltip.scripts = ReleaseTable(tooltip.scripts)
-    end
-end
-
-function tipPrototype:SetScript(scriptType, handler)
-    RawSetScript(self, scriptType, handler)
-
-    if handler then
-        if not self.scripts then
-            self.scripts = AcquireTable()
-        end
-
-        self.scripts[scriptType] = true
-    elseif self.scripts then
-        self.scripts[scriptType] = nil
-    end
-end
-
--- That might break some addons ; those addons were breaking other
--- addons' tooltip though.
-function tipPrototype:HookScript()
-    geterrorhandler()(":HookScript is not allowed on LibQTip tooltips")
-end
-
-------------------------------------------------------------------------------
--- Scrollbar data and functions
-------------------------------------------------------------------------------
-local BACKDROP_SLIDER_8_8 = BACKDROP_SLIDER_8_8 or {
-    bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
-    edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
-    tile = true,
-    tileEdge = true,
-    tileSize = 8,
-    edgeSize = 8,
-    insets = { left = 3, right = 3, top = 6, bottom = 6 },
-};
-
-local function slider_OnValueChanged(self)
-    self.scrollFrame:SetVerticalScroll(self:GetValue())
-end
-
-local function tooltip_OnMouseWheel(self, delta)
-    local slider = self.slider
-    local currentValue = slider:GetValue()
-    local minValue, maxValue = slider:GetMinMaxValues()
-    local stepValue = self.step or 10
-
-    if delta < 0 and currentValue < maxValue then
-        slider:SetValue(min(maxValue, currentValue + stepValue))
-    elseif delta > 0 and currentValue > minValue then
-        slider:SetValue(max(minValue, currentValue - stepValue))
-    end
-end
-
--- Set the step size for the scroll bar
-function tipPrototype:SetScrollStep(step)
-    self.step = step
-end
-
--- will resize the tooltip to fit the screen and show a scrollbar if needed
-function tipPrototype:UpdateScrolling(maxheight)
-    self:SetClampedToScreen(false)
-
-    -- all data is in the tooltip; fix colspan width and prevent the layout cleaner from messing up the tooltip later
-    FixCellSizes(self)
-    layoutCleaner.registry[self] = nil
-
-    local scale = self:GetScale()
-    local topside = self:GetTop()
-    local bottomside = self:GetBottom()
-    local screensize = UIParent:GetHeight() / scale
-    local tipsize = (topside - bottomside)
-
-    -- if the tooltip would be too high, limit its height and show the slider
-    if bottomside < 0 or topside > screensize or (maxheight and tipsize > maxheight) then
-        local shrink = (bottomside < 0 and (5 - bottomside) or 0) + (topside > screensize and (topside - screensize + 5) or 0)
-
-        if maxheight and tipsize - shrink > maxheight then
-            shrink = tipsize - maxheight
-        end
-
-        self:SetHeight(2 * TOOLTIP_PADDING + self.height - shrink)
-        self:SetWidth(2 * TOOLTIP_PADDING + self.width + 20)
-        self.scrollFrame:SetPoint("RIGHT", self, "RIGHT", -(TOOLTIP_PADDING + 20), 0)
-
-        if not self.slider then
-            local slider = CreateFrame("Slider", nil, self, BackdropTemplateMixin and "BackdropTemplate")
-            slider.scrollFrame = self.scrollFrame
-
-            slider:SetOrientation("VERTICAL")
-            slider:SetPoint("TOPRIGHT", self, "TOPRIGHT", -TOOLTIP_PADDING, -TOOLTIP_PADDING)
-            slider:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -TOOLTIP_PADDING, TOOLTIP_PADDING)
-            slider:SetBackdrop(BACKDROP_SLIDER_8_8)
-            slider:SetThumbTexture([[Interface\Buttons\UI-SliderBar-Button-Vertical]])
-            slider:SetMinMaxValues(0, 1)
-            slider:SetValueStep(1)
-            slider:SetWidth(12)
-            slider:SetScript("OnValueChanged", slider_OnValueChanged)
-            slider:SetValue(0)
-
-            self.slider = slider
-        end
-
-        self.slider:SetMinMaxValues(0, shrink)
-        self.slider:Show()
-
-        self:EnableMouseWheel(true)
-        self:SetScript("OnMouseWheel", tooltip_OnMouseWheel)
-    else
-        self:SetHeight(2 * TOOLTIP_PADDING + self.height)
-        self:SetWidth(2 * TOOLTIP_PADDING + self.width)
-
-        self.scrollFrame:SetPoint("RIGHT", self, "RIGHT", -TOOLTIP_PADDING, 0)
-
-        if self.slider then
-            self.slider:SetValue(0)
-            self.slider:Hide()
-
-            self:EnableMouseWheel(false)
-            self:SetScript("OnMouseWheel", nil)
-        end
-    end
-end
-
-------------------------------------------------------------------------------
--- Tooltip methods for changing its contents.
-------------------------------------------------------------------------------
-function tipPrototype:Clear()
-    for i, line in ipairs(self.lines) do
-        for _, cell in pairs(line.cells) do
-            if cell then
-                ReleaseCell(cell)
-            end
-        end
-
-        ReleaseTable(line.cells)
-
-        line.cells = nil
-        line.is_header = nil
-
-        ReleaseFrame(line)
-
-        self.lines[i] = nil
-    end
-
-    for _, column in ipairs(self.columns) do
-        column.width = 0
-        column:SetWidth(1)
-    end
-
-    wipe(self.colspans)
-
-    self.cell_margin_h = nil
-    self.cell_margin_v = nil
-
-    ResetTooltipSize(self)
-end
-
-function tipPrototype:SetCellMarginH(size)
-    if #self.lines > 0 then
-       -- error("Unable to set horizontal margin while the tooltip has lines.", 2)
-       return
-    end
-
-    if not size or type(size) ~= "number" or size < 0 then
-        --error("Margin size must be a positive number or zero.", 2)
-        return
-    end
-
-    self.cell_margin_h = size
-end
-
-function tipPrototype:SetCellMarginV(size)
-    if #self.lines > 0 then
-        error("Unable to set vertical margin while the tooltip has lines.", 2)
-    end
-
-    if not size or type(size) ~= "number" or size < 0 then
-        error("Margin size must be a positive number or zero.", 2)
-    end
-
-    self.cell_margin_v = size
-end
-
-function SetTooltipSize(tooltip, width, height)
-    tooltip.height = height
-    tooltip.width = width
-
-    tooltip:SetHeight(2 * TOOLTIP_PADDING + height)
-    tooltip:SetWidth(2 * TOOLTIP_PADDING + width)
-
-    tooltip.scrollChild:SetHeight(height)
-    tooltip.scrollChild:SetWidth(width)
-end
-
--- Add 2 pixels to height so dangling letters (g, y, p, j, etc) are not clipped.
-function ResetTooltipSize(tooltip)
-    local h_margin = tooltip.cell_margin_h or CELL_MARGIN_H
-
-    SetTooltipSize(tooltip, max(0, (h_margin * (#tooltip.columns - 1)) + (h_margin / 2)), 2)
-end
-
-local function EnlargeColumn(tooltip, column, width)
-    if width > column.width then
-        SetTooltipSize(tooltip, tooltip.width + width - column.width, tooltip.height)
-
-        column.width = width
-        column:SetWidth(width)
-    end
-end
-
-local function ResizeLine(tooltip, line, height)
-    SetTooltipSize(tooltip, tooltip.width, tooltip.height + height - line.height)
-
-    line.height = height
-    line:SetHeight(height)
-end
-
-function FixCellSizes(tooltip)
-    local columns = tooltip.columns
-    local colspans = tooltip.colspans
-    local lines = tooltip.lines
-    local h_margin = tooltip.cell_margin_h or CELL_MARGIN_H
-
-    -- resize columns to make room for the colspans
-    while next(colspans) do
-        local maxNeedCols
-        local maxNeedWidthPerCol = 0
-
-        -- calculate the colspan with the highest additional width need per column
-        for colRange, width in pairs(colspans) do
-            local left, right = colRange:match("^(%d+)%-(%d+)$")
-
-            left, right = tonumber(left), tonumber(right)
-
-            for col = left, right - 1 do
-                width = width - columns[col].width - h_margin
-            end
-
-            width = width - columns[right].width
-
-            if width <= 0 then
-                colspans[colRange] = nil
-            else
-                width = width / (right - left + 1)
-
-                if width > maxNeedWidthPerCol then
-                    maxNeedCols = colRange
-                    maxNeedWidthPerCol = width
-                end
-            end
-        end
-
-        -- resize all columns for that colspan
-        if maxNeedCols then
-            local left, right = maxNeedCols:match("^(%d+)%-(%d+)$")
-
-            for col = left, right do
-                EnlargeColumn(tooltip, columns[col], columns[col].width + maxNeedWidthPerCol)
-            end
-
-            colspans[maxNeedCols] = nil
-        end
-    end
-
-    --now that the cell width is set, recalculate the rows' height
-    for _, line in ipairs(lines) do
-        if #(line.cells) > 0 then
-            local lineheight = 0
-
-            for _, cell in pairs(line.cells) do
-                if cell then
-                    lineheight = max(lineheight, cell:getContentHeight())
-                end
-            end
-
-            if lineheight > 0 then
-                ResizeLine(tooltip, line, lineheight)
-            end
-        end
-    end
-end
-
-local function _SetCell(tooltip, lineNum, colNum, value, font, justification, colSpan, provider, ...)
-    local line = tooltip.lines[lineNum]
-    local cells = line.cells
-
-    -- Unset: be quick
-    if value == nil then
-        local cell = cells[colNum]
-
-        if cell then
-            for i = colNum, colNum + cell._colSpan - 1 do
-                cells[i] = nil
-            end
-
-            ReleaseCell(cell)
-        end
-
-        return lineNum, colNum
-    end
-
-    font = font or (line.is_header and tooltip.headerFont or tooltip.regularFont)
-
-    -- Check previous cell
-    local cell
-    local prevCell = cells[colNum]
-
-    if prevCell then
-        -- There is a cell here
-        justification = justification or prevCell._justification
-        colSpan = colSpan or prevCell._colSpan
-
-        -- Clear the currently marked colspan
-        for i = colNum + 1, colNum + prevCell._colSpan - 1 do
-            cells[i] = nil
-        end
-
-        if provider == nil or prevCell._provider == provider then
-            -- Reuse existing cell
-            cell = prevCell
-            provider = cell._provider
-        else
-            -- A new cell is required
-            cells[colNum] = ReleaseCell(prevCell)
-        end
-    elseif prevCell == nil then
-        -- Creating a new cell, using meaningful defaults.
-        provider = provider or tooltip.labelProvider
-        justification = justification or tooltip.columns[colNum].justification or "LEFT"
-        colSpan = colSpan or 1
-    else
-        error("overlapping cells at column " .. colNum, 3)
-    end
-
-    local tooltipWidth = #tooltip.columns
-    local rightColNum
-
-    if colSpan > 0 then
-        rightColNum = colNum + colSpan - 1
-
-        if rightColNum > tooltipWidth then
-            error("ColSpan too big, cell extends beyond right-most column", 3)
-        end
-    else
-        -- Zero or negative: count back from right-most columns
-        rightColNum = max(colNum, tooltipWidth + colSpan)
-        -- Update colspan to its effective value
-        colSpan = 1 + rightColNum - colNum
-    end
-
-    -- Cleanup colspans
-    for i = colNum + 1, rightColNum do
-        local columnCell = cells[i]
-
-        if columnCell then
-            ReleaseCell(columnCell)
-        elseif columnCell == false then
-            error("overlapping cells at column " .. i, 3)
-        end
-
-        cells[i] = false
-    end
-
-    -- Create the cell
-    if not cell then
-        cell = AcquireCell(tooltip, provider)
-        cells[colNum] = cell
-    end
-
-    -- Anchor the cell
-    cell:SetPoint("LEFT", tooltip.columns[colNum])
-    cell:SetPoint("RIGHT", tooltip.columns[rightColNum])
-    cell:SetPoint("TOP", line)
-    cell:SetPoint("BOTTOM", line)
-
-    -- Store the cell settings directly into the cell
-    -- That's a bit risky but is really cheap compared to other ways to do it
-    cell._font, cell._justification, cell._colSpan, cell._line, cell._column = font, justification, colSpan, lineNum, colNum
-
-    -- Setup the cell content
-    local width, height = cell:SetupCell(tooltip, value, justification, font, ...)
-    cell:Show()
-
-    if colSpan > 1 then
-        -- Postpone width changes until the tooltip is shown
-        local colRange = colNum .. "-" .. rightColNum
-
-        tooltip.colspans[colRange] = max(tooltip.colspans[colRange] or 0, width)
-        layoutCleaner:RegisterForCleanup(tooltip)
-    else
-        -- Enlarge the column and tooltip if need be
-        EnlargeColumn(tooltip, tooltip.columns[colNum], width)
-    end
-
-    -- Enlarge the line and tooltip if need be
-    if height > line.height then
-        SetTooltipSize(tooltip, tooltip.width, tooltip.height + height - line.height)
-
-        line.height = height
-        line:SetHeight(height)
-    end
-
-    if rightColNum < tooltipWidth then
-        return lineNum, rightColNum + 1
-    else
-        return lineNum, nil
-    end
-end
-
-do
-    local function CreateLine(tooltip, font, ...)
-        if #tooltip.columns == 0 then
-            error("column layout should be defined before adding line", 3)
-        end
-
-        local lineNum = #tooltip.lines + 1
-        local line = tooltip.lines[lineNum] or AcquireFrame(tooltip.scrollChild)
-
-        line:SetFrameLevel(tooltip.scrollChild:GetFrameLevel() + 2)
-        line:SetPoint("LEFT", tooltip.scrollChild)
-        line:SetPoint("RIGHT", tooltip.scrollChild)
-
-        if lineNum > 1 then
-            local v_margin = tooltip.cell_margin_v or CELL_MARGIN_V
-
-            line:SetPoint("TOP", tooltip.lines[lineNum - 1], "BOTTOM", 0, -v_margin)
-            SetTooltipSize(tooltip, tooltip.width, tooltip.height + v_margin)
-        else
-            line:SetPoint("TOP", tooltip.scrollChild)
-        end
-
-        tooltip.lines[lineNum] = line
-
-        line.cells = line.cells or AcquireTable()
-        line.height = 0
-        line:SetHeight(1)
-        line:Show()
-
-        local colNum = 1
-
-        for i = 1, #tooltip.columns do
-            local value = select(i, ...)
-
-            if value ~= nil then
-                lineNum, colNum = _SetCell(tooltip, lineNum, i, value, font, nil, 1, tooltip.labelProvider)
-            end
-        end
-
-        return lineNum, colNum
-    end
-
-    function tipPrototype:AddLine(...)
-        return CreateLine(self, self.regularFont, ...)
-    end
-
-    function tipPrototype:AddHeader(...)
-        local line, col = CreateLine(self, self.headerFont, ...)
-
-        self.lines[line].is_header = true
-
-        return line, col
-    end
-end -- do-block
-
-local GenericBackdrop = {
-    bgFile = "Interface\\Tooltips\\UI-Tooltip-Background"
-}
-
-function tipPrototype:AddSeparator(height, r, g, b, a)
-    local lineNum, colNum = self:AddLine()
-    local line = self.lines[lineNum]
-    local color = _G.NORMAL_FONT_COLOR
-
-    height = height or 1
-
-    SetTooltipSize(self, self.width, self.height + height)
-
-    line.height = height
-    line:SetHeight(height)
-    line:SetBackdrop(GenericBackdrop)
-    line:SetBackdropColor(r or color.r, g or color.g, b or color.b, a or 1)
-
-    return lineNum, colNum
-end
-
-function tipPrototype:SetCellColor(lineNum, colNum, r, g, b, a)
-    local cell = self.lines[lineNum].cells[colNum]
-
-    if cell then
-        local sr, sg, sb, sa = self:GetBackdropColor()
-
-        cell:SetBackdrop(GenericBackdrop)
-        cell:SetBackdropColor(r or sr, g or sg, b or sb, a or sa)
-    end
-end
-
-function tipPrototype:SetColumnColor(colNum, r, g, b, a)
-    local column = self.columns[colNum]
-
-    if column then
-        local sr, sg, sb, sa = self:GetBackdropColor()
-        column:SetBackdrop(GenericBackdrop)
-        column:SetBackdropColor(r or sr, g or sg, b or sb, a or sa)
-    end
-end
-
-function tipPrototype:SetLineColor(lineNum, r, g, b, a)
-    local line = self.lines[lineNum]
-
-    if line then
-        local sr, sg, sb, sa = self:GetBackdropColor()
-
-        line:SetBackdrop(GenericBackdrop)
-        line:SetBackdropColor(r or sr, g or sg, b or sb, a or sa)
-    end
-end
-
-function tipPrototype:SetCellTextColor(lineNum, colNum, r, g, b, a)
-    local line = self.lines[lineNum]
-    local column = self.columns[colNum]
-
-    if not line or not column then
-        return
-    end
-
-    local cell = self.lines[lineNum].cells[colNum]
-
-    if cell then
-        if not cell.fontString then
-            error("cell's label provider did not assign a fontString field", 2)
-        end
-
-        if not cell.r then
-            cell.r, cell.g, cell.b, cell.a = cell.fontString:GetTextColor()
-        end
-
-        cell.fontString:SetTextColor(r or cell.r, g or cell.g, b or cell.b, a or cell.a)
-    end
-end
-
-function tipPrototype:SetColumnTextColor(colNum, r, g, b, a)
-    if not self.columns[colNum] then
-        return
-    end
-
-    for lineIndex = 1, #self.lines do
-        self:SetCellTextColor(lineIndex, colNum, r, g, b, a)
-    end
-end
-
-function tipPrototype:SetLineTextColor(lineNum, r, g, b, a)
-    local line = self.lines[lineNum]
-
-    if not line then
-        return
-    end
-
-    for cellIndex = 1, #line.cells do
-        self:SetCellTextColor(lineNum, line.cells[cellIndex]._column, r, g, b, a)
-    end
-end
-
-function tipPrototype:SetHighlightTexture(...)
-    return highlightTexture:SetTexture(...)
-end
-
-function tipPrototype:SetHighlightTexCoord(...)
-    highlightTexture:SetTexCoord(...)
-end
-
-do
-    local function checkFont(font, level, silent)
-        local bad = false
-
-        if not font then
-            bad = true
-        elseif type(font) == "string" then
-            local ref = _G[font]
-
-            if not ref or type(ref) ~= "table" or type(ref.IsObjectType) ~= "function" or not ref:IsObjectType("Font") then
-                bad = true
-            end
-        elseif type(font) ~= "table" or type(font.IsObjectType) ~= "function" or not font:IsObjectType("Font") then
-            bad = true
-        end
-
-        if bad then
-            if silent then
-                return false
-            end
-
-            error("font must be a Font instance or a string matching the name of a global Font instance, not: " .. tostring(font), level + 1)
-        end
-        return true
-    end
-
-    function tipPrototype:SetFont(font)
-        local is_string = type(font) == "string"
-
-        checkFont(font, 2)
-        self.regularFont = is_string and _G[font] or font
-    end
-
-    function tipPrototype:SetHeaderFont(font)
-        local is_string = type(font) == "string"
-
-        checkFont(font, 2)
-        self.headerFont = is_string and _G[font] or font
-    end
-
-    -- TODO: fixed argument positions / remove checks for performance?
-    function tipPrototype:SetCell(lineNum, colNum, value, ...)
-        -- Mandatory argument checking
-        if type(lineNum) ~= "number" then
-            error("line number must be a number, not: " .. tostring(lineNum), 2)
-        elseif lineNum < 1 or lineNum > #self.lines then
-            error("line number out of range: " .. tostring(lineNum), 2)
-        elseif type(colNum) ~= "number" then
-            error("column number must be a number, not: " .. tostring(colNum), 2)
-        elseif colNum < 1 or colNum > #self.columns then
-            error("column number out of range: " .. tostring(colNum), 2)
-        end
-
-        -- Variable argument checking
-        local font, justification, colSpan, provider
-        local i, arg = 1, ...
-
-        if arg == nil or checkFont(arg, 2, true) then
-            i, font, arg = 2, ...
-        end
-
-        if arg == nil or checkJustification(arg, 2, true) then
-            i, justification, arg = i + 1, select(i, ...)
-        end
-
-        if arg == nil or type(arg) == "number" then
-            i, colSpan, arg = i + 1, select(i, ...)
-        end
-
-        if arg == nil or type(arg) == "table" and type(arg.AcquireCell) == "function" then
-            i, provider = i + 1, arg
-        end
-
-        return _SetCell(self, lineNum, colNum, value, font, justification, colSpan, provider, select(i, ...))
-    end
-end -- do-block
-
-function tipPrototype:GetFont()
-    return self.regularFont
-end
-
-function tipPrototype:GetHeaderFont()
-    return self.headerFont
-end
-
-function tipPrototype:GetLineCount()
-    return #self.lines
-end
-
-function tipPrototype:GetColumnCount()
-    return #self.columns
-end
-
-------------------------------------------------------------------------------
--- Frame Scripts
-------------------------------------------------------------------------------
-local scripts = {
-    OnEnter = function(frame, ...)
-        highlightFrame:SetParent(frame)
-        highlightFrame:SetAllPoints(frame)
-        highlightFrame:Show()
-
-        if frame._OnEnter_func then
-            frame:_OnEnter_func(frame._OnEnter_arg, ...)
-        end
-    end,
-    OnLeave = function(frame, ...)
-        highlightFrame:Hide()
-        highlightFrame:ClearAllPoints()
-        highlightFrame:SetParent(nil)
-
-        if frame._OnLeave_func then
-            frame:_OnLeave_func(frame._OnLeave_arg, ...)
-        end
-    end,
-    OnMouseDown = function(frame, ...)
-        frame:_OnMouseDown_func(frame._OnMouseDown_arg, ...)
-    end,
-    OnMouseUp = function(frame, ...)
-        frame:_OnMouseUp_func(frame._OnMouseUp_arg, ...)
-    end,
-    OnReceiveDrag = function(frame, ...)
-        frame:_OnReceiveDrag_func(frame._OnReceiveDrag_arg, ...)
-    end,
-	-- SUPPORT FOR MORE EVENTS
-	OnEvent = function(frame, ...)
-		frame:_OnEvent_func(frame._OnEvent_arg, ...)
-	end,
-}
-
-function SetFrameScript(frame, script, func, arg)
-    if not scripts[script] then
-        return
-    end
-
-    frame["_" .. script .. "_func"] = func
-    frame["_" .. script .. "_arg"] = arg
-
-    if script == "OnMouseDown" or script == "OnMouseUp" or script == "OnReceiveDrag" then
-        if func then
-            frame:SetScript(script, scripts[script])
-        else
-            frame:SetScript(script, nil)
-        end
-    end
-	
-	-- SUPPORT FOR MORE EVENTS
-	if script == "OnEvent" then
-		if func then
-			frame:RegisterEvent("MODIFIER_STATE_CHANGED")
-			frame:SetScript(script, scripts[script])
-		else
-			frame:SetScript(script, nil)
-		end
-	end
-
-    -- if at least one script is set, set the OnEnter/OnLeave scripts for the highlight
-    if frame._OnEnter_func or frame._OnLeave_func or frame._OnMouseDown_func or frame._OnMouseUp_func or frame._OnReceiveDrag_func then
-        frame:EnableMouse(true)
-        frame:SetScript("OnEnter", scripts.OnEnter)
-        frame:SetScript("OnLeave", scripts.OnLeave)
-    else
-        frame:EnableMouse(false)
-        frame:SetScript("OnEnter", nil)
-        frame:SetScript("OnLeave", nil)
-    end
-end
-
-function ClearFrameScripts(frame)
-    if frame._OnEnter_func or frame._OnLeave_func or frame._OnMouseDown_func or frame._OnMouseUp_func or frame._OnReceiveDrag_func then
-        frame:EnableMouse(false)
-
-        frame:SetScript("OnEnter", nil)
-        frame._OnEnter_func = nil
-        frame._OnEnter_arg = nil
-
-        frame:SetScript("OnLeave", nil)
-        frame._OnLeave_func = nil
-        frame._OnLeave_arg = nil
-
-        frame:SetScript("OnReceiveDrag", nil)
-        frame._OnReceiveDrag_func = nil
-        frame._OnReceiveDrag_arg = nil
-
-        frame:SetScript("OnMouseDown", nil)
-        frame._OnMouseDown_func = nil
-        frame._OnMouseDown_arg = nil
-
-        frame:SetScript("OnMouseUp", nil)
-        frame._OnMouseUp_func = nil
-        frame._OnMouseUp_arg = nil
-	elseif frame._OnEvent_func then
-		frame:SetScript("OnEvent", nil)
-		frame._OnEvent_func = nil
-		frame._OnEvent_arg = nil
-		frame:UnregisterEvent("MODIFIER_STATE_CHANGED")
-	end
-end
-
-function tipPrototype:SetLineScript(lineNum, script, func, arg)
-    SetFrameScript(self.lines[lineNum], script, func, arg)
-end
-
-function tipPrototype:SetColumnScript(colNum, script, func, arg)
-    SetFrameScript(self.columns[colNum], script, func, arg)
-end
-
-function tipPrototype:SetCellScript(lineNum, colNum, script, func, arg)
-    local cell = self.lines[lineNum].cells[colNum]
-
-    if cell then
-        SetFrameScript(cell, script, func, arg)
-    end
-end
-
-------------------------------------------------------------------------------
--- Auto-hiding feature
-------------------------------------------------------------------------------
-
--- Script of the auto-hiding child frame
-local function AutoHideTimerFrame_OnUpdate(self, elapsed)
-    self.checkElapsed = self.checkElapsed + elapsed
-
-    if self.checkElapsed > 0.1 then
-        if self.parent:IsMouseOver() or (self.alternateFrame and self.alternateFrame:IsMouseOver()) then
-            self.elapsed = 0
-        else
-            self.elapsed = self.elapsed + self.checkElapsed
-
-            if self.elapsed >= self.delay then
-                lib:Release(self.parent)
-            end
-        end
-
-        self.checkElapsed = 0
-    end
-end
-
--- Usage:
--- :SetAutoHideDelay(0.25) => hides after 0.25sec outside of the tooltip
--- :SetAutoHideDelay(0.25, someFrame) => hides after 0.25sec outside of both the tooltip and someFrame
--- :SetAutoHideDelay() => disable auto-hiding (default)
-function tipPrototype:SetAutoHideDelay(delay, alternateFrame, releaseHandler)
-    local timerFrame = self.autoHideTimerFrame
-    delay = tonumber(delay) or 0
-
-    if releaseHandler then
-        if type(releaseHandler) ~= "function" then
-            error("releaseHandler must be a function", 2)
-        end
-
-        lib.onReleaseHandlers[self] = releaseHandler
-    end
-
-    if delay > 0 then
-        if not timerFrame then
-            timerFrame = AcquireTimer(self)
-            timerFrame:SetScript("OnUpdate", AutoHideTimerFrame_OnUpdate)
-
-            self.autoHideTimerFrame = timerFrame
-        end
-
-        timerFrame.parent = self
-        timerFrame.checkElapsed = 0
-        timerFrame.elapsed = 0
-        timerFrame.delay = delay
-        timerFrame.alternateFrame = alternateFrame
-        timerFrame:Show()
-    elseif timerFrame then
-        self.autoHideTimerFrame = nil
-
-        timerFrame.alternateFrame = nil
-        timerFrame:SetScript("OnUpdate", nil)
-
-        ReleaseTimer(timerFrame)
-    end
-end
-
-------------------------------------------------------------------------------
--- "Smart" Anchoring
-------------------------------------------------------------------------------
-local function GetTipAnchor(frame)
-    local x, y = frame:GetCenter()
-	--if not x or not y then return "TOPLEFT", "BOTTOMLEFT" end
-	if not x or not y then return "BOTTOMLEFT" end
-	local hhalf = (x > UIParent:GetWidth() * 2 / 3) and "RIGHT" or (x < UIParent:GetWidth() / 3) and "LEFT" or "LEFT"
-	--local vhalf = (y > UIParent:GetHeight() / 2) and "TOP" or "BOTTOM"
-	--return vhalf .. hhalf, frame, (vhalf == "TOP" and "BOTTOM" or "TOP") .. hhalf
-	return "BOTTOM"..hhalf, frame, "BOTTOM".. (hhalf == "RIGHT" and "LEFT" or "RIGHT")
-end
-
-function tipPrototype:SmartAnchorTo(frame)
-    if not frame then
-        error("Invalid frame provided.", 2)
-    end
-
-    self:ClearAllPoints()
-    self:SetClampedToScreen(true)
-    self:SetPoint(GetTipAnchor(frame))
-end
-
-------------------------------------------------------------------------------
--- Debug slashcmds
-------------------------------------------------------------------------------
--- @debug @
-local print = print
-local function PrintStats()
-    local tipCache = tostring(#tooltipHeap)
-    local frameCache = tostring(#frameHeap)
-    local tableCache = tostring(#tableHeap)
-    local header = false
-
-    print("Tooltips used: " .. usedTooltips .. ", Cached: " .. tipCache .. ", Total: " .. tipCache + usedTooltips)
-    print("Frames used: " .. usedFrames .. ", Cached: " .. frameCache .. ", Total: " .. frameCache + usedFrames)
-    print("Tables used: " .. usedTables .. ", Cached: " .. tableCache .. ", Total: " .. tableCache + usedTables)
-
-    for k in pairs(activeTooltips) do
-        if not header then
-            print("Active tooltips:")
-            header = true
-        end
-        print("- " .. k)
-    end
-end
-
-SLASH_LibQTip1 = "/qtip"
-_G.SlashCmdList["LibQTip"] = PrintStats
---@end-debug@
+local MAJOR = "LibQTip-1.0RS"
+local MINOR = 49 -- Should be manually increased
+local LibStub = _G.LibStub
+
+assert(LibStub, MAJOR .. " requires LibStub")
+
+local lib, oldMinor = LibStub:NewLibrary(MAJOR, MINOR)
+
+if not lib then
+    return
+end -- No upgrade needed
+
+------------------------------------------------------------------------------
+-- Upvalued globals
+------------------------------------------------------------------------------
+local table = _G.table
+local tinsert = table.insert
+local tremove = table.remove
+local wipe = table.wipe
+
+local error = error
+local math = math
+local min, max = math.min, math.max
+local next = next
+local pairs, ipairs = pairs, ipairs
+local select = select
+local setmetatable = setmetatable
+local tonumber, tostring = tonumber, tostring
+local type = type
+
+local CreateFrame = _G.CreateFrame
+local GameTooltip = _G.GameTooltip
+local UIParent = _G.UIParent
+
+local geterrorhandler = _G.geterrorhandler
+
+------------------------------------------------------------------------------
+-- Tables and locals
+------------------------------------------------------------------------------
+lib.frameMetatable = lib.frameMetatable or {__index = CreateFrame("Frame")}
+
+lib.tipPrototype = lib.tipPrototype or setmetatable({}, lib.frameMetatable)
+lib.tipMetatable = lib.tipMetatable or {__index = lib.tipPrototype}
+
+lib.providerPrototype = lib.providerPrototype or {}
+lib.providerMetatable = lib.providerMetatable or {__index = lib.providerPrototype}
+
+lib.cellPrototype = lib.cellPrototype or setmetatable({}, lib.frameMetatable)
+lib.cellMetatable = lib.cellMetatable or {__index = lib.cellPrototype}
+
+lib.activeTooltips = lib.activeTooltips or {}
+
+lib.tooltipHeap = lib.tooltipHeap or {}
+lib.frameHeap = lib.frameHeap or {}
+lib.timerHeap = lib.timerHeap or {}
+lib.tableHeap = lib.tableHeap or {}
+
+lib.onReleaseHandlers = lib.onReleaseHandlers or {}
+
+local tipPrototype = lib.tipPrototype
+local tipMetatable = lib.tipMetatable
+
+local providerPrototype = lib.providerPrototype
+local providerMetatable = lib.providerMetatable
+
+local cellPrototype = lib.cellPrototype
+local cellMetatable = lib.cellMetatable
+
+local activeTooltips = lib.activeTooltips
+
+local highlightFrame = CreateFrame("Frame", nil, UIParent)
+highlightFrame:SetFrameStrata("TOOLTIP")
+highlightFrame:Hide()
+
+local DEFAULT_HIGHLIGHT_TEXTURE_PATH = [[Interface\QuestFrame\UI-QuestTitleHighlight]]
+
+local highlightTexture = highlightFrame:CreateTexture(nil, "OVERLAY")
+highlightTexture:SetTexture(DEFAULT_HIGHLIGHT_TEXTURE_PATH)
+highlightTexture:SetBlendMode("ADD")
+highlightTexture:SetAllPoints(highlightFrame)
+
+------------------------------------------------------------------------------
+-- Private methods for Caches and Tooltip
+------------------------------------------------------------------------------
+local AcquireTooltip, ReleaseTooltip
+local AcquireCell, ReleaseCell
+local AcquireTable, ReleaseTable
+
+local InitializeTooltip, SetTooltipSize, ResetTooltipSize, FixCellSizes
+local ClearTooltipScripts
+local SetFrameScript, ClearFrameScripts
+
+------------------------------------------------------------------------------
+-- Cache debugging.
+------------------------------------------------------------------------------
+-- @debug @
+local usedTables, usedFrames, usedTooltips = 0, 0, 0
+--@end-debug@
+
+------------------------------------------------------------------------------
+-- Internal constants to tweak the layout
+------------------------------------------------------------------------------
+local TOOLTIP_PADDING = 10
+local CELL_MARGIN_H = 6
+local CELL_MARGIN_V = 3
+
+------------------------------------------------------------------------------
+-- Public library API
+------------------------------------------------------------------------------
+--- Create or retrieve the tooltip with the given key.
+-- If additional arguments are passed, they are passed to :SetColumnLayout for the acquired tooltip.
+-- @name LibQTip:Acquire(key[, numColumns, column1Justification, column2justification, ...])
+-- @param key string or table - the tooltip key. Any value that can be used as a table key is accepted though you should try to provide unique keys to avoid conflicts.
+-- Numbers and booleans should be avoided and strings should be carefully chosen to avoid namespace clashes - no "MyTooltip" - you have been warned!
+-- @return tooltip Frame object - the acquired tooltip.
+-- @usage Acquire a tooltip with at least 5 columns, justification : left, center, left, left, left
+-- <pre>local tip = LibStub('LibQTip-1.0'):Acquire('MyFooBarTooltip', 5, "LEFT", "CENTER")</pre>
+function lib:Acquire(key, ...)
+    if key == nil then
+        error("attempt to use a nil key", 2)
+    end
+
+    local tooltip = activeTooltips[key]
+
+    if not tooltip then
+        tooltip = AcquireTooltip()
+        InitializeTooltip(tooltip, key)
+        activeTooltips[key] = tooltip
+    end
+
+    if select("#", ...) > 0 then
+        -- Here we catch any error to properly report it for the calling code
+        local ok, msg = pcall(tooltip.SetColumnLayout, tooltip, ...)
+
+        if not ok then
+            error(msg, 2)
+        end
+    end
+
+    return tooltip
+end
+
+function lib:Release(tooltip)
+    local key = tooltip and tooltip.key
+
+    if not key or activeTooltips[key] ~= tooltip then
+        return
+    end
+
+    ReleaseTooltip(tooltip)
+    activeTooltips[key] = nil
+end
+
+function lib:IsAcquired(key)
+    if key == nil then
+        error("attempt to use a nil key", 2)
+    end
+
+    return not (not activeTooltips[key])
+end
+
+function lib:IterateTooltips()
+    return pairs(activeTooltips)
+end
+
+------------------------------------------------------------------------------
+-- Frame cache (for lines and columns)
+------------------------------------------------------------------------------
+local frameHeap = lib.frameHeap
+
+local function AcquireFrame(parent)
+    local frame = tremove(frameHeap) or CreateFrame("Frame", nil, nil, BackdropTemplateMixin and "BackdropTemplate")
+    frame:SetParent(parent)
+    --[===[@debug@
+    usedFrames = usedFrames + 1
+    --@end-debug@]===]
+    return frame
+end
+
+local function ReleaseFrame(frame)
+    frame:Hide()
+    frame:SetParent(nil)
+    frame:ClearAllPoints()
+    frame:SetBackdrop(nil)
+
+    ClearFrameScripts(frame)
+
+    tinsert(frameHeap, frame)
+    --[===[@debug@
+    usedFrames = usedFrames - 1
+    --@end-debug@]===]
+end
+
+------------------------------------------------------------------------------
+-- Timer cache
+------------------------------------------------------------------------------
+local timerHeap = lib.timerHeap
+
+local function AcquireTimer(parent)
+    local frame = tremove(timerHeap) or CreateFrame("Frame")
+    frame:SetParent(parent)
+    return frame
+end
+
+local function ReleaseTimer(frame)
+    frame:Hide()
+    frame:SetParent(nil)
+
+    ClearFrameScripts(frame)
+
+    tinsert(timerHeap, frame)
+end
+
+------------------------------------------------------------------------------
+-- Dirty layout handler
+------------------------------------------------------------------------------
+lib.layoutCleaner = lib.layoutCleaner or CreateFrame("Frame")
+
+local layoutCleaner = lib.layoutCleaner
+layoutCleaner.registry = layoutCleaner.registry or {}
+
+function layoutCleaner:RegisterForCleanup(tooltip)
+    self.registry[tooltip] = true
+    self:Show()
+end
+
+function layoutCleaner:CleanupLayouts()
+    self:Hide()
+
+    for tooltip in pairs(self.registry) do
+        FixCellSizes(tooltip)
+    end
+
+    wipe(self.registry)
+end
+
+layoutCleaner:SetScript("OnUpdate", layoutCleaner.CleanupLayouts)
+
+------------------------------------------------------------------------------
+-- CellProvider and Cell
+------------------------------------------------------------------------------
+function providerPrototype:AcquireCell()
+    local cell = tremove(self.heap)
+
+    if not cell then
+        cell = CreateFrame("Frame", nil, UIParent, BackdropTemplateMixin and "BackdropTemplate")
+        setmetatable(cell, self.cellMetatable)
+
+        if type(cell.InitializeCell) == "function" then
+            cell:InitializeCell()
+        end
+    end
+
+    self.cells[cell] = true
+
+    return cell
+end
+
+function providerPrototype:ReleaseCell(cell)
+    if not self.cells[cell] then
+        return
+    end
+
+    if type(cell.ReleaseCell) == "function" then
+        cell:ReleaseCell()
+    end
+
+    self.cells[cell] = nil
+    tinsert(self.heap, cell)
+end
+
+function providerPrototype:GetCellPrototype()
+    return self.cellPrototype, self.cellMetatable
+end
+
+function providerPrototype:IterateCells()
+    return pairs(self.cells)
+end
+
+function lib:CreateCellProvider(baseProvider)
+    local cellBaseMetatable, cellBasePrototype
+
+    if baseProvider and baseProvider.GetCellPrototype then
+        cellBasePrototype, cellBaseMetatable = baseProvider:GetCellPrototype()
+    else
+        cellBaseMetatable = cellMetatable
+    end
+
+    local newCellPrototype = setmetatable({}, cellBaseMetatable)
+    local newCellProvider = setmetatable({}, providerMetatable)
+
+    newCellProvider.heap = {}
+    newCellProvider.cells = {}
+    newCellProvider.cellPrototype = newCellPrototype
+    newCellProvider.cellMetatable = {__index = newCellPrototype}
+
+    return newCellProvider, newCellPrototype, cellBasePrototype
+end
+
+------------------------------------------------------------------------------
+-- Basic label provider
+------------------------------------------------------------------------------
+if not lib.LabelProvider then
+    lib.LabelProvider, lib.LabelPrototype = lib:CreateCellProvider()
+end
+
+local labelProvider = lib.LabelProvider
+local labelPrototype = lib.LabelPrototype
+
+function labelPrototype:InitializeCell()
+    self.fontString = self:CreateFontString()
+    self.fontString:SetFontObject(_G.GameTooltipText)
+end
+
+function labelPrototype:SetupCell(tooltip, value, justification, font, leftPadding, rightPadding, maxWidth, minWidth, ...)
+    local fontString = self.fontString
+    local line = tooltip.lines[self._line]
+
+    -- detatch fs from cell for size calculations
+    fontString:ClearAllPoints()
+    fontString:SetFontObject(font or (line.is_header and tooltip:GetHeaderFont() or tooltip:GetFont()))
+    fontString:SetJustifyH(justification)
+    fontString:SetText(tostring(value))
+
+    leftPadding = leftPadding or 0
+    rightPadding = rightPadding or 0
+
+    local width = fontString:GetStringWidth() + leftPadding + rightPadding
+
+    if maxWidth and minWidth and (maxWidth < minWidth) then
+        error("maximum width cannot be lower than minimum width: " .. tostring(maxWidth) .. " < " .. tostring(minWidth), 2)
+    end
+
+    if maxWidth and (maxWidth < (leftPadding + rightPadding)) then
+        error("maximum width cannot be lower than the sum of paddings: " .. tostring(maxWidth) .. " < " .. tostring(leftPadding) .. " + " .. tostring(rightPadding), 2)
+    end
+
+    if minWidth and width < minWidth then
+        width = minWidth
+    end
+
+    if maxWidth and maxWidth < width then
+        width = maxWidth
+    end
+
+    fontString:SetWidth(width - (leftPadding + rightPadding))
+    -- Use GetHeight() instead of GetStringHeight() so lines which are longer than width will wrap.
+    local height = fontString:GetHeight()
+
+    -- reanchor fs to cell
+    fontString:SetWidth(0)
+    fontString:SetPoint("TOPLEFT", self, "TOPLEFT", leftPadding, 0)
+    fontString:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -rightPadding, 0)
+    --~ 	fs:SetPoint("TOPRIGHT", self, "TOPRIGHT", -r_pad, 0)
+
+    self._paddingL = leftPadding
+    self._paddingR = rightPadding
+
+    return width, height
+end
+
+function labelPrototype:getContentHeight()
+    local fontString = self.fontString
+    fontString:SetWidth(self:GetWidth() - (self._paddingL + self._paddingR))
+
+    local height = self.fontString:GetHeight()
+    fontString:SetWidth(0)
+
+    return height
+end
+
+function labelPrototype:GetPosition()
+    return self._line, self._column
+end
+
+------------------------------------------------------------------------------
+-- Tooltip cache
+------------------------------------------------------------------------------
+local tooltipHeap = lib.tooltipHeap
+
+-- Returns a tooltip
+function AcquireTooltip()
+    local tooltip = tremove(tooltipHeap)
+
+    if not tooltip then
+        local template = (TooltipBackdropTemplateMixin and "TooltipBackdropTemplate") or (BackdropTemplateMixin and "BackdropTemplate")
+        tooltip = CreateFrame("Frame", nil, UIParent, template)
+
+        local scrollFrame = CreateFrame("ScrollFrame", nil, tooltip)
+        scrollFrame:SetPoint("TOP", tooltip, "TOP", 0, -TOOLTIP_PADDING)
+        scrollFrame:SetPoint("BOTTOM", tooltip, "BOTTOM", 0, TOOLTIP_PADDING)
+        scrollFrame:SetPoint("LEFT", tooltip, "LEFT", TOOLTIP_PADDING, 0)
+        scrollFrame:SetPoint("RIGHT", tooltip, "RIGHT", -TOOLTIP_PADDING, 0)
+        tooltip.scrollFrame = scrollFrame
+
+        local scrollChild = CreateFrame("Frame", nil, tooltip.scrollFrame)
+        scrollFrame:SetScrollChild(scrollChild)
+        tooltip.scrollChild = scrollChild
+
+        setmetatable(tooltip, tipMetatable)
+    end
+
+    --[===[@debug@
+    usedTooltips = usedTooltips + 1
+    --@end-debug@]===]
+    return tooltip
+end
+
+-- Cleans the tooltip and stores it in the cache
+function ReleaseTooltip(tooltip)
+    if tooltip.releasing then
+        return
+    end
+
+    tooltip.releasing = true
+    tooltip:Hide()
+
+    local releaseHandler = lib.onReleaseHandlers[tooltip]
+
+    if releaseHandler then
+        lib.onReleaseHandlers[tooltip] = nil
+
+        local success, errorMessage = pcall(releaseHandler, tooltip)
+
+        if not success then
+            geterrorhandler()(errorMessage)
+        end
+    elseif tooltip.OnRelease then
+        local success, errorMessage = pcall(tooltip.OnRelease, tooltip)
+        if not success then
+            geterrorhandler()(errorMessage)
+        end
+
+        tooltip.OnRelease = nil
+    end
+
+    tooltip.releasing = nil
+    tooltip.key = nil
+    tooltip.step = nil
+
+    ClearTooltipScripts(tooltip)
+
+    tooltip:SetAutoHideDelay(nil)
+    tooltip:ClearAllPoints()
+    tooltip:Clear()
+
+    if tooltip.slider then
+        tooltip.slider:SetValue(0)
+        tooltip.slider:Hide()
+        tooltip.scrollFrame:SetPoint("RIGHT", tooltip, "RIGHT", -TOOLTIP_PADDING, 0)
+        tooltip:EnableMouseWheel(false)
+    end
+
+    for i, column in ipairs(tooltip.columns) do
+        tooltip.columns[i] = ReleaseFrame(column)
+    end
+
+    tooltip.columns = ReleaseTable(tooltip.columns)
+    tooltip.lines = ReleaseTable(tooltip.lines)
+    tooltip.colspans = ReleaseTable(tooltip.colspans)
+
+    layoutCleaner.registry[tooltip] = nil
+
+    if TooltipBackdropTemplateMixin and not tooltip.NineSlice then
+        -- don't recycle outdated tooltips into heap
+        tooltip = nil
+    end
+
+    if tooltip then
+        tinsert(tooltipHeap, tooltip)
+    end
+
+    highlightTexture:SetTexture(DEFAULT_HIGHLIGHT_TEXTURE_PATH)
+    highlightTexture:SetTexCoord(0, 1, 0, 1)
+
+    --[===[@debug@
+    usedTooltips = usedTooltips - 1
+    --@end-debug@]===]
+end
+
+------------------------------------------------------------------------------
+-- Cell 'cache' (just a wrapper to the provider's cache)
+------------------------------------------------------------------------------
+-- Returns a cell for the given tooltip from the given provider
+function AcquireCell(tooltip, provider)
+    local cell = provider:AcquireCell(tooltip)
+
+    cell:SetParent(tooltip.scrollChild)
+    cell:SetFrameLevel(tooltip.scrollChild:GetFrameLevel() + 3)
+    cell._provider = provider
+
+    return cell
+end
+
+-- Cleans the cell hands it to its provider for storing
+function ReleaseCell(cell)
+    if cell.fontString and cell.r then
+        cell.fontString:SetTextColor(cell.r, cell.g, cell.b, cell.a)
+    end
+
+    cell._font = nil
+    cell._justification = nil
+    cell._colSpan = nil
+    cell._line = nil
+    cell._column = nil
+
+    cell:Hide()
+    cell:ClearAllPoints()
+    cell:SetParent(nil)
+    cell:SetBackdrop(nil)
+
+    ClearFrameScripts(cell)
+
+    cell._provider:ReleaseCell(cell)
+    cell._provider = nil
+end
+
+------------------------------------------------------------------------------
+-- Table cache
+------------------------------------------------------------------------------
+local tableHeap = lib.tableHeap
+
+-- Returns a table
+function AcquireTable()
+    local tbl = tremove(tableHeap) or {}
+    --[===[@debug@
+    usedTables = usedTables + 1
+    --@end-debug@]===]
+    return tbl
+end
+
+-- Cleans the table and stores it in the cache
+function ReleaseTable(tableInstance)
+    wipe(tableInstance)
+    tinsert(tableHeap, tableInstance)
+    --[===[@debug@
+    usedTables = usedTables - 1
+    --@end-debug@]===]
+end
+
+------------------------------------------------------------------------------
+-- Tooltip prototype
+------------------------------------------------------------------------------
+function InitializeTooltip(tooltip, key)
+    ----------------------------------------------------------------------
+    -- (Re)set frame settings
+    ----------------------------------------------------------------------
+    if TooltipBackdropTemplateMixin then
+        tooltip.layoutType = GameTooltip.layoutType
+        NineSlicePanelMixin.OnLoad(tooltip.NineSlice)
+        if GameTooltip.layoutType then
+            tooltip.NineSlice:SetCenterColor(GameTooltip.NineSlice:GetCenterColor())
+            tooltip.NineSlice:SetBorderColor(GameTooltip.NineSlice:GetBorderColor())
+        end
+    else
+        local backdrop = GameTooltip:GetBackdrop()
+
+        tooltip:SetBackdrop(backdrop)
+
+        if backdrop then
+            tooltip:SetBackdropColor(GameTooltip:GetBackdropColor())
+            tooltip:SetBackdropBorderColor(GameTooltip:GetBackdropBorderColor())
+        end
+    end
+
+    tooltip:SetScale(GameTooltip:GetScale())
+    tooltip:SetAlpha(1)
+    tooltip:SetFrameStrata("TOOLTIP")
+    tooltip:SetClampedToScreen(false)
+
+    ----------------------------------------------------------------------
+    -- Internal data. Since it's possible to Acquire twice without calling
+    -- release, check for pre-existence.
+    ----------------------------------------------------------------------
+    tooltip.key = key
+    tooltip.columns = tooltip.columns or AcquireTable()
+    tooltip.lines = tooltip.lines or AcquireTable()
+    tooltip.colspans = tooltip.colspans or AcquireTable()
+    tooltip.regularFont = _G.GameTooltipText
+    tooltip.headerFont = _G.GameTooltipHeaderText
+    tooltip.labelProvider = labelProvider
+    tooltip.cell_margin_h = tooltip.cell_margin_h or CELL_MARGIN_H
+    tooltip.cell_margin_v = tooltip.cell_margin_v or CELL_MARGIN_V
+
+    ----------------------------------------------------------------------
+    -- Finishing procedures
+    ----------------------------------------------------------------------
+    tooltip:SetAutoHideDelay(nil)
+    tooltip:Hide()
+    ResetTooltipSize(tooltip)
+end
+
+function tipPrototype:SetDefaultProvider(myProvider)
+    if not myProvider then
+        return
+    end
+
+    self.labelProvider = myProvider
+end
+
+function tipPrototype:GetDefaultProvider()
+    return self.labelProvider
+end
+
+local function checkJustification(justification, level, silent)
+    if justification ~= "LEFT" and justification ~= "CENTER" and justification ~= "RIGHT" then
+        if silent then
+            return false
+        end
+        error("invalid justification, must one of LEFT, CENTER or RIGHT, not: " .. tostring(justification), level + 1)
+    end
+
+    return true
+end
+
+function tipPrototype:SetColumnLayout(numColumns, ...)
+    if type(numColumns) ~= "number" or numColumns < 1 then
+        error("number of columns must be a positive number, not: " .. tostring(numColumns), 2)
+    end
+
+    for i = 1, numColumns do
+        local justification = select(i, ...) or "LEFT"
+
+        checkJustification(justification, 2)
+
+        if self.columns[i] then
+            self.columns[i].justification = justification
+        else
+            self:AddColumn(justification)
+        end
+    end
+end
+
+function tipPrototype:AddColumn(justification)
+    justification = justification or "LEFT"
+    checkJustification(justification, 2)
+
+    local colNum = #self.columns + 1
+    local column = self.columns[colNum] or AcquireFrame(self.scrollChild)
+
+    column:SetFrameLevel(self.scrollChild:GetFrameLevel() + 1)
+    column.justification = justification
+    column.width = 0
+    column:SetWidth(1)
+    column:SetPoint("TOP", self.scrollChild)
+    column:SetPoint("BOTTOM", self.scrollChild)
+
+    if colNum > 1 then
+        local h_margin = self.cell_margin_h or CELL_MARGIN_H
+
+        column:SetPoint("LEFT", self.columns[colNum - 1], "RIGHT", h_margin, 0)
+        SetTooltipSize(self, self.width + h_margin, self.height)
+    else
+        column:SetPoint("LEFT", self.scrollChild)
+    end
+
+    column:Show()
+    self.columns[colNum] = column
+
+    return colNum
+end
+
+------------------------------------------------------------------------------
+-- Convenient methods
+------------------------------------------------------------------------------
+function tipPrototype:Release()
+    lib:Release(self)
+end
+
+function tipPrototype:IsAcquiredBy(key)
+    return key ~= nil and self.key == key
+end
+
+------------------------------------------------------------------------------
+-- Script hooks
+------------------------------------------------------------------------------
+local RawSetScript = lib.frameMetatable.__index.SetScript
+
+function ClearTooltipScripts(tooltip)
+    if tooltip.scripts then
+        for scriptType in pairs(tooltip.scripts) do
+            RawSetScript(tooltip, scriptType, nil)
+        end
+
+        tooltip.scripts = ReleaseTable(tooltip.scripts)
+    end
+end
+
+function tipPrototype:SetScript(scriptType, handler)
+    RawSetScript(self, scriptType, handler)
+
+    if handler then
+        if not self.scripts then
+            self.scripts = AcquireTable()
+        end
+
+        self.scripts[scriptType] = true
+    elseif self.scripts then
+        self.scripts[scriptType] = nil
+    end
+end
+
+-- That might break some addons ; those addons were breaking other
+-- addons' tooltip though.
+function tipPrototype:HookScript()
+    geterrorhandler()(":HookScript is not allowed on LibQTip tooltips")
+end
+
+------------------------------------------------------------------------------
+-- Scrollbar data and functions
+------------------------------------------------------------------------------
+local BACKDROP_SLIDER_8_8 = BACKDROP_SLIDER_8_8 or {
+    bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
+    edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
+    tile = true,
+    tileEdge = true,
+    tileSize = 8,
+    edgeSize = 8,
+    insets = { left = 3, right = 3, top = 6, bottom = 6 },
+};
+
+local function slider_OnValueChanged(self)
+    self.scrollFrame:SetVerticalScroll(self:GetValue())
+end
+
+local function tooltip_OnMouseWheel(self, delta)
+    local slider = self.slider
+    local currentValue = slider:GetValue()
+    local minValue, maxValue = slider:GetMinMaxValues()
+    local stepValue = self.step or 10
+
+    if delta < 0 and currentValue < maxValue then
+        slider:SetValue(min(maxValue, currentValue + stepValue))
+    elseif delta > 0 and currentValue > minValue then
+        slider:SetValue(max(minValue, currentValue - stepValue))
+    end
+end
+
+-- Set the step size for the scroll bar
+function tipPrototype:SetScrollStep(step)
+    self.step = step
+end
+
+-- will resize the tooltip to fit the screen and show a scrollbar if needed
+function tipPrototype:UpdateScrolling(maxheight)
+    self:SetClampedToScreen(false)
+
+    -- all data is in the tooltip; fix colspan width and prevent the layout cleaner from messing up the tooltip later
+    FixCellSizes(self)
+    layoutCleaner.registry[self] = nil
+
+    local scale = self:GetScale()
+    local topside = self:GetTop()
+    local bottomside = self:GetBottom()
+    local screensize = UIParent:GetHeight() / scale
+    local tipsize = (topside - bottomside)
+
+    -- if the tooltip would be too high, limit its height and show the slider
+    if bottomside < 0 or topside > screensize or (maxheight and tipsize > maxheight) then
+        local shrink = (bottomside < 0 and (5 - bottomside) or 0) + (topside > screensize and (topside - screensize + 5) or 0)
+
+        if maxheight and tipsize - shrink > maxheight then
+            shrink = tipsize - maxheight
+        end
+
+        self:SetHeight(2 * TOOLTIP_PADDING + self.height - shrink)
+        self:SetWidth(2 * TOOLTIP_PADDING + self.width + 20)
+        self.scrollFrame:SetPoint("RIGHT", self, "RIGHT", -(TOOLTIP_PADDING + 20), 0)
+
+        if not self.slider then
+            local slider = CreateFrame("Slider", nil, self, BackdropTemplateMixin and "BackdropTemplate")
+            slider.scrollFrame = self.scrollFrame
+
+            slider:SetOrientation("VERTICAL")
+            slider:SetPoint("TOPRIGHT", self, "TOPRIGHT", -TOOLTIP_PADDING, -TOOLTIP_PADDING)
+            slider:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -TOOLTIP_PADDING, TOOLTIP_PADDING)
+            slider:SetBackdrop(BACKDROP_SLIDER_8_8)
+            slider:SetThumbTexture([[Interface\Buttons\UI-SliderBar-Button-Vertical]])
+            slider:SetMinMaxValues(0, 1)
+            slider:SetValueStep(1)
+            slider:SetWidth(12)
+            slider:SetScript("OnValueChanged", slider_OnValueChanged)
+            slider:SetValue(0)
+
+            self.slider = slider
+        end
+
+        self.slider:SetMinMaxValues(0, shrink)
+        self.slider:Show()
+
+        self:EnableMouseWheel(true)
+        self:SetScript("OnMouseWheel", tooltip_OnMouseWheel)
+    else
+        self:SetHeight(2 * TOOLTIP_PADDING + self.height)
+        self:SetWidth(2 * TOOLTIP_PADDING + self.width)
+
+        self.scrollFrame:SetPoint("RIGHT", self, "RIGHT", -TOOLTIP_PADDING, 0)
+
+        if self.slider then
+            self.slider:SetValue(0)
+            self.slider:Hide()
+
+            self:EnableMouseWheel(false)
+            self:SetScript("OnMouseWheel", nil)
+        end
+    end
+end
+
+------------------------------------------------------------------------------
+-- Tooltip methods for changing its contents.
+------------------------------------------------------------------------------
+function tipPrototype:Clear()
+    for i, line in ipairs(self.lines) do
+        for _, cell in pairs(line.cells) do
+            if cell then
+                ReleaseCell(cell)
+            end
+        end
+
+        ReleaseTable(line.cells)
+
+        line.cells = nil
+        line.is_header = nil
+
+        ReleaseFrame(line)
+
+        self.lines[i] = nil
+    end
+
+    for _, column in ipairs(self.columns) do
+        column.width = 0
+        column:SetWidth(1)
+    end
+
+    wipe(self.colspans)
+
+    self.cell_margin_h = nil
+    self.cell_margin_v = nil
+
+    ResetTooltipSize(self)
+end
+
+function tipPrototype:SetCellMarginH(size)
+    if #self.lines > 0 then
+       -- error("Unable to set horizontal margin while the tooltip has lines.", 2)
+       return
+    end
+
+    if not size or type(size) ~= "number" or size < 0 then
+        --error("Margin size must be a positive number or zero.", 2)
+        return
+    end
+
+    self.cell_margin_h = size
+end
+
+function tipPrototype:SetCellMarginV(size)
+    if #self.lines > 0 then
+        error("Unable to set vertical margin while the tooltip has lines.", 2)
+    end
+
+    if not size or type(size) ~= "number" or size < 0 then
+        error("Margin size must be a positive number or zero.", 2)
+    end
+
+    self.cell_margin_v = size
+end
+
+function SetTooltipSize(tooltip, width, height)
+    tooltip.height = height
+    tooltip.width = width
+
+    tooltip:SetHeight(2 * TOOLTIP_PADDING + height)
+    tooltip:SetWidth(2 * TOOLTIP_PADDING + width)
+
+    tooltip.scrollChild:SetHeight(height)
+    tooltip.scrollChild:SetWidth(width)
+end
+
+-- Add 2 pixels to height so dangling letters (g, y, p, j, etc) are not clipped.
+function ResetTooltipSize(tooltip)
+    local h_margin = tooltip.cell_margin_h or CELL_MARGIN_H
+
+    SetTooltipSize(tooltip, max(0, (h_margin * (#tooltip.columns - 1)) + (h_margin / 2)), 2)
+end
+
+local function EnlargeColumn(tooltip, column, width)
+    if width > column.width then
+        SetTooltipSize(tooltip, tooltip.width + width - column.width, tooltip.height)
+
+        column.width = width
+        column:SetWidth(width)
+    end
+end
+
+local function ResizeLine(tooltip, line, height)
+    SetTooltipSize(tooltip, tooltip.width, tooltip.height + height - line.height)
+
+    line.height = height
+    line:SetHeight(height)
+end
+
+function FixCellSizes(tooltip)
+    local columns = tooltip.columns
+    local colspans = tooltip.colspans
+    local lines = tooltip.lines
+    local h_margin = tooltip.cell_margin_h or CELL_MARGIN_H
+
+    -- resize columns to make room for the colspans
+    while next(colspans) do
+        local maxNeedCols
+        local maxNeedWidthPerCol = 0
+
+        -- calculate the colspan with the highest additional width need per column
+        for colRange, width in pairs(colspans) do
+            local left, right = colRange:match("^(%d+)%-(%d+)$")
+
+            left, right = tonumber(left), tonumber(right)
+
+            for col = left, right - 1 do
+                width = width - columns[col].width - h_margin
+            end
+
+            width = width - columns[right].width
+
+            if width <= 0 then
+                colspans[colRange] = nil
+            else
+                width = width / (right - left + 1)
+
+                if width > maxNeedWidthPerCol then
+                    maxNeedCols = colRange
+                    maxNeedWidthPerCol = width
+                end
+            end
+        end
+
+        -- resize all columns for that colspan
+        if maxNeedCols then
+            local left, right = maxNeedCols:match("^(%d+)%-(%d+)$")
+
+            for col = left, right do
+                EnlargeColumn(tooltip, columns[col], columns[col].width + maxNeedWidthPerCol)
+            end
+
+            colspans[maxNeedCols] = nil
+        end
+    end
+
+    --now that the cell width is set, recalculate the rows' height
+    for _, line in ipairs(lines) do
+        if #(line.cells) > 0 then
+            local lineheight = 0
+
+            for _, cell in pairs(line.cells) do
+                if cell then
+                    lineheight = max(lineheight, cell:getContentHeight())
+                end
+            end
+
+            if lineheight > 0 then
+                ResizeLine(tooltip, line, lineheight)
+            end
+        end
+    end
+end
+
+local function _SetCell(tooltip, lineNum, colNum, value, font, justification, colSpan, provider, ...)
+    local line = tooltip.lines[lineNum]
+    local cells = line.cells
+
+    -- Unset: be quick
+    if value == nil then
+        local cell = cells[colNum]
+
+        if cell then
+            for i = colNum, colNum + cell._colSpan - 1 do
+                cells[i] = nil
+            end
+
+            ReleaseCell(cell)
+        end
+
+        return lineNum, colNum
+    end
+
+    font = font or (line.is_header and tooltip.headerFont or tooltip.regularFont)
+
+    -- Check previous cell
+    local cell
+    local prevCell = cells[colNum]
+
+    if prevCell then
+        -- There is a cell here
+        justification = justification or prevCell._justification
+        colSpan = colSpan or prevCell._colSpan
+
+        -- Clear the currently marked colspan
+        for i = colNum + 1, colNum + prevCell._colSpan - 1 do
+            cells[i] = nil
+        end
+
+        if provider == nil or prevCell._provider == provider then
+            -- Reuse existing cell
+            cell = prevCell
+            provider = cell._provider
+        else
+            -- A new cell is required
+            cells[colNum] = ReleaseCell(prevCell)
+        end
+    elseif prevCell == nil then
+        -- Creating a new cell, using meaningful defaults.
+        provider = provider or tooltip.labelProvider
+        justification = justification or tooltip.columns[colNum].justification or "LEFT"
+        colSpan = colSpan or 1
+    else
+        error("overlapping cells at column " .. colNum, 3)
+    end
+
+    local tooltipWidth = #tooltip.columns
+    local rightColNum
+
+    if colSpan > 0 then
+        rightColNum = colNum + colSpan - 1
+
+        if rightColNum > tooltipWidth then
+            error("ColSpan too big, cell extends beyond right-most column", 3)
+        end
+    else
+        -- Zero or negative: count back from right-most columns
+        rightColNum = max(colNum, tooltipWidth + colSpan)
+        -- Update colspan to its effective value
+        colSpan = 1 + rightColNum - colNum
+    end
+
+    -- Cleanup colspans
+    for i = colNum + 1, rightColNum do
+        local columnCell = cells[i]
+
+        if columnCell then
+            ReleaseCell(columnCell)
+        elseif columnCell == false then
+            error("overlapping cells at column " .. i, 3)
+        end
+
+        cells[i] = false
+    end
+
+    -- Create the cell
+    if not cell then
+        cell = AcquireCell(tooltip, provider)
+        cells[colNum] = cell
+    end
+
+    -- Anchor the cell
+    cell:SetPoint("LEFT", tooltip.columns[colNum])
+    cell:SetPoint("RIGHT", tooltip.columns[rightColNum])
+    cell:SetPoint("TOP", line)
+    cell:SetPoint("BOTTOM", line)
+
+    -- Store the cell settings directly into the cell
+    -- That's a bit risky but is really cheap compared to other ways to do it
+    cell._font, cell._justification, cell._colSpan, cell._line, cell._column = font, justification, colSpan, lineNum, colNum
+
+    -- Setup the cell content
+    local width, height = cell:SetupCell(tooltip, value, justification, font, ...)
+    cell:Show()
+
+    if colSpan > 1 then
+        -- Postpone width changes until the tooltip is shown
+        local colRange = colNum .. "-" .. rightColNum
+
+        tooltip.colspans[colRange] = max(tooltip.colspans[colRange] or 0, width)
+        layoutCleaner:RegisterForCleanup(tooltip)
+    else
+        -- Enlarge the column and tooltip if need be
+        EnlargeColumn(tooltip, tooltip.columns[colNum], width)
+    end
+
+    -- Enlarge the line and tooltip if need be
+    if height > line.height then
+        SetTooltipSize(tooltip, tooltip.width, tooltip.height + height - line.height)
+
+        line.height = height
+        line:SetHeight(height)
+    end
+
+    if rightColNum < tooltipWidth then
+        return lineNum, rightColNum + 1
+    else
+        return lineNum, nil
+    end
+end
+
+do
+    local function CreateLine(tooltip, font, ...)
+        if #tooltip.columns == 0 then
+            error("column layout should be defined before adding line", 3)
+        end
+
+        local lineNum = #tooltip.lines + 1
+        local line = tooltip.lines[lineNum] or AcquireFrame(tooltip.scrollChild)
+
+        line:SetFrameLevel(tooltip.scrollChild:GetFrameLevel() + 2)
+        line:SetPoint("LEFT", tooltip.scrollChild)
+        line:SetPoint("RIGHT", tooltip.scrollChild)
+
+        if lineNum > 1 then
+            local v_margin = tooltip.cell_margin_v or CELL_MARGIN_V
+
+            line:SetPoint("TOP", tooltip.lines[lineNum - 1], "BOTTOM", 0, -v_margin)
+            SetTooltipSize(tooltip, tooltip.width, tooltip.height + v_margin)
+        else
+            line:SetPoint("TOP", tooltip.scrollChild)
+        end
+
+        tooltip.lines[lineNum] = line
+
+        line.cells = line.cells or AcquireTable()
+        line.height = 0
+        line:SetHeight(1)
+        line:Show()
+
+        local colNum = 1
+
+        for i = 1, #tooltip.columns do
+            local value = select(i, ...)
+
+            if value ~= nil then
+                lineNum, colNum = _SetCell(tooltip, lineNum, i, value, font, nil, 1, tooltip.labelProvider)
+            end
+        end
+
+        return lineNum, colNum
+    end
+
+    function tipPrototype:AddLine(...)
+        return CreateLine(self, self.regularFont, ...)
+    end
+
+    function tipPrototype:AddHeader(...)
+        local line, col = CreateLine(self, self.headerFont, ...)
+
+        self.lines[line].is_header = true
+
+        return line, col
+    end
+end -- do-block
+
+local GenericBackdrop = {
+    bgFile = "Interface\\Tooltips\\UI-Tooltip-Background"
+}
+
+function tipPrototype:AddSeparator(height, r, g, b, a)
+    local lineNum, colNum = self:AddLine()
+    local line = self.lines[lineNum]
+    local color = _G.NORMAL_FONT_COLOR
+
+    height = height or 1
+
+    SetTooltipSize(self, self.width, self.height + height)
+
+    line.height = height
+    line:SetHeight(height)
+    line:SetBackdrop(GenericBackdrop)
+    line:SetBackdropColor(r or color.r, g or color.g, b or color.b, a or 1)
+
+    return lineNum, colNum
+end
+
+function tipPrototype:SetCellColor(lineNum, colNum, r, g, b, a)
+    local cell = self.lines[lineNum].cells[colNum]
+
+    if cell then
+        local sr, sg, sb, sa = self:GetBackdropColor()
+
+        cell:SetBackdrop(GenericBackdrop)
+        cell:SetBackdropColor(r or sr, g or sg, b or sb, a or sa)
+    end
+end
+
+function tipPrototype:SetColumnColor(colNum, r, g, b, a)
+    local column = self.columns[colNum]
+
+    if column then
+        local sr, sg, sb, sa = self:GetBackdropColor()
+        column:SetBackdrop(GenericBackdrop)
+        column:SetBackdropColor(r or sr, g or sg, b or sb, a or sa)
+    end
+end
+
+function tipPrototype:SetLineColor(lineNum, r, g, b, a)
+    local line = self.lines[lineNum]
+
+    if line then
+        local sr, sg, sb, sa = self:GetBackdropColor()
+
+        line:SetBackdrop(GenericBackdrop)
+        line:SetBackdropColor(r or sr, g or sg, b or sb, a or sa)
+    end
+end
+
+function tipPrototype:SetCellTextColor(lineNum, colNum, r, g, b, a)
+    local line = self.lines[lineNum]
+    local column = self.columns[colNum]
+
+    if not line or not column then
+        return
+    end
+
+    local cell = self.lines[lineNum].cells[colNum]
+
+    if cell then
+        if not cell.fontString then
+            error("cell's label provider did not assign a fontString field", 2)
+        end
+
+        if not cell.r then
+            cell.r, cell.g, cell.b, cell.a = cell.fontString:GetTextColor()
+        end
+
+        cell.fontString:SetTextColor(r or cell.r, g or cell.g, b or cell.b, a or cell.a)
+    end
+end
+
+function tipPrototype:SetColumnTextColor(colNum, r, g, b, a)
+    if not self.columns[colNum] then
+        return
+    end
+
+    for lineIndex = 1, #self.lines do
+        self:SetCellTextColor(lineIndex, colNum, r, g, b, a)
+    end
+end
+
+function tipPrototype:SetLineTextColor(lineNum, r, g, b, a)
+    local line = self.lines[lineNum]
+
+    if not line then
+        return
+    end
+
+    for cellIndex = 1, #line.cells do
+        self:SetCellTextColor(lineNum, line.cells[cellIndex]._column, r, g, b, a)
+    end
+end
+
+function tipPrototype:SetHighlightTexture(...)
+    return highlightTexture:SetTexture(...)
+end
+
+function tipPrototype:SetHighlightTexCoord(...)
+    highlightTexture:SetTexCoord(...)
+end
+
+do
+    local function checkFont(font, level, silent)
+        local bad = false
+
+        if not font then
+            bad = true
+        elseif type(font) == "string" then
+            local ref = _G[font]
+
+            if not ref or type(ref) ~= "table" or type(ref.IsObjectType) ~= "function" or not ref:IsObjectType("Font") then
+                bad = true
+            end
+        elseif type(font) ~= "table" or type(font.IsObjectType) ~= "function" or not font:IsObjectType("Font") then
+            bad = true
+        end
+
+        if bad then
+            if silent then
+                return false
+            end
+
+            error("font must be a Font instance or a string matching the name of a global Font instance, not: " .. tostring(font), level + 1)
+        end
+        return true
+    end
+
+    function tipPrototype:SetFont(font)
+        local is_string = type(font) == "string"
+
+        checkFont(font, 2)
+        self.regularFont = is_string and _G[font] or font
+    end
+
+    function tipPrototype:SetHeaderFont(font)
+        local is_string = type(font) == "string"
+
+        checkFont(font, 2)
+        self.headerFont = is_string and _G[font] or font
+    end
+
+    -- TODO: fixed argument positions / remove checks for performance?
+    function tipPrototype:SetCell(lineNum, colNum, value, ...)
+        -- Mandatory argument checking
+        if type(lineNum) ~= "number" then
+            error("line number must be a number, not: " .. tostring(lineNum), 2)
+        elseif lineNum < 1 or lineNum > #self.lines then
+            error("line number out of range: " .. tostring(lineNum), 2)
+        elseif type(colNum) ~= "number" then
+            error("column number must be a number, not: " .. tostring(colNum), 2)
+        elseif colNum < 1 or colNum > #self.columns then
+            error("column number out of range: " .. tostring(colNum), 2)
+        end
+
+        -- Variable argument checking
+        local font, justification, colSpan, provider
+        local i, arg = 1, ...
+
+        if arg == nil or checkFont(arg, 2, true) then
+            i, font, arg = 2, ...
+        end
+
+        if arg == nil or checkJustification(arg, 2, true) then
+            i, justification, arg = i + 1, select(i, ...)
+        end
+
+        if arg == nil or type(arg) == "number" then
+            i, colSpan, arg = i + 1, select(i, ...)
+        end
+
+        if arg == nil or type(arg) == "table" and type(arg.AcquireCell) == "function" then
+            i, provider = i + 1, arg
+        end
+
+        return _SetCell(self, lineNum, colNum, value, font, justification, colSpan, provider, select(i, ...))
+    end
+end -- do-block
+
+function tipPrototype:GetFont()
+    return self.regularFont
+end
+
+function tipPrototype:GetHeaderFont()
+    return self.headerFont
+end
+
+function tipPrototype:GetLineCount()
+    return #self.lines
+end
+
+function tipPrototype:GetColumnCount()
+    return #self.columns
+end
+
+------------------------------------------------------------------------------
+-- Frame Scripts
+------------------------------------------------------------------------------
+local scripts = {
+    OnEnter = function(frame, ...)
+        highlightFrame:SetParent(frame)
+        highlightFrame:SetAllPoints(frame)
+        highlightFrame:Show()
+
+        if frame._OnEnter_func then
+            frame:_OnEnter_func(frame._OnEnter_arg, ...)
+        end
+    end,
+    OnLeave = function(frame, ...)
+        highlightFrame:Hide()
+        highlightFrame:ClearAllPoints()
+        highlightFrame:SetParent(nil)
+
+        if frame._OnLeave_func then
+            frame:_OnLeave_func(frame._OnLeave_arg, ...)
+        end
+    end,
+    OnMouseDown = function(frame, ...)
+        frame:_OnMouseDown_func(frame._OnMouseDown_arg, ...)
+    end,
+    OnMouseUp = function(frame, ...)
+        frame:_OnMouseUp_func(frame._OnMouseUp_arg, ...)
+    end,
+    OnReceiveDrag = function(frame, ...)
+        frame:_OnReceiveDrag_func(frame._OnReceiveDrag_arg, ...)
+    end,
+	-- SUPPORT FOR MORE EVENTS
+	OnEvent = function(frame, ...)
+		frame:_OnEvent_func(frame._OnEvent_arg, ...)
+	end,
+}
+
+function SetFrameScript(frame, script, func, arg)
+    if not scripts[script] then
+        return
+    end
+
+    frame["_" .. script .. "_func"] = func
+    frame["_" .. script .. "_arg"] = arg
+
+    if script == "OnMouseDown" or script == "OnMouseUp" or script == "OnReceiveDrag" then
+        if func then
+            frame:SetScript(script, scripts[script])
+        else
+            frame:SetScript(script, nil)
+        end
+    end
+	
+	-- SUPPORT FOR MORE EVENTS
+	if script == "OnEvent" then
+		if func then
+			frame:RegisterEvent("MODIFIER_STATE_CHANGED")
+			frame:SetScript(script, scripts[script])
+		else
+			frame:SetScript(script, nil)
+		end
+	end
+
+    -- if at least one script is set, set the OnEnter/OnLeave scripts for the highlight
+    if frame._OnEnter_func or frame._OnLeave_func or frame._OnMouseDown_func or frame._OnMouseUp_func or frame._OnReceiveDrag_func then
+        frame:EnableMouse(true)
+        frame:SetScript("OnEnter", scripts.OnEnter)
+        frame:SetScript("OnLeave", scripts.OnLeave)
+    else
+        frame:EnableMouse(false)
+        frame:SetScript("OnEnter", nil)
+        frame:SetScript("OnLeave", nil)
+    end
+end
+
+function ClearFrameScripts(frame)
+    if frame._OnEnter_func or frame._OnLeave_func or frame._OnMouseDown_func or frame._OnMouseUp_func or frame._OnReceiveDrag_func then
+        frame:EnableMouse(false)
+
+        frame:SetScript("OnEnter", nil)
+        frame._OnEnter_func = nil
+        frame._OnEnter_arg = nil
+
+        frame:SetScript("OnLeave", nil)
+        frame._OnLeave_func = nil
+        frame._OnLeave_arg = nil
+
+        frame:SetScript("OnReceiveDrag", nil)
+        frame._OnReceiveDrag_func = nil
+        frame._OnReceiveDrag_arg = nil
+
+        frame:SetScript("OnMouseDown", nil)
+        frame._OnMouseDown_func = nil
+        frame._OnMouseDown_arg = nil
+
+        frame:SetScript("OnMouseUp", nil)
+        frame._OnMouseUp_func = nil
+        frame._OnMouseUp_arg = nil
+	elseif frame._OnEvent_func then
+		frame:SetScript("OnEvent", nil)
+		frame._OnEvent_func = nil
+		frame._OnEvent_arg = nil
+		frame:UnregisterEvent("MODIFIER_STATE_CHANGED")
+	end
+end
+
+function tipPrototype:SetLineScript(lineNum, script, func, arg)
+    SetFrameScript(self.lines[lineNum], script, func, arg)
+end
+
+function tipPrototype:SetColumnScript(colNum, script, func, arg)
+    SetFrameScript(self.columns[colNum], script, func, arg)
+end
+
+function tipPrototype:SetCellScript(lineNum, colNum, script, func, arg)
+    local cell = self.lines[lineNum].cells[colNum]
+
+    if cell then
+        SetFrameScript(cell, script, func, arg)
+    end
+end
+
+------------------------------------------------------------------------------
+-- Auto-hiding feature
+------------------------------------------------------------------------------
+
+-- Script of the auto-hiding child frame
+local function AutoHideTimerFrame_OnUpdate(self, elapsed)
+    self.checkElapsed = self.checkElapsed + elapsed
+
+    if self.checkElapsed > 0.1 then
+        if self.parent:IsMouseOver() or (self.alternateFrame and self.alternateFrame:IsMouseOver()) then
+            self.elapsed = 0
+        else
+            self.elapsed = self.elapsed + self.checkElapsed
+
+            if self.elapsed >= self.delay then
+                lib:Release(self.parent)
+            end
+        end
+
+        self.checkElapsed = 0
+    end
+end
+
+-- Usage:
+-- :SetAutoHideDelay(0.25) => hides after 0.25sec outside of the tooltip
+-- :SetAutoHideDelay(0.25, someFrame) => hides after 0.25sec outside of both the tooltip and someFrame
+-- :SetAutoHideDelay() => disable auto-hiding (default)
+function tipPrototype:SetAutoHideDelay(delay, alternateFrame, releaseHandler)
+    local timerFrame = self.autoHideTimerFrame
+    delay = tonumber(delay) or 0
+
+    if releaseHandler then
+        if type(releaseHandler) ~= "function" then
+            error("releaseHandler must be a function", 2)
+        end
+
+        lib.onReleaseHandlers[self] = releaseHandler
+    end
+
+    if delay > 0 then
+        if not timerFrame then
+            timerFrame = AcquireTimer(self)
+            timerFrame:SetScript("OnUpdate", AutoHideTimerFrame_OnUpdate)
+
+            self.autoHideTimerFrame = timerFrame
+        end
+
+        timerFrame.parent = self
+        timerFrame.checkElapsed = 0
+        timerFrame.elapsed = 0
+        timerFrame.delay = delay
+        timerFrame.alternateFrame = alternateFrame
+        timerFrame:Show()
+    elseif timerFrame then
+        self.autoHideTimerFrame = nil
+
+        timerFrame.alternateFrame = nil
+        timerFrame:SetScript("OnUpdate", nil)
+
+        ReleaseTimer(timerFrame)
+    end
+end
+
+------------------------------------------------------------------------------
+-- "Smart" Anchoring
+------------------------------------------------------------------------------
+local function GetTipAnchor(frame)
+    local x, y = frame:GetCenter()
+	--if not x or not y then return "TOPLEFT", "BOTTOMLEFT" end
+	if not x or not y then return "BOTTOMLEFT" end
+	local hhalf = (x > UIParent:GetWidth() * 2 / 3) and "RIGHT" or (x < UIParent:GetWidth() / 3) and "LEFT" or "LEFT"
+	--local vhalf = (y > UIParent:GetHeight() / 2) and "TOP" or "BOTTOM"
+	--return vhalf .. hhalf, frame, (vhalf == "TOP" and "BOTTOM" or "TOP") .. hhalf
+	return "BOTTOM"..hhalf, frame, "BOTTOM".. (hhalf == "RIGHT" and "LEFT" or "RIGHT")
+end
+
+function tipPrototype:SmartAnchorTo(frame)
+    if not frame then
+        error("Invalid frame provided.", 2)
+    end
+
+    self:ClearAllPoints()
+    self:SetClampedToScreen(true)
+    self:SetPoint(GetTipAnchor(frame))
+end
+
+------------------------------------------------------------------------------
+-- Debug slashcmds
+------------------------------------------------------------------------------
+-- @debug @
+local print = print
+local function PrintStats()
+    local tipCache = tostring(#tooltipHeap)
+    local frameCache = tostring(#frameHeap)
+    local tableCache = tostring(#tableHeap)
+    local header = false
+
+    print("Tooltips used: " .. usedTooltips .. ", Cached: " .. tipCache .. ", Total: " .. tipCache + usedTooltips)
+    print("Frames used: " .. usedFrames .. ", Cached: " .. frameCache .. ", Total: " .. frameCache + usedFrames)
+    print("Tables used: " .. usedTables .. ", Cached: " .. tableCache .. ", Total: " .. tableCache + usedTables)
+
+    for k in pairs(activeTooltips) do
+        if not header then
+            print("Active tooltips:")
+            header = true
+        end
+        print("- " .. k)
+    end
+end
+
+SLASH_LibQTip1 = "/qtip"
+_G.SlashCmdList["LibQTip"] = PrintStats
+--@end-debug@
diff --git a/Carbonite/Libs/LibQTip-1.0/lib.xml b/Carbonite/Libs/LibQTip-1.0/lib.xml
index f212246..5531be0 100644
--- a/Carbonite/Libs/LibQTip-1.0/lib.xml
+++ b/Carbonite/Libs/LibQTip-1.0/lib.xml
@@ -1,4 +1,4 @@
-<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
-..\FrameXML\UI.xsd">
-	<Script file="LibQTip-1.0.lua"/>
+<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
+..\FrameXML\UI.xsd">
+	<Script file="LibQTip-1.0.lua"/>
 </Ui>
\ No newline at end of file
diff --git a/Carbonite/Libs/LibStub/LibStub.lua b/Carbonite/Libs/LibStub/LibStub.lua
index 7a442e2..d50c267 100644
--- a/Carbonite/Libs/LibStub/LibStub.lua
+++ b/Carbonite/Libs/LibStub/LibStub.lua
@@ -1,30 +1,30 @@
--- LibStub is a simple versioning stub meant for use in Libraries.  http://www.wowace.com/wiki/LibStub for more info
--- LibStub is hereby placed in the Public Domain Credits: Kaelten, Cladhaire, ckknight, Mikk, Ammo, Nevcairiel, joshborke
-local LIBSTUB_MAJOR, LIBSTUB_MINOR = "LibStub", 2  -- NEVER MAKE THIS AN SVN REVISION! IT NEEDS TO BE USABLE IN ALL REPOS!
-local LibStub = _G[LIBSTUB_MAJOR]
-
-if not LibStub or LibStub.minor < LIBSTUB_MINOR then
-	LibStub = LibStub or {libs = {}, minors = {} }
-	_G[LIBSTUB_MAJOR] = LibStub
-	LibStub.minor = LIBSTUB_MINOR
-
-	function LibStub:NewLibrary(major, minor)
-		assert(type(major) == "string", "Bad argument #2 to `NewLibrary' (string expected)")
-		minor = assert(tonumber(string.match(minor, "%d+")), "Minor version must either be a number or contain a number.")
-
-		local oldminor = self.minors[major]
-		if oldminor and oldminor >= minor then return nil end
-		self.minors[major], self.libs[major] = minor, self.libs[major] or {}
-		return self.libs[major], oldminor
-	end
-
-	function LibStub:GetLibrary(major, silent)
-		if not self.libs[major] and not silent then
-			error(("Cannot find a library instance of %q."):format(tostring(major)), 2)
-		end
-		return self.libs[major], self.minors[major]
-	end
-
-	function LibStub:IterateLibraries() return pairs(self.libs) end
-	setmetatable(LibStub, { __call = LibStub.GetLibrary })
-end
+-- LibStub is a simple versioning stub meant for use in Libraries.  http://www.wowace.com/wiki/LibStub for more info
+-- LibStub is hereby placed in the Public Domain Credits: Kaelten, Cladhaire, ckknight, Mikk, Ammo, Nevcairiel, joshborke
+local LIBSTUB_MAJOR, LIBSTUB_MINOR = "LibStub", 2  -- NEVER MAKE THIS AN SVN REVISION! IT NEEDS TO BE USABLE IN ALL REPOS!
+local LibStub = _G[LIBSTUB_MAJOR]
+
+if not LibStub or LibStub.minor < LIBSTUB_MINOR then
+	LibStub = LibStub or {libs = {}, minors = {} }
+	_G[LIBSTUB_MAJOR] = LibStub
+	LibStub.minor = LIBSTUB_MINOR
+
+	function LibStub:NewLibrary(major, minor)
+		assert(type(major) == "string", "Bad argument #2 to `NewLibrary' (string expected)")
+		minor = assert(tonumber(string.match(minor, "%d+")), "Minor version must either be a number or contain a number.")
+
+		local oldminor = self.minors[major]
+		if oldminor and oldminor >= minor then return nil end
+		self.minors[major], self.libs[major] = minor, self.libs[major] or {}
+		return self.libs[major], oldminor
+	end
+
+	function LibStub:GetLibrary(major, silent)
+		if not self.libs[major] and not silent then
+			error(("Cannot find a library instance of %q."):format(tostring(major)), 2)
+		end
+		return self.libs[major], self.minors[major]
+	end
+
+	function LibStub:IterateLibraries() return pairs(self.libs) end
+	setmetatable(LibStub, { __call = LibStub.GetLibrary })
+end
diff --git a/Carbonite/Locales/enUS/FlightMasters.lua b/Carbonite/Locales/enUS/FlightMasters.lua
old mode 100755
new mode 100644
diff --git a/Carbonite/Locales/esES/FlightMasters.lua b/Carbonite/Locales/esES/FlightMasters.lua
old mode 100755
new mode 100644
diff --git a/Carbonite/Locales/esMX/FlightMasters.lua b/Carbonite/Locales/esMX/FlightMasters.lua
old mode 100755
new mode 100644
diff --git a/Carbonite/Locales/frFR/FlightMasters.lua b/Carbonite/Locales/frFR/FlightMasters.lua
old mode 100755
new mode 100644
diff --git a/Carbonite/Locales/itIT/FlightMasters.lua b/Carbonite/Locales/itIT/FlightMasters.lua
old mode 100755
new mode 100644
diff --git a/Carbonite/Locales/koKR/FlightMasters.lua b/Carbonite/Locales/koKR/FlightMasters.lua
old mode 100755
new mode 100644
diff --git a/Carbonite/Locales/ruRU/FlightMasters.lua b/Carbonite/Locales/ruRU/FlightMasters.lua
old mode 100755
new mode 100644
diff --git a/Carbonite/Locales/zhTW/FlightMasters.lua b/Carbonite/Locales/zhTW/FlightMasters.lua
old mode 100755
new mode 100644
diff --git a/Carbonite/NxMap.lua b/Carbonite/NxMap.lua
index 25e824d..8fde79f 100644
--- a/Carbonite/NxMap.lua
+++ b/Carbonite/NxMap.lua
@@ -695,6 +695,19 @@ function Nx.Map:Create(index)
     m.Scrolling = false                     -- Currently scrolling
     m.StepTime = 0                          -- Animation step time
 
+    ---------------------------------------------------------------------------
+    -- Edit Mode State (for drawing quest objective rectangles)
+    ---------------------------------------------------------------------------
+    m.EditMode = false                      -- Edit mode enabled
+    m.EditDrawing = false                   -- Currently drawing a rectangle
+    m.EditStartX = nil                      -- Start X coordinate (zone 0-100)
+    m.EditStartY = nil                      -- Start Y coordinate (zone 0-100)
+    m.EditMapId = nil                       -- Map ID where drawing started
+    m.EditPreviewFrame = nil                -- Preview rectangle frame
+    m.EditRectangles = {}                   -- Array of drawn rectangles
+    m.EditRectFrames = {}                   -- Array of rectangle display frames
+    m.EditFinishButton = nil                -- Button to finish and output all
+
     ---------------------------------------------------------------------------
     -- Map Position and Zone State
     ---------------------------------------------------------------------------
@@ -3956,6 +3969,11 @@ function Nx.Map:OnMouseDown (button)
         end
 --]]
 
+        -- Edit mode: Ctrl+Alt+LeftClick starts rectangle drawing
+        if map:EditModeMouseDown(button) then
+            return
+        end
+
         if IsControlKeyDown() and map:CallFunc ("ButLCtrl") then    -- If func does nothing continue
 
         elseif IsAltKeyDown() and map:CallFunc ("ButLAlt") then    -- If func does nothing continue
@@ -4066,6 +4084,12 @@ end
 function Nx.Map:OnMouseUp(button)
     local this = self
     local map = this.NxMap
+    
+    -- Edit mode: finalize rectangle on mouse up
+    if map:EditModeMouseUp(button) then
+        return
+    end
+    
     map.Scrolling = false
 end
 
@@ -4337,6 +4361,9 @@ function Nx.Map.OnUpdate(this, elapsed)
         map.Scale = map.ScaleDraw
     end
 
+    -- Update edit mode preview rectangle while drawing
+    map:EditModeUpdate()
+
     map:Update (elapsed)
 
     -- Title text
@@ -12504,6 +12531,909 @@ function Nx.Map:UnpackObjective (obj)
     local zone = strbyte (obj, i + 1) - 35
     return desc, zone, i + 2
 end
+
+-------------------------------------------------------------------------------
+-- EDIT MODE - QUEST OBJECTIVE RECTANGLE DRAWING
+-- Allows manual drawing of multiple objective rectangles on the map
+-- Activated with /carb editmode, draw with Ctrl+Alt+LeftClick+Drag
+-- Each rectangle has a close button, finish button outputs all rectangles
+-------------------------------------------------------------------------------
+
+---
+-- Toggle edit mode for quest objective rectangle drawing
+--
+function Nx.Map:ToggleEditMode()
+    self.EditMode = not self.EditMode
+    if self.EditMode then
+        Nx.prt("|cff00ff00Quest Objective Edit Mode ENABLED|r")
+        Nx.prt("|cffffffff  Ctrl+Alt+Click = place a point (type 32)|r")
+        Nx.prt("|cffffffff  Ctrl+Alt+Click+Drag = draw a rectangle (type 35)|r")
+        Nx.prt("|cffffffff  Click [X] to remove, [Finish] to output all|r")
+        self:EditModeCreateFinishButton()
+    else
+        Nx.prt("|cffff0000Quest Objective Edit Mode DISABLED|r")
+        self:EditModeClearAll()
+    end
+end
+
+---
+-- Create the finish button for outputting all rectangles
+--
+function Nx.Map:EditModeCreateFinishButton()
+    if self.EditFinishButton then
+        self.EditFinishButton:Show()
+        return
+    end
+    
+    local map = self
+    local f = CreateFrame("Button", nil, self.Frm, "UIPanelButtonTemplate")
+    f:SetSize(80, 22)
+    f:SetPoint("TOPRIGHT", self.Frm, "TOPRIGHT", -10, -30)
+    f:SetText("Finish")
+    f:SetFrameLevel(100)
+    f:SetScript("OnClick", function()
+        map:EditModeFinish()
+    end)
+    f:SetScript("OnEnter", function(self)
+        GameTooltip:SetOwner(self, "ANCHOR_LEFT")
+        GameTooltip:AddLine("Output all rectangles to chat")
+        GameTooltip:AddLine("and clear the editor", 0.7, 0.7, 0.7)
+        GameTooltip:Show()
+    end)
+    f:SetScript("OnLeave", function()
+        GameTooltip:Hide()
+    end)
+    
+    -- Add a "Clear All" button next to it
+    local clearBtn = CreateFrame("Button", nil, self.Frm, "UIPanelButtonTemplate")
+    clearBtn:SetSize(70, 22)
+    clearBtn:SetPoint("RIGHT", f, "LEFT", -5, 0)
+    clearBtn:SetText("Clear")
+    clearBtn:SetFrameLevel(100)
+    clearBtn:SetScript("OnClick", function()
+        map:EditModeClearRectangles()
+        Nx.prt("|cffff8000All rectangles cleared|r")
+    end)
+    clearBtn:SetScript("OnEnter", function(self)
+        GameTooltip:SetOwner(self, "ANCHOR_LEFT")
+        GameTooltip:AddLine("Clear all rectangles")
+        GameTooltip:AddLine("without outputting", 0.7, 0.7, 0.7)
+        GameTooltip:Show()
+    end)
+    clearBtn:SetScript("OnLeave", function()
+        GameTooltip:Hide()
+    end)
+    
+    -- Rectangle count label
+    local countLabel = f:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
+    countLabel:SetPoint("RIGHT", clearBtn, "LEFT", -10, 0)
+    countLabel:SetText("0 rects")
+    
+    self.EditFinishButton = f
+    self.EditClearButton = clearBtn
+    self.EditCountLabel = countLabel
+end
+
+---
+-- Update the rectangle count display
+--
+function Nx.Map:EditModeUpdateCount()
+    if self.EditCountLabel then
+        local total = #self.EditRectangles
+        local points = 0
+        local rects = 0
+        for _, data in ipairs(self.EditRectangles) do
+            if data.isPoint then
+                points = points + 1
+            else
+                rects = rects + 1
+            end
+        end
+        
+        local text
+        if points > 0 and rects > 0 then
+            text = rects .. "R " .. points .. "P"
+        elseif points > 0 then
+            text = points .. (points == 1 and " pt" or " pts")
+        elseif rects > 0 then
+            text = rects .. (rects == 1 and " rect" or " rects")
+        else
+            text = "0"
+        end
+        
+        self.EditCountLabel:SetText(text)
+        if total > 0 then
+            self.EditCountLabel:SetTextColor(0, 1, 0)
+        else
+            self.EditCountLabel:SetTextColor(0.7, 0.7, 0.7)
+        end
+    end
+end
+
+---
+-- Clear all rectangles without output
+--
+function Nx.Map:EditModeClearRectangles()
+    -- Hide all rectangle frames
+    for i, frame in ipairs(self.EditRectFrames) do
+        frame:Hide()
+    end
+    self.EditRectFrames = {}
+    self.EditRectangles = {}
+    
+    if self.EditPreviewFrame then
+        self.EditPreviewFrame:Hide()
+    end
+    self.EditDrawing = false
+    self:EditModeUpdateCount()
+end
+
+---
+-- Clear everything and hide UI
+--
+function Nx.Map:EditModeClearAll()
+    self:EditModeClearRectangles()
+    
+    if self.EditFinishButton then
+        self.EditFinishButton:Hide()
+    end
+    if self.EditClearButton then
+        self.EditClearButton:Hide()
+    end
+    if self.EditCountLabel then
+        self.EditCountLabel:SetText("")
+    end
+end
+
+---
+-- Create a persistent rectangle frame with close button
+-- @param rectData  Table with x, y, w, h, mapId
+-- @param index     Index in the rectangles array
+--
+function Nx.Map:EditModeCreateRectFrame(rectData, index)
+    local map = self
+    
+    -- Use stable frame level (base + high offset to be above map elements)
+    local baseLevel = self.Frm:GetFrameLevel() + 100
+    
+    -- Main rectangle frame
+    local f = CreateFrame("Frame", nil, self.Frm)
+    f:SetFrameLevel(baseLevel)
+    f.NxEditIndex = index
+    f.NxRectData = rectData
+    f.NxBaseLevel = baseLevel  -- Store for later use
+    
+    -- Rectangle texture (semi-transparent green with border effect)
+    local t = f:CreateTexture(nil, "OVERLAY")
+    t:SetAllPoints(f)
+    t:SetColorTexture(0, 0.8, 0, 0.35)
+    f.texture = t
+    
+    -- Border textures for visibility
+    local borderSize = 2
+    local borders = {}
+    for i = 1, 4 do
+        local b = f:CreateTexture(nil, "OVERLAY")
+        b:SetColorTexture(0, 1, 0, 0.9)
+        borders[i] = b
+    end
+    -- Top
+    borders[1]:SetPoint("TOPLEFT", f, "TOPLEFT", 0, 0)
+    borders[1]:SetPoint("TOPRIGHT", f, "TOPRIGHT", 0, 0)
+    borders[1]:SetHeight(borderSize)
+    -- Bottom
+    borders[2]:SetPoint("BOTTOMLEFT", f, "BOTTOMLEFT", 0, 0)
+    borders[2]:SetPoint("BOTTOMRIGHT", f, "BOTTOMRIGHT", 0, 0)
+    borders[2]:SetHeight(borderSize)
+    -- Left
+    borders[3]:SetPoint("TOPLEFT", f, "TOPLEFT", 0, 0)
+    borders[3]:SetPoint("BOTTOMLEFT", f, "BOTTOMLEFT", 0, 0)
+    borders[3]:SetWidth(borderSize)
+    -- Right
+    borders[4]:SetPoint("TOPRIGHT", f, "TOPRIGHT", 0, 0)
+    borders[4]:SetPoint("BOTTOMRIGHT", f, "BOTTOMRIGHT", 0, 0)
+    borders[4]:SetWidth(borderSize)
+    f.borders = borders
+    
+    -- Close button (X) in upper right
+    local closeBtn = CreateFrame("Button", nil, f)
+    closeBtn:SetSize(16, 16)
+    closeBtn:SetPoint("TOPRIGHT", f, "TOPRIGHT", 2, 2)
+    closeBtn:SetFrameLevel(baseLevel + 5)
+    closeBtn.NxEditIndex = index
+    
+    -- Close button background
+    local closeBg = closeBtn:CreateTexture(nil, "BACKGROUND")
+    closeBg:SetAllPoints()
+    closeBg:SetColorTexture(0.8, 0, 0, 0.8)
+    
+    -- Close button X text
+    local closeText = closeBtn:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
+    closeText:SetPoint("CENTER", 0, 0)
+    closeText:SetText("X")
+    closeText:SetTextColor(1, 1, 1)
+    
+    closeBtn:SetScript("OnClick", function(self)
+        map:EditModeRemoveRect(self.NxEditIndex)
+    end)
+    closeBtn:SetScript("OnEnter", function(self)
+        closeBg:SetColorTexture(1, 0, 0, 1)
+    end)
+    closeBtn:SetScript("OnLeave", function(self)
+        closeBg:SetColorTexture(0.8, 0, 0, 0.8)
+    end)
+    
+    f.closeBtn = closeBtn
+    
+    -- Index label
+    local indexLabel = f:CreateFontString(nil, "OVERLAY", "GameFontNormal")
+    indexLabel:SetPoint("CENTER", f, "CENTER", 0, 0)
+    indexLabel:SetText(tostring(index))
+    indexLabel:SetTextColor(1, 1, 1, 0.7)
+    f.indexLabel = indexLabel
+    
+    return f
+end
+
+---
+-- Create a point marker frame with close button
+-- @param pointData  Table with x, y, mapId, isPoint=true
+-- @param index      Index in the rectangles array
+--
+function Nx.Map:EditModeCreatePointFrame(pointData, index)
+    local map = self
+    
+    -- Use stable frame level
+    local baseLevel = self.Frm:GetFrameLevel() + 105  -- Slightly above rectangles
+    
+    -- Main point frame (fixed size circle/dot)
+    local f = CreateFrame("Frame", nil, self.Frm)
+    f:SetSize(16, 16)
+    f:SetFrameLevel(baseLevel)
+    f.NxEditIndex = index
+    f.NxRectData = pointData
+    f.NxBaseLevel = baseLevel
+    f.NxIsPoint = true
+    
+    -- Point texture (cyan/blue dot)
+    local t = f:CreateTexture(nil, "OVERLAY")
+    t:SetAllPoints(f)
+    t:SetTexture("Interface\\MINIMAP\\ObjectIconsAtlas")
+    t:SetTexCoord(0.2578125, 0.2890625, 0.0078125, 0.0390625)  -- Small dot
+    t:SetVertexColor(0, 1, 1, 1)  -- Cyan color
+    f.texture = t
+    
+    -- Alternative: colored circle texture
+    local bg = f:CreateTexture(nil, "BACKGROUND")
+    bg:SetPoint("CENTER")
+    bg:SetSize(14, 14)
+    bg:SetColorTexture(0, 0.8, 0.8, 0.6)
+    f.bg = bg
+    
+    -- Border ring
+    local ring = f:CreateTexture(nil, "BORDER")
+    ring:SetPoint("CENTER")
+    ring:SetSize(16, 16)
+    ring:SetColorTexture(0, 1, 1, 0.9)
+    f.ring = ring
+    
+    -- Inner dot
+    local dot = f:CreateTexture(nil, "ARTWORK")
+    dot:SetPoint("CENTER")
+    dot:SetSize(10, 10)
+    dot:SetColorTexture(0, 0.6, 0.6, 1)
+    f.dot = dot
+    
+    -- Close button (X) 
+    local closeBtn = CreateFrame("Button", nil, f)
+    closeBtn:SetSize(12, 12)
+    closeBtn:SetPoint("TOPRIGHT", f, "TOPRIGHT", 4, 4)
+    closeBtn:SetFrameLevel(baseLevel + 5)
+    closeBtn.NxEditIndex = index
+    
+    local closeBg = closeBtn:CreateTexture(nil, "BACKGROUND")
+    closeBg:SetAllPoints()
+    closeBg:SetColorTexture(0.8, 0, 0, 0.8)
+    
+    local closeText = closeBtn:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
+    closeText:SetPoint("CENTER", 0, 0)
+    closeText:SetText("X")
+    closeText:SetTextColor(1, 1, 1)
+    
+    closeBtn:SetScript("OnClick", function(self)
+        map:EditModeRemoveRect(self.NxEditIndex)
+    end)
+    closeBtn:SetScript("OnEnter", function(self)
+        closeBg:SetColorTexture(1, 0, 0, 1)
+    end)
+    closeBtn:SetScript("OnLeave", function(self)
+        closeBg:SetColorTexture(0.8, 0, 0, 0.8)
+    end)
+    
+    f.closeBtn = closeBtn
+    
+    -- Index label
+    local indexLabel = f:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
+    indexLabel:SetPoint("BOTTOM", f, "TOP", 0, 2)
+    indexLabel:SetText(tostring(index))
+    indexLabel:SetTextColor(0, 1, 1, 0.9)
+    f.indexLabel = indexLabel
+    
+    return f
+end
+
+---
+-- Position a point frame at world coordinates
+-- @param frm  Frame to position
+-- @param wx   World X coordinate
+-- @param wy   World Y coordinate
+-- @return     true if visible, false if off-screen
+--
+function Nx.Map:EditModePositionPoint(frm, wx, wy)
+    local scale = self.ScaleDraw
+    local clipW = self.MapW
+    local clipH = self.MapH
+    
+    -- Calculate screen position from world coordinates (centered)
+    local sx = (wx - self.MapPosXDraw) * scale + clipW * 0.5
+    local sy = (wy - self.MapPosYDraw) * scale + clipH * 0.5
+    
+    -- Check if off screen (with margin for point size)
+    if sx < -8 or sx > clipW + 8 or sy < -8 or sy > clipH + 8 then
+        frm:Hide()
+        return false
+    end
+    
+    -- Position the frame centered on the point
+    frm:ClearAllPoints()
+    frm:SetPoint("CENTER", self.Frm, "TOPLEFT", sx, -sy - self.TitleH)
+    frm:Show()
+    
+    return true
+end
+
+---
+-- Remove a rectangle or point by index
+-- @param index  Index of item to remove
+--
+function Nx.Map:EditModeRemoveRect(index)
+    -- Get type before removing
+    local wasPoint = self.EditRectangles[index] and self.EditRectangles[index].isPoint
+    
+    -- Hide and remove the frame
+    if self.EditRectFrames[index] then
+        self.EditRectFrames[index]:Hide()
+    end
+    
+    -- Remove from arrays
+    table.remove(self.EditRectangles, index)
+    table.remove(self.EditRectFrames, index)
+    
+    -- Re-index remaining frames
+    for i, frame in ipairs(self.EditRectFrames) do
+        frame.NxEditIndex = i
+        frame.closeBtn.NxEditIndex = i
+        frame.indexLabel:SetText(tostring(i))
+    end
+    
+    self:EditModeUpdateCount()
+    local itemType = wasPoint and "Point" or "Rectangle"
+    Nx.prt("|cff808080%s %d removed (%d remaining)|r", itemType, index, #self.EditRectangles)
+end
+
+---
+-- Handle mouse down in edit mode
+-- Starts rectangle drawing on Ctrl+Alt+LeftButton
+-- @param button  Mouse button pressed
+-- @return        true if event was consumed, false otherwise
+--
+function Nx.Map:EditModeMouseDown(button)
+    if not self.EditMode then return false end
+    
+    if button == "LeftButton" and IsControlKeyDown() and IsAltKeyDown() then
+        -- Calculate click position - convert frame pos to world, then to zone coords
+        self:CalcClick()
+        local wx, wy = self:FramePosToWorldPos(self.ClickFrmX, self.ClickFrmY)
+        local x, y = self:GetZonePos(self.MapId, wx, wy)
+        
+        -- Clamp to valid range
+        x = max(0, min(100, x))
+        y = max(0, min(100, y))
+        
+        self.EditDrawing = true
+        self.EditStartX = x
+        self.EditStartY = y
+        self.EditMapId = self.MapId
+        
+        -- Create preview frame if it doesn't exist
+        if not self.EditPreviewFrame then
+            local f = CreateFrame("Frame", nil, self.Frm)
+            local previewLevel = self.Frm:GetFrameLevel() + 110  -- Above rect frames
+            f:SetFrameLevel(previewLevel)
+            f.NxBaseLevel = previewLevel
+            local t = f:CreateTexture(nil, "OVERLAY")
+            t:SetAllPoints(f)
+            t:SetColorTexture(0.2, 1, 0.2, 0.4)  -- Bright green for active drawing
+            f.texture = t
+            self.EditPreviewFrame = f
+        end
+        self.EditPreviewFrame:Show()
+        
+        return true
+    end
+    return false
+end
+
+---
+-- Position an edit mode rectangle frame using world coordinates
+-- @param frm    Frame to position
+-- @param wx1    World X of top-left
+-- @param wy1    World Y of top-left  
+-- @param wx2    World X of bottom-right
+-- @param wy2    World Y of bottom-right
+-- @return       true if visible, false if off-screen
+--
+function Nx.Map:EditModePositionRect(frm, wx1, wy1, wx2, wy2)
+    local scale = self.ScaleDraw
+    local clipW = self.MapW
+    local clipH = self.MapH
+    
+    -- Calculate screen positions from world coordinates
+    local sx1 = (wx1 - self.MapPosXDraw) * scale + clipW * 0.5
+    local sy1 = (wy1 - self.MapPosYDraw) * scale + clipH * 0.5
+    local sx2 = (wx2 - self.MapPosXDraw) * scale + clipW * 0.5
+    local sy2 = (wy2 - self.MapPosYDraw) * scale + clipH * 0.5
+    
+    -- Check if completely off screen
+    if sx2 < 0 or sx1 > clipW or sy2 < 0 or sy1 > clipH then
+        frm:Hide()
+        return false
+    end
+    
+    -- Clamp to visible area
+    sx1 = max(0, sx1)
+    sy1 = max(0, sy1)
+    sx2 = min(clipW, sx2)
+    sy2 = min(clipH, sy2)
+    
+    local w = sx2 - sx1
+    local h = sy2 - sy1
+    
+    if w < 1 or h < 1 then
+        frm:Hide()
+        return false
+    end
+    
+    -- Position the frame - clear existing points first!
+    frm:ClearAllPoints()
+    frm:SetPoint("TOPLEFT", self.Frm, "TOPLEFT", sx1, -sy1 - self.TitleH)
+    frm:SetSize(w, h)
+    frm:Show()
+    
+    return true
+end
+
+---
+-- Update edit mode - preview rectangle and existing rectangles
+-- Called during OnUpdate
+--
+function Nx.Map:EditModeUpdate()
+    if not self.EditMode then return end
+    
+    -- Update preview rectangle if drawing
+    if self.EditDrawing and self.EditPreviewFrame then
+        local f = self.Frm
+        local cx, cy = GetCursorPosition()
+        cx = cx / f:GetEffectiveScale()
+        cy = cy / f:GetEffectiveScale()
+        
+        local frmX = cx - f:GetLeft()
+        local frmY = f:GetTop() - cy
+        
+        -- Convert frame position to world, then to zone coordinates
+        local wx, wy = self:FramePosToWorldPos(frmX, frmY)
+        local endX, endY = self:GetZonePos(self.EditMapId, wx, wy)
+        
+        -- Clamp to valid range
+        endX = max(0, min(100, endX))
+        endY = max(0, min(100, endY))
+        
+        -- Calculate rectangle bounds
+        local x1 = min(self.EditStartX, endX)
+        local y1 = min(self.EditStartY, endY)
+        local x2 = max(self.EditStartX, endX)
+        local y2 = max(self.EditStartY, endY)
+        
+        -- Convert zone coords back to world coordinates for drawing
+        local wx1, wy1 = self:GetWorldPos(self.EditMapId, x1, y1)
+        local wx2, wy2 = self:GetWorldPos(self.EditMapId, x2, y2)
+        
+        if self:EditModePositionRect(self.EditPreviewFrame, wx1, wy1, wx2, wy2) then
+            -- Use stored stable frame level
+            if self.EditPreviewFrame.NxBaseLevel then
+                self.EditPreviewFrame:SetFrameLevel(self.EditPreviewFrame.NxBaseLevel)
+            end
+            self.EditPreviewFrame.texture:SetColorTexture(0.2, 1, 0.2, 0.4)
+        end
+    end
+    
+    -- Update all existing rectangle/point positions (for map pan/zoom)
+    for i, frame in ipairs(self.EditRectFrames) do
+        local data = frame.NxRectData
+        if data then
+            if data.isPoint then
+                -- Position point
+                local pwx, pwy = self:GetWorldPos(data.mapId, data.x, data.y)
+                if self:EditModePositionPoint(frame, pwx, pwy) then
+                    if frame.NxBaseLevel then
+                        frame:SetFrameLevel(frame.NxBaseLevel)
+                    end
+                end
+            else
+                -- Position rectangle
+                local wx1, wy1 = self:GetWorldPos(data.mapId, data.x, data.y)
+                local wx2, wy2 = self:GetWorldPos(data.mapId, data.x + data.w, data.y + data.h)
+                
+                if self:EditModePositionRect(frame, wx1, wy1, wx2, wy2) then
+                    if frame.NxBaseLevel then
+                        frame:SetFrameLevel(frame.NxBaseLevel)
+                    end
+                end
+            end
+        end
+    end
+end
+
+---
+-- Check if two rectangles overlap
+-- @param r1  Rectangle 1 {x, y, w, h}
+-- @param r2  Rectangle 2 {x, y, w, h}
+-- @return    true if overlapping, false otherwise
+--
+function Nx.Map:EditModeRectsOverlap(r1, r2)
+    -- Points don't overlap with anything (they're just markers)
+    if r1.isPoint or r2.isPoint then
+        return false
+    end
+    
+    -- Check if r1 and r2 overlap (excluding touching edges)
+    local r1x2 = r1.x + r1.w
+    local r1y2 = r1.y + r1.h
+    local r2x2 = r2.x + r2.w
+    local r2y2 = r2.y + r2.h
+    
+    -- No overlap if one is completely to the side of the other
+    if r1x2 <= r2.x or r2x2 <= r1.x then return false end
+    if r1y2 <= r2.y or r2y2 <= r1.y then return false end
+    
+    return true
+end
+
+---
+-- Adjust a new rectangle to eliminate overlap with existing rectangles
+-- Creates flush edges for clean blob coverage
+-- @param newRect  The new rectangle to adjust {x, y, w, h}
+-- @return         Adjusted rectangle (may be split into multiple), or nil if completely inside existing
+--
+function Nx.Map:EditModeAdjustForOverlap(newRect)
+    local adjusted = {x = newRect.x, y = newRect.y, w = newRect.w, h = newRect.h, mapId = newRect.mapId}
+    local wasAdjusted = false
+    
+    for _, existing in ipairs(self.EditRectangles) do
+        if self:EditModeRectsOverlap(adjusted, existing) then
+            -- Calculate overlap region
+            local overlapX1 = max(adjusted.x, existing.x)
+            local overlapY1 = max(adjusted.y, existing.y)
+            local overlapX2 = min(adjusted.x + adjusted.w, existing.x + existing.w)
+            local overlapY2 = min(adjusted.y + adjusted.h, existing.y + existing.h)
+            
+            local overlapW = overlapX2 - overlapX1
+            local overlapH = overlapY2 - overlapY1
+            
+            -- Determine which edge to adjust (pick the one that removes least area)
+            -- Calculate how much we'd lose by trimming each edge
+            local trimLeft = overlapX2 - adjusted.x  -- trim from left edge
+            local trimRight = (adjusted.x + adjusted.w) - overlapX1  -- trim from right
+            local trimTop = overlapY2 - adjusted.y  -- trim from top
+            local trimBottom = (adjusted.y + adjusted.h) - overlapY1  -- trim from bottom
+            
+            -- Calculate area lost for each trim option
+            local areaLeft = trimLeft * adjusted.h
+            local areaRight = trimRight * adjusted.h
+            local areaTop = trimTop * adjusted.w
+            local areaBottom = trimBottom * adjusted.w
+            
+            -- Find minimum loss that still leaves a valid rectangle
+            local minLoss = math.huge
+            local bestTrim = nil
+            
+            -- Only consider trims that leave a rectangle with positive dimensions
+            if adjusted.w - trimLeft > 0.5 and areaLeft < minLoss then
+                minLoss = areaLeft
+                bestTrim = "left"
+            end
+            if adjusted.w - trimRight > 0.5 and areaRight < minLoss then
+                minLoss = areaRight
+                bestTrim = "right"
+            end
+            if adjusted.h - trimTop > 0.5 and areaTop < minLoss then
+                minLoss = areaTop
+                bestTrim = "top"
+            end
+            if adjusted.h - trimBottom > 0.5 and areaBottom < minLoss then
+                minLoss = areaBottom
+                bestTrim = "bottom"
+            end
+            
+            -- Apply the trim
+            if bestTrim == "left" then
+                adjusted.w = adjusted.w - trimLeft
+                adjusted.x = overlapX2
+                wasAdjusted = true
+            elseif bestTrim == "right" then
+                adjusted.w = overlapX1 - adjusted.x
+                wasAdjusted = true
+            elseif bestTrim == "top" then
+                adjusted.h = adjusted.h - trimTop
+                adjusted.y = overlapY2
+                wasAdjusted = true
+            elseif bestTrim == "bottom" then
+                adjusted.h = overlapY1 - adjusted.y
+                wasAdjusted = true
+            else
+                -- No valid trim found - rectangle is too small or completely inside existing
+                return nil, true
+            end
+            
+            -- Check if adjusted rectangle is still valid
+            if adjusted.w < 0.5 or adjusted.h < 0.5 then
+                return nil, true
+            end
+        end
+    end
+    
+    return adjusted, wasAdjusted
+end
+
+---
+-- Handle mouse up in edit mode
+-- Finalizes the rectangle and adds it to the list
+-- @param button  Mouse button released
+-- @return        true if event was consumed, false otherwise
+--
+function Nx.Map:EditModeMouseUp(button)
+    if not self.EditMode or not self.EditDrawing then return false end
+    
+    if button == "LeftButton" then
+        self.EditDrawing = false
+        
+        -- Get final cursor position - convert frame pos to world, then to zone coords
+        local f = self.Frm
+        local cx, cy = GetCursorPosition()
+        cx = cx / f:GetEffectiveScale()
+        cy = cy / f:GetEffectiveScale()
+        
+        local frmX = cx - f:GetLeft()
+        local frmY = f:GetTop() - cy
+        local wx, wy = self:FramePosToWorldPos(frmX, frmY)
+        local endX, endY = self:GetZonePos(self.EditMapId, wx, wy)
+        
+        -- Clamp to valid range
+        endX = max(0, min(100, endX))
+        endY = max(0, min(100, endY))
+        
+        -- Calculate size of drawn area
+        local w = abs(endX - self.EditStartX)
+        local h = abs(endY - self.EditStartY)
+        
+        -- Hide preview
+        if self.EditPreviewFrame then
+            self.EditPreviewFrame:Hide()
+        end
+        
+        -- Determine if this is a POINT (small drag) or RECTANGLE (larger drag)
+        local isPoint = (w < 1.5 and h < 1.5)
+        
+        if isPoint then
+            -- Create a POINT at the click location
+            local pointX = (self.EditStartX + endX) / 2  -- Center of tiny drag
+            local pointY = (self.EditStartY + endY) / 2
+            
+            local pointData = {
+                x = pointX,
+                y = pointY,
+                isPoint = true,
+                mapId = self.EditMapId
+            }
+            
+            local index = #self.EditRectangles + 1
+            self.EditRectangles[index] = pointData
+            
+            -- Create point frame
+            local pointFrame = self:EditModeCreatePointFrame(pointData, index)
+            self.EditRectFrames[index] = pointFrame
+            
+            -- Position the frame
+            local pwx, pwy = self:GetWorldPos(pointData.mapId, pointX, pointY)
+            self:EditModePositionPoint(pointFrame, pwx, pwy)
+            
+            self:EditModeUpdateCount()
+            Nx.prt("|cff80ffff Point %d added|r at (%.1f, %.1f)", index, pointX, pointY)
+        else
+            -- Create a RECTANGLE
+            local x = min(self.EditStartX, endX)
+            local y = min(self.EditStartY, endY)
+            
+            -- Check for minimum size for rectangles
+            if w < 0.5 or h < 0.5 then
+                Nx.prt("|cffff0000Rectangle too small - cancelled|r")
+                return true
+            end
+            
+            -- Create initial rectangle data
+            local rectData = {
+                x = x,
+                y = y,
+                w = w,
+                h = h,
+                isPoint = false,
+                mapId = self.EditMapId
+            }
+            
+            -- Adjust for overlaps with existing rectangles
+            local adjustedRect, wasAdjusted = self:EditModeAdjustForOverlap(rectData)
+            
+            if not adjustedRect then
+                Nx.prt("|cffff8000Rectangle overlaps existing - skipped|r")
+                return true
+            end
+            
+            -- Use the adjusted rectangle
+            rectData = adjustedRect
+            rectData.isPoint = false
+            x, y, w, h = rectData.x, rectData.y, rectData.w, rectData.h
+            
+            local index = #self.EditRectangles + 1
+            self.EditRectangles[index] = rectData
+            
+            -- Create persistent frame for this rectangle
+            local rectFrame = self:EditModeCreateRectFrame(rectData, index)
+            self.EditRectFrames[index] = rectFrame
+            
+            -- Position the frame using our custom function
+            local wx1, wy1 = self:GetWorldPos(rectData.mapId, x, y)
+            local wx2, wy2 = self:GetWorldPos(rectData.mapId, x + w, y + h)
+            self:EditModePositionRect(rectFrame, wx1, wy1, wx2, wy2)
+            
+            self:EditModeUpdateCount()
+            if wasAdjusted then
+                Nx.prt("|cff80ff80Rectangle %d added (adjusted)|r (%.1f, %.1f) size %.1fx%.1f", index, x, y, w, h)
+            else
+                Nx.prt("|cff80ff80Rectangle %d added|r (%.1f, %.1f) size %.1fx%.1f", index, x, y, w, h)
+            end
+        end
+        
+        return true
+    end
+    return false
+end
+
+---
+-- Finish editing - output all rectangles and clear
+--
+function Nx.Map:EditModeFinish()
+    local count = #self.EditRectangles
+    
+    if count == 0 then
+        Nx.prt("|cffff0000No items to output|r")
+        return
+    end
+    
+    -- Count points and rectangles
+    local points = 0
+    local rects = 0
+    for _, data in ipairs(self.EditRectangles) do
+        if data.isPoint then
+            points = points + 1
+        else
+            rects = rects + 1
+        end
+    end
+    
+    -- Get mapId from first item (assuming all are same zone)
+    local mapId = self.EditRectangles[1].mapId
+    
+    local summary = ""
+    if rects > 0 and points > 0 then
+        summary = format("%d rectangles, %d points", rects, points)
+    elseif rects > 0 then
+        summary = format("%d rectangles", rects)
+    else
+        summary = format("%d points", points)
+    end
+    
+    Nx.prt("|cff00ff00=== Quest Objective Output (%s) ===|r", summary)
+    Nx.prt("|cffffffffMap ID: |cffffd700%d|r", mapId)
+    Nx.prt("")
+    Nx.prt("|cff80ff80Quest database format (copy these lines):|r")
+    
+    for i, data in ipairs(self.EditRectangles) do
+        local str
+        if data.isPoint then
+            -- Format for points: "|mapId|32|x|y|5.01|3.34" (type 32, default size)
+            str = format("\"|%d|32|%.0f|%.0f|5.01|3.34\"", 
+                data.mapId, data.x, data.y)
+        else
+            -- Format for rectangles: "|mapId|35|x|y|w|h" (type 35 for rectangles)
+            str = format("\"|%d|35|%.0f|%.0f|%.2f|%.2f\"", 
+                data.mapId, data.x, data.y, data.w, data.h)
+        end
+        Nx.prt("|cffffffff  %s|r", str)
+    end
+    
+    Nx.prt("")
+    Nx.prt("|cff808080Raw coordinates:|r")
+    for i, data in ipairs(self.EditRectangles) do
+        if data.isPoint then
+            Nx.prt("|cff80ffff  [%d] POINT MapId=%d X=%.2f Y=%.2f|r", 
+                i, data.mapId, data.x, data.y)
+        else
+            Nx.prt("|cff808080  [%d] RECT  MapId=%d X=%.2f Y=%.2f W=%.2f H=%.2f|r", 
+                i, data.mapId, data.x, data.y, data.w, data.h)
+        end
+    end
+    
+    -- Generate hex-encoded string for rectangles (sorted by X)
+    if rects > 0 then
+        -- Collect rectangles only
+        local rectList = {}
+        for _, data in ipairs(self.EditRectangles) do
+            if not data.isPoint then
+                table.insert(rectList, data)
+            end
+        end
+        
+        -- Sort by top-left X coordinate
+        table.sort(rectList, function(a, b) return a.x < b.x end)
+        
+        -- Helper function to convert to padded hex
+        local function toHex3(val)
+            local hex = format("%X", floor(val + 0.5))
+            while #hex < 3 do
+                hex = "0" .. hex
+            end
+            return strlower(hex)
+        end
+        
+        -- Generate hex strings
+        local hexParts = {}
+        for _, rect in ipairs(rectList) do
+            local zw = rect.w / 100 * 1002
+            local zh = rect.h / 100 * 668
+            local wx = rect.x * 4095 / 100
+            local wy = rect.y * 4095 / 100
+            local ww = zw * 4095 / 1002
+            local wh = zh * 4095 / 668
+            
+            local hexx = toHex3(wx)
+            local hexy = toHex3(wy)
+            local hexw = toHex3(ww)
+            local hexh = toHex3(wh)
+            
+            table.insert(hexParts, hexx .. hexy .. hexw .. hexh)
+        end
+        
+        local hexString = table.concat(hexParts)
+        Nx.prt("")
+        Nx.prt("|cffffaa00Hex-encoded rectangles (sorted by X):|r")
+        Nx.prt("|cffffffff  %s|r", hexString)
+    end
+    
+    -- Clear all items
+    self:EditModeClearRectangles()
+    Nx.prt("|cff00ff00Output complete - cleared|r")
+end
+
 -------------------------------------------------------------------------------
 -- DEBUG/TEST CODE
 -- Development and debugging utilities
diff --git a/CarboniteClassic.toc b/CarboniteClassic.toc
index 596597d..a82df63 100644
--- a/CarboniteClassic.toc
+++ b/CarboniteClassic.toc
@@ -1,4 +1,4 @@
-## Interface: 50501, 11508
+## Interface: 50502, 11508
 ## Title: Carbonite Maps - Classic
 ## Version: @project-version@
 ## Notes: Released Under GPL
